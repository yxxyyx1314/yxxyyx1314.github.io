<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>myblog</title>
  
  <subtitle>Desire is the starting point of all achievement</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ylovex.cn/"/>
  <updated>2019-06-30T01:42:36.666Z</updated>
  <id>http://ylovex.cn/</id>
  
  <author>
    <name>Yang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LMS算法</title>
    <link href="http://ylovex.cn/2019/06/29/LMS%E7%AE%97%E6%B3%95/"/>
    <id>http://ylovex.cn/2019/06/29/LMS算法/</id>
    <published>2019-06-29T12:07:05.000Z</published>
    <updated>2019-06-30T01:42:36.666Z</updated>
    
    <content type="html"><![CDATA[<p>自适应滤波就是利用前一时刻获得的滤波器参数来自动调节现时刻的滤波器参数，以适应信号和噪声随时间变化的统计特性，从而实现最优滤波。</p><p><img src="2019629001.jpg" alt="jpg"></p><p>主输入端接收带噪信号，参考端为噪声信号，其中参考信号vi是与主输入端中信号s无关但与vo相关的噪声信号，利用量输入信号的相关性和有用信号与噪声的独立性，使参考信号尽可能逼近主输入端中的vo并相减从而抵消掉主输入端中的噪声干扰，最终得到有用信号。</p><p><strong>算法代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function [yn,w,en,itr]=LMSALG(xn,dn,M,mu,itr)</span><br><span class="line">% LMS(Least Mean Squre)算法</span><br><span class="line">% 输入参数:</span><br><span class="line">%     xn   输入的信号序列      (列向量) </span><br><span class="line">%     dn   所期望的响应序列    (列向量) </span><br><span class="line">%     M    滤波器的阶数        (标量)  </span><br><span class="line">%     mu   收敛因子(步长)      (标量)     要求大于0,小于xn的相关矩阵最大特征值的倒数      </span><br><span class="line">%     itr  迭代次数            (标量)     默认为xn的长度,M &lt; itr &lt;= length(xn) </span><br><span class="line">% 输出参数:  </span><br><span class="line">%     w    滤波器的权值矩阵     (矩阵) </span><br><span class="line">%          大小为M*itr,  </span><br><span class="line">%     en   误差序列(itr*1)    (列向量)   </span><br><span class="line">%     yn   实际输出序列         (列向量)</span><br><span class="line"></span><br><span class="line">% 确定迭代次数，若输入迭代次数itr，则设置为itr；若没有该参数，则设置为输入信号长度</span><br><span class="line">% 参数个数必须为4个或5个</span><br><span class="line">if nargin == 4    %  4个时递归迭代的次数为xn的长度</span><br><span class="line">    itr = length(xn);</span><br><span class="line">elseif nargin == 5     %  5个时需满足 M &lt; itr &lt; length(xn)     </span><br><span class="line">    if itr &gt; length(xn) || itr &lt; M          </span><br><span class="line">        error(&apos;迭代次数过大或过小!&apos;);     </span><br><span class="line">    end</span><br><span class="line">else</span><br><span class="line">    error(&apos;请检查输入参数的个数!&apos;); </span><br><span class="line">end  % 初始化参数</span><br><span class="line"></span><br><span class="line">en = zeros(itr,1);     % 误差序列,en(k)表示第k次迭代时预期输出与实际输入的误差</span><br><span class="line">w  = zeros(itr,M);     % 每一行代表一个加权参量,每一列代表-次迭代,初始为0</span><br><span class="line">% w权系数取为矩阵主要是为了判断该算法的收敛性</span><br><span class="line">xn_r=xn&apos;; %%%%参考行向量</span><br><span class="line">dn_r=dn&apos;; %%%%nmr行向量</span><br><span class="line">% 迭代计算</span><br><span class="line">for kitr = M:itr    % 第k次迭代</span><br><span class="line">    x = xn(kitr:-1:kitr-M+1);    % 滤波器M个抽头的输入</span><br><span class="line">    y = w(kitr-1,:)*x;    % 滤波器的输出 </span><br><span class="line">    en(kitr) = dn(kitr) - y;     % 第k次迭代的误差</span><br><span class="line">    % 滤波器权值计算的迭代式</span><br><span class="line">    w(kitr,:) = w(kitr-1,:) + 2*mu*en(kitr)*x&apos;;%%xn(kitr-M+1:kitr)&apos;;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%%%方法一、直接使用filter函数来进行滤波处理</span><br><span class="line">CancellationData = filter(w(end,:),1,xn_r);  % 直接使用filter函数来进行滤波处理</span><br><span class="line">yn = dn_r-CancellationData;</span><br><span class="line">yn = yn(M+1:end);% 去掉与滤波系数长度对应的前N个点</span><br><span class="line">yn=yn&apos;; %%输出行向量</span><br><span class="line"></span><br><span class="line">% % 求最优时滤波器的输出序列</span><br><span class="line">% yn = zeros(size(xn)); </span><br><span class="line">% for kitr = M:length(xn)</span><br><span class="line">%     x = xn(kitr:-1:kitr-M+1);</span><br><span class="line">%     yn(kitr) = dn(kitr) - w(end,:)*x;   % w(:,end)为最后一次迭代生成的滤波器系数</span><br><span class="line">% end</span><br><span class="line">% yn = yn(M:end);  % 前面M个数据没有经过滤波处理，所以设置成inf，绘图时不显示</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自适应滤波就是利用前一时刻获得的滤波器参数来自动调节现时刻的滤波器参数，以适应信号和噪声随时间变化的统计特性，从而实现最优滤波。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2019629001.jpg&quot; alt=&quot;jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;主输入端接收带噪信号，参考端为噪声信号，其
      
    
    </summary>
    
      <category term="信号处理" scheme="http://ylovex.cn/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
      <category term="lms" scheme="http://ylovex.cn/tags/lms/"/>
    
  </entry>
  
  <entry>
    <title>Java List面经</title>
    <link href="http://ylovex.cn/2019/06/28/java-list%E9%9D%A2%E7%BB%8F/"/>
    <id>http://ylovex.cn/2019/06/28/java-list面经/</id>
    <published>2019-06-28T13:54:41.000Z</published>
    <updated>2019-06-29T14:19:10.807Z</updated>
    
    <content type="html"><![CDATA[<h3 id="List实现原理"><a href="#List实现原理" class="headerlink" title="List实现原理"></a>List实现原理</h3><h3 id="ArrayList实现原理"><a href="#ArrayList实现原理" class="headerlink" title="ArrayList实现原理"></a>ArrayList实现原理</h3><h3 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h3><h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><h3 id="线程安全List"><a href="#线程安全List" class="headerlink" title="线程安全List"></a>线程安全List</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;List实现原理&quot;&gt;&lt;a href=&quot;#List实现原理&quot; class=&quot;headerlink&quot; title=&quot;List实现原理&quot;&gt;&lt;/a&gt;List实现原理&lt;/h3&gt;&lt;h3 id=&quot;ArrayList实现原理&quot;&gt;&lt;a href=&quot;#ArrayList实现原理&quot; c
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
      <category term="List" scheme="http://ylovex.cn/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Java Map面经</title>
    <link href="http://ylovex.cn/2019/06/28/java-map%E9%9D%A2%E7%BB%8F/"/>
    <id>http://ylovex.cn/2019/06/28/java-map面经/</id>
    <published>2019-06-28T13:54:41.000Z</published>
    <updated>2019-06-29T12:03:20.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h3><h3 id="JDK1-8前后HashMap区别"><a href="#JDK1-8前后HashMap区别" class="headerlink" title="JDK1.8前后HashMap区别"></a>JDK1.8前后HashMap区别</h3><h3 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h3><h3 id="HashMap多线程问题"><a href="#HashMap多线程问题" class="headerlink" title="HashMap多线程问题"></a>HashMap多线程问题</h3><h3 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h3><h3 id="HashTable和synchronizedMap和ConcurrentHashMap"><a href="#HashTable和synchronizedMap和ConcurrentHashMap" class="headerlink" title="HashTable和synchronizedMap和ConcurrentHashMap"></a>HashTable和synchronizedMap和ConcurrentHashMap</h3><h3 id="ConcurrentHashMap-JDK1-8"><a href="#ConcurrentHashMap-JDK1-8" class="headerlink" title="ConcurrentHashMap JDK1.8"></a>ConcurrentHashMap JDK1.8</h3><h3 id="HashMap读取与写入"><a href="#HashMap读取与写入" class="headerlink" title="HashMap读取与写入"></a>HashMap读取与写入</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HashMap实现原理&quot;&gt;&lt;a href=&quot;#HashMap实现原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap实现原理&quot;&gt;&lt;/a&gt;HashMap实现原理&lt;/h3&gt;&lt;h3 id=&quot;JDK1-8前后HashMap区别&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
      <category term="Map" scheme="http://ylovex.cn/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java Set面经</title>
    <link href="http://ylovex.cn/2019/06/28/java-set%E9%9D%A2%E7%BB%8F/"/>
    <id>http://ylovex.cn/2019/06/28/java-set面经/</id>
    <published>2019-06-28T13:54:41.000Z</published>
    <updated>2019-06-29T14:17:09.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Set种类"><a href="#Set种类" class="headerlink" title="Set种类"></a>Set种类</h3><h3 id="Set实现原理"><a href="#Set实现原理" class="headerlink" title="Set实现原理"></a>Set实现原理</h3><h3 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h3><h3 id="HashSet和HashMap"><a href="#HashSet和HashMap" class="headerlink" title="HashSet和HashMap"></a>HashSet和HashMap</h3><h3 id="HashSet和TreeSet"><a href="#HashSet和TreeSet" class="headerlink" title="HashSet和TreeSet"></a>HashSet和TreeSet</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Set种类&quot;&gt;&lt;a href=&quot;#Set种类&quot; class=&quot;headerlink&quot; title=&quot;Set种类&quot;&gt;&lt;/a&gt;Set种类&lt;/h3&gt;&lt;h3 id=&quot;Set实现原理&quot;&gt;&lt;a href=&quot;#Set实现原理&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
      <category term="Set" scheme="http://ylovex.cn/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础知识</title>
    <link href="http://ylovex.cn/2019/06/28/java-%E5%9F%BA%E7%A1%80/"/>
    <id>http://ylovex.cn/2019/06/28/java-基础/</id>
    <published>2019-06-28T13:43:41.000Z</published>
    <updated>2019-06-29T14:40:40.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h3><ol><li>面向过程：是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。</li><li>面向对象：是以“对象”为中心的编程思想。</li><li>面向对象三大特性：封装、继承、多态。因为一切皆对象，所以一切都需要“封装”成类。“继承”让我们设计相似的东西的时候更方便，而“多态”让我们使用类似的东西的时候可以不用去思考它们微弱的不同。我们关心的不是过程，而是接口，而接口来自对象，故名为面向对象。</li></ol><h3 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h3><ol><li>封装：通过隐藏类的内部实现机制，对外界提供已经定义好的接口进行访问。对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。</li><li>继承：是从已有的类得到继承信息创建新的类的过程，继承可以表示为is-a关系，让我们设计相似的东西的时候更加的方便。</li><li>多态：可以分为方法重载和方法重写两种方式，方法重载是在编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致；方法重写是运行时多态（也称为后绑定），实现方法重写：1.方法重写，子类继承父类并重写父类方法；2.用父类型引用来引用子类型对象，实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li></ol><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol><li><p>Java的反射机制允许我们动态的调用某个对象的方法、构造函数、获取某个对象的属性等；</p></li><li><p>无需在编码的时候确定调用的对象</p></li><li><p>实现方式：</p><ol><li><p>先获取这个类的class实例，比如:Class&lt;?&gt; myClass =Class.<strong>forName</strong>(“myClassName”);</p></li><li><p>然后通过这个类实例获得一个类对象，比如：Object myClassObject = myClass.newInstance();</p></li><li><p>然后调用Class类的对象的<strong>getMethod</strong>获取method对象;</p></li><li><p>获取method对象后调用method.<strong>invoke</strong>方法获取这个类的field、method、construct等，在这一步中，JVM默认如果调用次数小于15次，会调用native方法实现反射，累积调用大于15次之后，会由java代码创建出字节码来实现反射。</p></li></ol></li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h5 id="实现了Collection接口的集合类："><a href="#实现了Collection接口的集合类：" class="headerlink" title="实现了Collection接口的集合类："></a>实现了Collection接口的集合类：</h5><ol><li><p>Collection&lt;–List&lt;–Vector</p></li><li><p>Collection&lt;–List&lt;–ArrayList</p></li><li><p>Collection&lt;–List&lt;–LinkedList</p></li><li><p>Collection&lt;–Set&lt;–HashSet </p></li><li><p>Collection&lt;–Set&lt;–HashSet&lt;–LinkedHashSet</p></li><li><p>Collection&lt;–Set&lt;–SortedSet&lt;–TreeSet</p></li></ol><h5 id="实现了Map接口，和Collection接口没关系，但都属于集合类的一部分："><a href="#实现了Map接口，和Collection接口没关系，但都属于集合类的一部分：" class="headerlink" title="实现了Map接口，和Collection接口没关系，但都属于集合类的一部分："></a>实现了Map接口，和Collection接口没关系，但都属于集合类的一部分：</h5><ol><li><p>HashMap</p></li><li><p>HashTable</p></li><li><p>LinkedHashMap</p></li><li><p>TreeMap</p></li><li><p>SynchronizedMap</p></li><li><p>ConcurrentHashMap</p></li><li></li></ol><h3 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h3><h5 id="被final声明的对象即表示“我不想这个对象再被改变”，因此："><a href="#被final声明的对象即表示“我不想这个对象再被改变”，因此：" class="headerlink" title="被final声明的对象即表示“我不想这个对象再被改变”，因此："></a>被final声明的对象即表示“我不想这个对象再被改变”，因此：</h5><ol><li>被final声明的方法：这个方法不可以被子类重写</li><li>被final声明的类：这个类不能被继承</li><li>被final声明的变量：引用不能改变，常和static关键字一起使用作为常量<br>final关键字的好处：</li><li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li><li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li><li>使用final关键字，JVM会对方法、变量及类进行优化。</li></ol><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><ol><li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li><li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li><li>使用final关键字，JVM会对方法、变量及类进行优化。</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>boolean byte char ：都是一个字节</p></li><li><p>short int long float double ：int是4个字节，负2的31次方到正2的31次方减1</p></li><li><p>String Enum Array</p></li><li><p>Object</p><p>ps：负数使用补码表示</p><p>Primitive type:  int,long,float…</p><p>Object: Integer,Long,Float,String…</p><p>Primitive type:</p><ol><li>值类型</li><li>用a==b判断相等</li></ol><p>Object：</p><ol><li>引用类型</li><li>用a==b判断是否为同一个Object</li><li>用a.equals(b),或者Obeject.equals(a,b)判断是否相等</li><li>两个Object如果不是同一个Object，即使值相等用==判断也是false</li></ol></li></ol><h3 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h3><h6 id="基于空间的考虑："><a href="#基于空间的考虑：" class="headerlink" title="基于空间的考虑："></a>基于空间的考虑：</h6><ol><li>数组的存储空间是静态，连续分布的，初始化的过大造成空间浪费，过小又将使空间溢出机会增多。而链表的存储空间是动态分布的，只要内存空间尚有空闲，就不会产生溢出；链表中每个节点出了数据域外，还有链域（指向下一个节点），这样空间利用率就会变高。</li><li>数组从栈中分配空间，对于程序员方便快速，但是自由度小。链表从堆中分配空间，自由度大但是申请管理比较麻烦。</li><li>数组中的数据在内存中按顺序存储的，而链表是随机存储的。</li></ol><h6 id="基于时间的考虑："><a href="#基于时间的考虑：" class="headerlink" title="基于时间的考虑："></a>基于时间的考虑：</h6><ol><li>数组查询快，插入与删除慢，单链表查询慢，插入与删除快。细说的话：数组中任意节点都可以在O（1）内直接存储访问，而链表中的节点，需从头指针顺着链表扫描才能获取到；而链表任意位置进行插入和删除，都只需要修改指针，而数组中插入删除节点，平均要移动一半的节点。</li></ol><h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><table><thead><tr><th></th><th>public</th><th>protected</th><th>defailt</th><th>private</th></tr></thead><tbody><tr><td>同一个类</td><td>True</td><td>True</td><td>True</td><td>True</td></tr><tr><td>同一个包</td><td>True</td><td>True</td><td>True</td><td>False</td></tr><tr><td>子父类</td><td>True</td><td>True</td><td>False</td><td>False</td></tr><tr><td>不同包</td><td>True</td><td>False</td><td>False</td><td>False</td></tr></tbody></table><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>抽象类就是比普通类多了一些抽象方法而已，其他部分和普通类完全一样；而接口是特殊的抽象类。<br>作用上看：</p><ol><li><p>接口与抽象类结构有点像，但功能完全不同</p></li><li><p>接口是强调合约、约束关系，即你要与我合作，必须实现我的功能；抽象类没这个功能</p></li></ol><p>语法上看：</p><ol><li>都不能被实例化</li><li>接口是特殊的抽象类</li><li>接口不能有实现，Java8中可以有添加default关键字的默认实现和静态方法实现。</li><li>接口中的成员变量必须是public static final修饰（编译器默认会添加上），因此是常量</li><li>一个类可以实现多个接口但只能继承一个抽象类</li></ol><p>什么是接口？</p><ol><li>从表现来说：定义了很多函数，但是这些函数都没有实现，这就是接口。从作用来说：起到一个合约规范的作用。我要告诉你和我打交道的东西有什么约束</li><li>接口中的方法只能用public和abstract修饰或者不修饰</li><li>接口中的属性默认都是public static final，因此是常量</li></ol><h3 id="equal与"><a href="#equal与" class="headerlink" title="equal与=="></a>equal与==</h3><p>对于字符串变量：</p><p>==：比较两个对象在内存中的首地址</p><p>equals：比较字符串中所包含的内容是否相同</p><p>对于非字符串变量：</p><p>==和equals都是比较对象在堆内存中的首地址。</p><h3 id="装箱及拆箱"><a href="#装箱及拆箱" class="headerlink" title="装箱及拆箱"></a>装箱及拆箱</h3><p>Integer i = 10; //装箱</p><p>int n = i ;//拆箱</p><p>装箱就是自动将基本数据类型转换为包装器类型。</p><p>拆箱就是自动将包装器类型转换为基本数据类型。</p><h3 id="hashCode方法及作用"><a href="#hashCode方法及作用" class="headerlink" title="hashCode方法及作用"></a>hashCode方法及作用</h3><p>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的 字段等）映射成一个数值，这个数值称作为散列值。</p><p>1、在Java集合中有两类，一类是List，一类是Set。他们之间的区别就在于List集合中的元素是有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知<br>2、当集合要添加新的对象时，先调用这个对象的 hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode 值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址<br>3、所以hashCode在上面扮演的角色为快速寻域（寻找某个对象在集合中区域位置）</p><p>在重写equals方法的同时，必须重写hashCode方法。为什么这么说呢？<br>1、让equals方法和hashCode方法始终在逻辑上保持一致性<br>2、即让equals认为相等的两个对象，这两个对象同时调用hashCode方法，返回的值也是一样的</p><h3 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h3><p>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p><p>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</p><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p><p>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p><p>Date Time API − 加强对日期与时间的处理。</p><p>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p><p>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p><h3 id="Java-NIO框架对比"><a href="#Java-NIO框架对比" class="headerlink" title="Java NIO框架对比"></a>Java NIO框架对比</h3><p>Mina</p><p>Mina(Multipurpose Infrastructure for Network Applications) 是 Apache 组织一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 Mina 版本2.04支持基于 Java NIO 技术的 TCP/UDP 应用程序开发、串口通讯程序，Mina 所支持的功能也在进一步的扩展中。</p><p>Netty</p><p>Netty是一款异步的事件驱动的网络应用框架和工具，用于快速开发可维护的高性能、高扩展性协议服务器和客户端。也就是说，Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器。</p><p>Grizzly</p><p>Grizzly是一种应用程序框架，专门解决编写成千上万用户访问服务器时候产生的各种问题。使用JAVA NIO作为基础，并隐藏其编程的复杂性。容易使用的高性能的API。带来非阻塞socketd到协议处理层。利用高性能的缓冲和缓冲管理使用高性能的线程池。</p><p>xSocket</p><p>xSocket是一个轻量级的基于nio的服务器框架用于开发高性能、可扩展、多线程的服务器。该框架封装了线程处理、异步读/写等方面。（只是对Java的NIO做了最简单的封装，以便于开发使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象和面向过程&quot;&gt;&lt;a href=&quot;#面向对象和面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向对象和面向过程&quot;&gt;&lt;/a&gt;面向对象和面向过程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面向过程：是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://ylovex.cn/2019/06/28/my-first-blog/"/>
    <id>http://ylovex.cn/2019/06/28/my-first-blog/</id>
    <published>2019-06-28T13:41:41.000Z</published>
    <updated>2019-06-29T14:47:25.595Z</updated>
    
    <content type="html"><![CDATA[<p>Desire is the starting point of all achievement</p><p>渴望是所有成就的原点。</p><p>love xy </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Desire is the starting point of all achievement&lt;/p&gt;
&lt;p&gt;渴望是所有成就的原点。&lt;/p&gt;
&lt;p&gt;love xy &lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="http://ylovex.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="http://ylovex.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://ylovex.cn/2019/06/28/hello-world/"/>
    <id>http://ylovex.cn/2019/06/28/hello-world/</id>
    <published>2019-06-28T05:32:33.400Z</published>
    <updated>2019-06-28T05:32:33.400Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
