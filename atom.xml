<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人生如逆旅，我亦是行人</title>
  
  <subtitle>Desire is the starting point of all achievement</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ylovex.cn/"/>
  <updated>2019-07-18T13:59:30.839Z</updated>
  <id>http://ylovex.cn/</id>
  
  <author>
    <name>Yang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java多线程基础</title>
    <link href="http://ylovex.cn/2019/07/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://ylovex.cn/2019/07/16/java多线程基础/</id>
    <published>2019-07-16T13:55:11.000Z</published>
    <updated>2019-07-18T13:59:30.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h2><h3 id="并行基础概念"><a href="#并行基础概念" class="headerlink" title="并行基础概念"></a>并行基础概念</h3><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>同步和异步通常是形容一次方法的调用，同步方法调用一旦开始，调用者必须等到方法调用返回后才能继续后续的行为；异步调用更像一个消息传递，一旦开始，方法调用就会立即放回，调用者可以继续后续的操作，而异步方法通常会在另外一个线程中“真实”的执行。</p><h5 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h5><p>并发侧重于多个任务交替执行，并行是真实的同时执行，真实的并行只可能出现在多核CPU中</p><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是一次只能有一个线程使用，一旦临界区资源被占用，其他线程想到使用这个资源必须等待</p><h5 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h5><p>当一个线程占用了临界区资源，其他所以需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起，这种情况就是阻塞。</p><h5 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h5><p>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p>饥饿是某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。</p><p>活锁是两个线程主动将资源释放给对方用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。</p><h5 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h5><p>可以分为阻塞、无饥饿、无障碍、无锁、无等待等</p><p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当使用synchronized关键字或者重入锁，得到的就是阻塞的线程</p><p>如果线程之间是有优先级的，那么线程调度的时候总会倾向于满足高优先级的线程，对于非公平锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。但如果锁是公平的，满足先来后到，那么饥饿就不会产生</p><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方挂起，对于无障碍线程，当检测到多个线程修改共享数据就会立即对自己所做的修改进行回滚，确保数据安全，如果没有数据竞争发生就可以顺利完成任务</p><p>无锁的并行都是无障碍的，在无锁的情况下，所有的线程都尝试对临界区进行访问，但不同的是无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区</p><p>无等待在无锁的基础上更进一步，要求所有的线程都必须在有限步内完成，一种典型的无等待结构就是RCU（Read-Copy-Update）基本思想是对数据的读可以不就控制，但在写数据的时候，先取得原始数据的副本，接着只修改副本数据，修改完成后，在合适的时机回写数据</p><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>是指一个操作是不可中断的，即使是多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰</p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>是指一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改</p><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致</p><h3 id="Java并行基础"><a href="#Java并行基础" class="headerlink" title="Java并行基础"></a>Java并行基础</h3><h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</p><p>线程是程序执行的最小单位，使用多线程而不是多进程进行并发程序设计是因为线程间的切换和调度的成本远小于进程</p><h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><p><img src="201907160001.png" alt="37812319"></p><h5 id="New状态"><a href="#New状态" class="headerlink" title="New状态"></a>New状态</h5><p>当使用new创建一个Thread对象时候，此时并不处于执行状态</p><h5 id="Runnable状态"><a href="#Runnable状态" class="headerlink" title="Runnable状态"></a>Runnable状态</h5><p>调用start方法后，那么此时才是真正在JVM进程中创建了一个线程，该状态线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权</p><h5 id="Running状态"><a href="#Running状态" class="headerlink" title="Running状态"></a>Running状态</h5><p>可运行状态（Runnable）的线程获得CPU时间片，执行程序代码</p><h5 id="Blocked状态"><a href="#Blocked状态" class="headerlink" title="Blocked状态"></a>Blocked状态</h5><p>是指线程因为某种原因放弃了cpu的使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><ol><li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li><li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li><li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或运行在当前线程里的其它线程调用了join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ol><h5 id="Dead状态"><a href="#Dead状态" class="headerlink" title="Dead状态"></a>Dead状态</h5><p>线程run(),main()方法执行结束，或者因为异常退出了run()方法，则该线程结束生命周期</p><h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><h5 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h5><p>只需要使用new关键字创建一个线程对象，并且将它start()起来即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = new Thread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>start()方法就会新建一个线程并让这个线程执行run()方法</p><p>如果直接调用run()方法不会新建一个线程，而是只会在当前线程中，串行执行run()中的代码</p><ol><li>继承Thread创建线程</li><li>实现Runnanle接口创建线程</li><li>实现Callable接口通过FutureTask包装器来创建线程</li><li>使用ExecutorService、Callable、Future实现有返回结果的线程</li></ol><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>stop()方法，可以立即将线程终止，已被标记为废弃</p><p>强行把执行到一半的线程终止，可能会引起一些数据不一致问题</p><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><p>线程中断不会使线程立即退出，而是给线程发送一个通知告知目标线程希望其退出，至于目标线程接到通知后如何处理则完全由线程自行决定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void Thread.interrupt() //中断线程</span><br><span class="line">public boolean Thread.isInterrupted() //判断是否被中断</span><br><span class="line">public static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态</span><br></pre></td></tr></table></figure><p>Thread.interrupt()是一个实例方法，它通知目标线程中断，也就是设置设置中断标志位。中断标志位表示当前线程已经被中断了。Thread.isInterrupted()方法也是实例方法，它判断当前线程是否被中断（通过检查中断标志位）。Thread.interrupted()是静态方法，也是判断中断状态，但同时会清除当前线程的中断标志位状态。</p><p>interrupted()作用于当前线程，interrupt()和isInterrupted()作用于调用此方法的实例所代表的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void sleep(long millis) throws InterruptedException</span><br><span class="line">public static void sleep(long millis, int nanos) throws InterruptedException</span><br></pre></td></tr></table></figure><p>sleep()方法会让当前线程休眠若干时间，它会抛出一个InterruptedException中断异常。InterruptedException不是运行时异常，也就是程序必须捕获处理，当线程在sleep()休眠时，如果被中断，这个异常就会产生</p><h5 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h5><p>这两个方法输出Object类，任何对象都可以调用</p><p>当在一个对象实例上调用了wait方法后，当前线程就会在这个对象上等待，比如一个线程调用了object.wait()，那么它就会进入这个object对象的等待队列。这个等待队列中可能有多个线程在等待，当object.notify()被调用的时候，就会从这个等待队列中随机选择一个线程唤醒，这个选择是不公平的，完全随机的</p><p>notifyAll()方法会唤醒在这个等待队列中所有的等待的线程</p><p>wait()和notify()方法必须包含哎对应的synchronzied语句中，都需要首先获得目标对象的一个监视器，</p><p>wait和sleep方法都可以让线程等待若干时间，wait方法会释放目标对象的锁，而sleep方法不会释放任何资源</p><h5 id="挂起suspend和继续执行resume线程"><a href="#挂起suspend和继续执行resume线程" class="headerlink" title="挂起suspend和继续执行resume线程"></a>挂起suspend和继续执行resume线程</h5><p>不推荐使用，suspend方法在导致线程暂停的同时，并不会去释放任何锁资源，直到对应线程上进行了resume方法被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行，但是如果resume操作意外的在suspend前执行会导致所占用的锁不会被释放。</p><h5 id="等待线程结束join和谦让yield"><a href="#等待线程结束join和谦让yield" class="headerlink" title="等待线程结束join和谦让yield"></a>等待线程结束join和谦让yield</h5><p>当一个线程的输入可能非常依赖另外一个或者多个线程的输出时候。此时这个线程就需要等待依赖线程执行完毕才能继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptException</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException</span><br></pre></td></tr></table></figure><p>第一个join方法表示无限等待，它会一直阻塞当前线程，直到目标线程执行完毕，第二个方法给出了一个最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因为等不及了而继续往下执行</p><p>join方法本质是让调用线程wait()在当前线程对象实例上，它让调用线程在当前对象上进行等待，当线程执行完成后，被等待的线程会在退出前调用notifyAll通知所有的等待线程继续执行 。因此不要在应用程序中，在Thread对象实例上使用类似wait或者notify等方法</p><p>yield方法是一个静态方法，会使当前线程让出CPU，但是让出后该线程还会进行CPU资源的争夺</p><h4 id="volatile与Java内存模型（JMM）"><a href="#volatile与Java内存模型（JMM）" class="headerlink" title="volatile与Java内存模型（JMM）"></a>volatile与Java内存模型（JMM）</h4><p>在计算机中，所有的运算操作都是由CPU的寄存器完成，CPU指令的执行过程需要涉及数据的读取和写入操作，由于CPU的处理速度和内存的访问速度之间的差距越来越大，增加了缓存的设计</p><p> <img src="201907160002.png" alt="23131123"></p><p>由于缓存的出现，极大地提高了CPU的吞吐模型，但是同时也引入了缓存不一致的问题，比如i++操作，在程序的运行过程中，首先需要将主内存中的数据复制一份存放到CPU Cache中，那么CPU寄存器在进行数值计算的时候就直接到Cache中读取和写入，当整个过程运算结束之后再将Cache中的数据刷新到主存当中，</p><p>i++在单线程中不会出现问题，但是在多线程中就会出现问题，为了解决缓存不一致的问题，通常主流解决办法有：通过总线加锁的方式，通过缓存一致性协议</p><p> 在缓存一致性协议中最为出名的是Intel的MESI协议，MESI协议保证了每一个缓存中使用的共享变量副本都是一致的，它的大致思想是，当CPU在操作Cache数据的时，如果发现该变量是一个共享变量，也就是说在其他CPU Cache中也存在一个副本，那么：</p><ol><li>读取操作，不做任何处理，只是将Cache中的数据读取到寄存器</li><li>写入操作，发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU在进行该变量读取的时候不得不到主内存中再次获取</li></ol><h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p> Java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系，具体有：</p><ol><li>共享内存存储在主内存之中，每个线程都可以访问</li><li>每个线程都有私有的工作内存或者称为本地内存</li><li>工作内存只存储该线程对共享变量的副本</li><li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存</li><li>工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等</li></ol><p><img src="201907160003.png" alt="12311414"></p><h5 id="JMM与原子性"><a href="#JMM与原子性" class="headerlink" title="JMM与原子性"></a>JMM与原子性</h5><p>对基本数据类型的变量读取赋值操作是原子性，对引用类型的变量读取和赋值操作也是原子性的</p><ol><li><p>x=10 原子性</p></li><li><p>y=x 非原子</p></li><li><p>y++ 非原子</p></li><li><p>z=z+1 非原子</p><p>JMM只保证了基本读取和赋值的原子性操作，如果想要使得某些代码片段具备原子性，需要使用关键字synchronized，或者JUC中的lock。如果想要使得int等类型自增操作具备原子性，可以使用JUC包下的原子封装类型java.util.concurrent.atomic.*</p></li></ol><p>volatile关键字不具备原子性的语义</p><h5 id="JMM与可见性"><a href="#JMM与可见性" class="headerlink" title="JMM与可见性"></a>JMM与可见性</h5><p>使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作要先修改工作内存，但是修改结束后会立刻将其刷新到主内存中</p><p>同通过synchronized关键字，能够保证同一个时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中</p><p>通过JUC提供的显式锁Lock</p><h5 id="JMM与有序性"><a href="#JMM与有序性" class="headerlink" title="JMM与有序性"></a>JMM与有序性</h5><p>在Java内存模型中，允许编译器和处理器对指令进行重排列，</p><ol><li>使用volatile</li><li>使用synchronized</li><li>使用Lock</li></ol><h5 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h5><ol><li>程序次序规则：在一个线程内，代码按照编写时的次序执行，但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致</li><li>锁定原则：一个unlock操作要先发生于对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作要早与对这个变量之后的读操作</li><li>传递规则：如果A操作先于B，B先于C，则A肯定先于C</li><li>线程启动规则：Thread对象的start方法要先行发生于对该线程的任何动作</li><li>线程中断规则：对线程执行interrupt方法肯定要优先于捕获到中断信号</li><li>线程终结规则：线程中所有的操作都要先行发生于线程的终止检测</li><li>对象的终结规则：一个对象初始化的完成要先行发生在finalize()方法前</li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p> 被volatile修饰的实例变量或者类变量具备如下两层语义：</p><ol><li>保证了不同线程之间对共享变量操作的可见性</li><li>禁止对指令进行重排序操作</li></ol><h5 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h5><p> 被volatile修饰的变量存在于一个“lock；”的前缀中，</p><p><img src="201907160004.png" alt="13123"></p><p>“lock；”前缀实际上相当于一个内存屏障，该内存屏障会为指令的执行提供如下几个保证：</p><ol><li>确保指令重排序时不会将后面的代码排到内存屏障之前</li><li>确保指令重排序时不会将前面的代码排到内存屏障后</li><li>确保在执行到内存屏障修饰的指令时在前面的代码全部执行完成</li><li>强制将线程工作内存中的值修改刷新到主内存</li><li>如果是写操作，则会导致其他线程工作内存总的缓存数据失效</li></ol><h5 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h5><p>使用上的区别</p><ol><li>volatile关键字只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法参数和局部变量、常量等</li><li>synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块</li><li>volatile修饰的变量可以为null，synchronized同步语句块的monitor对象不能为null</li></ol><p>对原子性的保证</p><ol><li>volatile不能保证原子性</li><li>synchronized可以保证代码的原子性</li></ol><p>对可见性的保证</p><ol><li>都可以保证共享资源在多线程的可见性</li><li>synchronized借助JVM指令monitor enter和monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都将刷新到主内存</li><li>volatile使用机器指令（偏硬件）“lock；”的方式迫使其他线程工作内存中的数据失效，不得不在主内存进行再次加载</li></ol><p>对有序性保证</p><ol><li>volatile禁止JVM编译器以及处理器对其进行重排序，所以保证有序性</li><li>synchronized所修饰的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修饰的代码块代码指令中也会发生指令重排序情况</li></ol><p>其他</p><ol><li>volatile不会使线程陷入阻塞</li><li>synchronized会使线程进入阻塞</li></ol><h5 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h5><p> 在Thread的构造函数中，可以显示的指定线程的Group，也就是ThreadGroup，下面看<code>init</code>方法的中间部分: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">              what to do. */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = security.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">              use the parent thread group. */</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果在构造Thread的时候没有显示的指定一个ThreadGroup，那么子线程将会被加入父线程所在的线程组</p><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p> 守护线程是在后台默默完成一些系统性的服务，比如垃圾回收线程、JIT线程；与之对应的是用户线程，用户线程是系统的工作线程，完成这个程序要完成的业务操作。当用户线程全部结束，只有守护线程时候，Java虚拟机自然退出</p><p><code>setDaemon</code> 方法。<code>isDaemon()</code> 方法可以判断该线程是不是守护线程。</p><p>另外需要注意的就是，<code>setDaemon()</code> 方法只在线程启动之前才能生效，如果一个线程已经死亡，那么再设置 <code>setDaemon()</code> 则会抛出 <code>IllegalThreadStateException</code> 异常。</p><h5 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h5><p>指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁</p><p>直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁</p><p>直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁</p><p>对象的同步Synchronized的底层是通过monitor来完成<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ol><li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p></li><li><p>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p></li><li><p>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p></li></ol><p>释放锁则是通过monitorexit指令，执行monitorexit的线程必须是objectref所对应的monitor的所有者，指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><p>方法的synchronized同步：相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><h3 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h3><h4 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h4><p>重要方法：</p><ol><li>lock():获得锁，如果锁已经被占用，则等待</li><li>lockInterruptibly():获得锁，但是优先响应中断</li><li>tryLock()：尝试获得锁，如果成功返回true，失败返回flae。该方法不等待，立即返回</li><li>tryLock(long time , TimeUnit nuit)：在给定时间内尝试获得锁</li><li>unlock()：释放锁</li></ol><p>在重入锁实现中主要包含三个要素：</p><ol><li>原子状态。原子状态使用CAS操作来存储当前锁的状态，判断锁是否已经被别的线程持有；以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</li><li>等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作</li><li>阻塞原语park()和unpark(),用于挂起和恢复线程,没有得到锁的线程将会被挂起</li></ol><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>通过Lock接口的Condition newCondition()方法可以生成一个与当前重入锁绑定的Condition实例。利用Condition对象，可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行</p><p>Condition接口方法有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException;</span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">void signal();</span><br></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量可以指定多个线程，同时访问某一个资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">       sync = new NonfairSync(permits);</span><br><span class="line">   &#125;</span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">       sync = fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 在构造信号量对象时，必须要指定信号量的准入数，当每个线程每次只申请一个许可时，就相当于指定了同时可以有多少个线程可以访问某个资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public void acquire() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"> public void acquireUninterruptibly() &#123;</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"> public boolean tryAcquire() &#123;</span><br><span class="line">        return sync.nonfairTryAcquireShared(1) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">public boolean tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"> public void release() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemapDemo implements Runnable &#123;</span><br><span class="line">    final Semaphore semp = new Semaphore(5);</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            semp.acquire();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.print(Thread.currentThread().getId()+&quot;:done&quot;);</span><br><span class="line">            semp.release();</span><br><span class="line"></span><br><span class="line">        &#125;catch (InterruptedException e )&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(20);</span><br><span class="line">        final SemapDemo demo = new SemapDemo();</span><br><span class="line">        for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h5><p>​    <img src="201907160005.png" alt="32314"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class RWDictionary &#123;</span><br><span class="line"> *   private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;();</span><br><span class="line"> *   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"> *   private final Lock r = rwl.readLock();</span><br><span class="line"> *   private final Lock w = rwl.writeLock();</span><br><span class="line"> *</span><br><span class="line"> *   public Data get(String key) &#123;</span><br><span class="line"> *     r.lock();</span><br><span class="line"> *     try &#123; return m.get(key); &#125;</span><br><span class="line"> *     finally &#123; r.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public String[] allKeys() &#123;</span><br><span class="line"> *     r.lock();</span><br><span class="line"> *     try &#123; return m.keySet().toArray(); &#125;</span><br><span class="line"> *     finally &#123; r.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public Data put(String key, Data value) &#123;</span><br><span class="line"> *     w.lock();</span><br><span class="line"> *     try &#123; return m.put(key, value); &#125;</span><br><span class="line"> *     finally &#123; w.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public void clear() &#123;</span><br><span class="line"> *     w.lock();</span><br><span class="line"> *     try &#123; m.clear(); &#125;</span><br><span class="line"> *     finally &#123; w.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>通常用来控制线程等待，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class Driver2 &#123; // ...</span><br><span class="line"> *   void main() throws InterruptedException &#123;</span><br><span class="line"> *     CountDownLatch doneSignal = new CountDownLatch(N);</span><br><span class="line"> *     Executor e = ...</span><br><span class="line"> *</span><br><span class="line"> *     for (int i = 0; i &lt; N; ++i) // create and start threads</span><br><span class="line"> *       e.execute(new WorkerRunnable(doneSignal, i));</span><br><span class="line"> *</span><br><span class="line"> *     doneSignal.await();           // wait for all to finish</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * class WorkerRunnable implements Runnable &#123;</span><br><span class="line"> *   private final CountDownLatch doneSignal;</span><br><span class="line"> *   private final int i;</span><br><span class="line"> *   WorkerRunnable(CountDownLatch doneSignal, int i) &#123;</span><br><span class="line"> *     this.doneSignal = doneSignal;</span><br><span class="line"> *     this.i = i;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public void run() &#123;</span><br><span class="line"> *     try &#123;</span><br><span class="line"> *       doWork(i);</span><br><span class="line"> *       doneSignal.countDown();</span><br><span class="line"> *     &#125; catch (InterruptedException ex) &#123;&#125; // return;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   void doWork() &#123; ... &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>也可以实现线程间的计数等待，但是计数器可以循环使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line">* class Solver &#123;</span><br><span class="line">*   final int N;</span><br><span class="line">*   final float[][] data;</span><br><span class="line">*   final CyclicBarrier barrier;</span><br><span class="line">*</span><br><span class="line">*   class Worker implements Runnable &#123;</span><br><span class="line">*     int myRow;</span><br><span class="line">*     Worker(int row) &#123; myRow = row; &#125;</span><br><span class="line">*     public void run() &#123;</span><br><span class="line">*       while (!done()) &#123;</span><br><span class="line">*         processRow(myRow);</span><br><span class="line">*</span><br><span class="line">*         try &#123;</span><br><span class="line">*           barrier.await();</span><br><span class="line">*         &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">*           return;</span><br><span class="line">*         &#125; catch (BrokenBarrierException ex) &#123;</span><br><span class="line">*           return;</span><br><span class="line">*         &#125;</span><br><span class="line">*       &#125;</span><br><span class="line">*     &#125;</span><br><span class="line">*   &#125;</span><br><span class="line">*</span><br><span class="line">*   public Solver(float[][] matrix) &#123;</span><br><span class="line">*     data = matrix;</span><br><span class="line">*     N = matrix.length;</span><br><span class="line">*     Runnable barrierAction =</span><br><span class="line">*       new Runnable() &#123; public void run() &#123; mergeRows(...); &#125;&#125;;</span><br><span class="line">*     barrier = new CyclicBarrier(N, barrierAction);</span><br><span class="line">*</span><br><span class="line">*     List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(N);</span><br><span class="line">*     for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">*       Thread thread = new Thread(new Worker(i));</span><br><span class="line">*       threads.add(thread);</span><br><span class="line">*       thread.start();</span><br><span class="line">*     &#125;</span><br><span class="line">*</span><br><span class="line">*     // wait until done</span><br><span class="line">*     for (Thread thread : threads)</span><br><span class="line">*       thread.join();</span><br><span class="line">*   &#125;</span><br><span class="line">* &#125;&#125;&lt;/pre&gt;</span><br><span class="line">*</span><br></pre></td></tr></table></figure><h5 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h5><p>可以在线程内任意位置让线程阻塞。和Thread。suspend相比，弥补了由于resume在前发生，导致线程无法继续执行的情况。和Object.wait相比，它不需要先获得某个对象的锁，也不会抛出InterruptedException异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class FIFOMutex &#123;</span><br><span class="line"> *   private final AtomicBoolean locked = new AtomicBoolean(false);</span><br><span class="line"> *   private final Queue&lt;Thread&gt; waiters</span><br><span class="line"> *     = new ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class="line"> *</span><br><span class="line"> *   public void lock() &#123;</span><br><span class="line"> *     boolean wasInterrupted = false;</span><br><span class="line"> *     Thread current = Thread.currentThread();</span><br><span class="line"> *     waiters.add(current);</span><br><span class="line"> *</span><br><span class="line"> *     // Block while not first in queue or cannot acquire lock</span><br><span class="line"> *     while (waiters.peek() != current ||</span><br><span class="line"> *            !locked.compareAndSet(false, true)) &#123;</span><br><span class="line"> *       LockSupport.park(this);</span><br><span class="line"> *       if (Thread.interrupted()) // ignore interrupts while waiting</span><br><span class="line"> *         wasInterrupted = true;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     waiters.remove();</span><br><span class="line"> *     if (wasInterrupted)          // reassert interrupt status on exit</span><br><span class="line"> *       current.interrupt();</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   public void unlock() &#123;</span><br><span class="line"> *     locked.set(false);</span><br><span class="line"> *     LockSupport.unpark(waiters.peek());</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>为了避免系统频繁地创建和销毁线程，可以让创建的线程进行复用</p><p>Executor 框架是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p><p>Executor 框架包括：线程池，<code>Executor，Executors，ExecutorService，CompletionService，Future，Callable</code> 等</p><p><img src="201907160006.png" alt="7989898"></p><h5 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法返回一个固定线程数量的线程池，当有一个新任务提交的时候，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法返回一个只有一个线程的线程池，若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法返回一个可根据实际情况调整线程数量的线程池。当有线程来的时候且现在线程池的线程都在工作的时候，才创建新的线程，否则使用空闲的线程，默认情况下，如果某个线程空闲超过60秒就会自动结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">        return new DelegatedScheduledExecutorService</span><br><span class="line">            (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法返回一个ScheduledExecutorService对象，线程池的大小为1，扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法返回一个ScheduledExecutorService对象，但该线程池可以指定线程数量</p><h5 id="ForkJoinPoll"><a href="#ForkJoinPoll" class="headerlink" title="ForkJoinPoll"></a>ForkJoinPoll</h5><p> 核心思想就是分治，Fork分解任务，Join收集数据</p><p>  <img src="201907160007.png" alt="12314"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CountTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">    private static final int THRESHOLD = 10000;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line"></span><br><span class="line">    public CountTask(long start , long end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long compute()&#123;</span><br><span class="line">        long sum = 0;</span><br><span class="line">        boolean canCompute = (end-start)&lt;THRESHOLD;</span><br><span class="line">        if(canCompute)&#123;</span><br><span class="line">            for(long i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //分成100个任务</span><br><span class="line">            long step = (start+end)/100;</span><br><span class="line">            ArrayList&lt;CountTask&gt; subTasks = new ArrayList&lt;&gt;();</span><br><span class="line">            long pos = start;</span><br><span class="line">            for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">                long lastOne = pos + step;</span><br><span class="line">                if(lastOne&gt;end) lastOne=end;</span><br><span class="line">                CountTask subTask = new CountTask(pos,lastOne);</span><br><span class="line">                pos+=step+1;</span><br><span class="line">                subTasks.add(subTask);</span><br><span class="line">                subTask.fork();</span><br><span class="line">            &#125;</span><br><span class="line">            for(CountTask t : subTasks)&#123;</span><br><span class="line">                sum+=t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        CountTask task = new CountTask(0,200000L);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        try&#123;</span><br><span class="line">            long res = result.get();</span><br><span class="line">            System.out.println(&quot;sum=&quot; +res);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h5><p>主要构造方法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line">     * parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line">     *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line">     * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line">     *        pool</span><br><span class="line">     * @param keepAliveTime when the number of threads is greater than</span><br><span class="line">     *        the core, this is the maximum time that excess idle threads</span><br><span class="line">     *        will wait for new tasks before terminating.</span><br><span class="line">     * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line">     * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line">     *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line">     *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line">     * @param threadFactory the factory to use when the executor</span><br><span class="line">     *        creates a new thread</span><br><span class="line">     * @param handler the handler to use when execution is blocked</span><br><span class="line">     *        because the thread bounds and queue capacities are reached</span><br><span class="line">     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line">     *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line">     * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line">     *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line">     */</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参数workQueue指被提交但未执行的任务队列，是一个BlockingQueue接口的对象，仅用于存放Runnable对象。根据队列功能分类，可以使用的BlockingQueue有：</p><p> 直接提交的队列：SynchronousQueue，是一个特殊的BlockingQueue。没有容量，每一个插入都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程数量已经达到最大值则执行拒绝策略</p><p>有界的任务队列：ArrayBlockingQueue，当使用有界的任务队列时，若有新的任务需要执行，如何线程池的实际线程小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务，若大于maximumPoolSize则执行拒绝策略</p><p>无界的任务队列：LinkedBlockingQueue，与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况</p><p>优先任务队列：PriorityBlockingQueue， 可以根据任务自身的优先级顺序先后执行，在确保系统性能的同时，也能够很好的质量保证</p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>ThreadPoolExecutor的最后一个参数指定了拒绝策略，也就是当任务数量超过系统实际承载能力时，需要使用拒绝策略，JDK内置了四种拒绝策略</p><p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</p><p>CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中,运行当前被丢弃的任务，</p><p>DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务</p><p>DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>减少锁持有时间，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量</p><p>减少锁粒度，就是缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力</p><p>读写分离锁来代替独占锁</p><p>锁分离，例如在LinkedBlockingQueue实现中，take和put函数分别实现了从队列中取得数据和往队列中增加数据功能，分别作用于队列的前端和尾端，所以可以通过takeLock和putLock两把锁</p><p>锁粗化，虚拟机在遇到一连串连续地对同一锁进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁粗化</p><h4 id="JDK内部”锁“优化策略"><a href="#JDK内部”锁“优化策略" class="headerlink" title="JDK内部”锁“优化策略"></a>JDK内部”锁“优化策略</h4><p>锁偏向:如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无须再做任何同步操作</p><p>轻量级锁：只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁</p><p>自旋锁：锁的等待者会原地忙等，不停的询问，直到获得锁。采用让当前线程不停地的在循环体内执行实现，当循环的条件被其他线程改变时才能进入临界区。</p><p>锁消除：Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁</p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">    * thread-local variable.  If the variable has no value for the</span><br><span class="line">    * current thread, it is first initialized to the value returned</span><br><span class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">    *</span><br><span class="line">    * @return the current thread&apos;s value of this thread-local</span><br><span class="line">    */</span><br><span class="line">   public T get() &#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       if (map != null) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">           if (e != null) &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">     * to the specified value.  Most subclasses will have no need to</span><br><span class="line">     * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">     * method to set the values of thread-locals.</span><br><span class="line">     *</span><br><span class="line">     * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">     *        this thread-local.</span><br><span class="line">     */</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Removes the current thread&apos;s value for this thread-local</span><br><span class="line">     * variable.  If this thread-local variable is subsequently</span><br><span class="line">     * &#123;@linkplain #get read&#125; by the current thread, its value will be</span><br><span class="line">     * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span><br><span class="line">     * unless its value is &#123;@linkplain #set set&#125; by the current thread</span><br><span class="line">     * in the interim.  This may result in multiple invocations of the</span><br><span class="line">     * &#123;@code initialValue&#125; method in the current thread.</span><br><span class="line">     *</span><br><span class="line">     * @since 1.5</span><br><span class="line">     */</span><br><span class="line">     public void remove() &#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         if (m != null)</span><br><span class="line">             m.remove(this);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h5 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h5><p>AQS（AbstractQueuedSynchronizer），抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><p><img src="201907160008.png" alt="312314"></p><p>AQS有以下几种方法：</p><ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li></ol><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>上面是AQS定义的资源独占方式，其实还有资源共享方式，采用以下两种方法：</p><ol><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ol><h5 id="CAS（Compare-and-swap）"><a href="#CAS（Compare-and-swap）" class="headerlink" title="CAS（Compare and swap）"></a>CAS（Compare and swap）</h5><p> CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p><p>现在CPU内部已经执行原子的CAS操作，Java5+中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性，这会使代码运行更快。</p><p>Java5以来，你可以使用java.util.concurrent.atomic包中的一些原子类来使用CPU中的这些功能</p><p><img src="201907160009.png" alt="31231"></p><p>上面是一个使用AtomicBoolean类实现lock()方法的例子。</p><p>locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，若两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。</p><p>即compareAndSet()返回true，如果值被替换了，返回false。</p><p>CAS用于同步（乐观锁的机制就是CAS）</p><ol><li>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值  B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</li><li>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算</li></ol><p>CAS存在的问题：有三个，ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。<br>ABA问题：</p><ol><li>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li><li>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li></ol><p>循环时间长开销大：</p><ol><li>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li><li>如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li></ol><p>只能保证一个共享变量的原子操作：</p><ol><li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</li><li>这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作</li></ol><h4 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h4><p>死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间相互等待对方释放资源，产生了无限制的等待现象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo extends Thread &#123;</span><br><span class="line">    protected Object tool;</span><br><span class="line">    static Object obj1 = new Object();</span><br><span class="line">    static Object obj2 = new Object();</span><br><span class="line"></span><br><span class="line">    public DeadLockDemo(Object obj)&#123;</span><br><span class="line">        this.tool=obj;</span><br><span class="line">        if(tool==obj1)&#123;</span><br><span class="line">            this.setName(&quot;哲学家A&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(tool==obj2)&#123;</span><br><span class="line">            this.setName(&quot;哲学家B&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        if(tool==obj1)&#123;</span><br><span class="line">            synchronized (obj1)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj2)&#123;</span><br><span class="line">                    System.out.println(&quot;A eat&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tool==obj2)&#123;</span><br><span class="line">            synchronized (obj2)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj1)&#123;</span><br><span class="line">                    System.out.println(&quot;B eat&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DeadLockDemo A = new DeadLockDemo(obj1);</span><br><span class="line">        DeadLockDemo B = new DeadLockDemo(obj2);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生死锁的四个必要条件： </p><ol><li><p>互斥条件：一个资源每次只能被一个进程使用。 </p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </p></li><li><p>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 </p></li><li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系</p></li></ol><p>如何避免死锁？ </p><ol><li><p>从死锁的四个必要条件来看，破坏其中的任意一个条件就可以避免死锁。但互斥条件是由资源本身决定的，不剥夺条件一般无法破坏，要实现的话得自己写更多的逻辑。 </p></li><li><p>避免无限期的等待：用Lock.tryLock(),wait/notify等方法写出请求一定时间后，放弃已经拥有的锁的程序。 </p></li><li><p>注意锁的顺序：以固定的顺序获取锁，可以避免死锁。 </p></li><li><p>开放调用：即只对有请求的进行封锁。你应当只想你要运行的资源获取封锁，比如在上述程序中我在封锁的完全的对象资源。但是如果我们只对它所属领域中的一个感兴趣，那我们应当封锁住那个特殊的领域而并非完全的对象。 </p></li><li><p>最后，如果能避免使用多个锁，甚至写出无锁的线程安全程序是再好不过了</p></li></ol><h5 id="BlockingQueue解决生产者消费者问题"><a href="#BlockingQueue解决生产者消费者问题" class="headerlink" title="BlockingQueue解决生产者消费者问题"></a>BlockingQueue解决生产者消费者问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class ProduceAndConsumerDemo &#123;</span><br><span class="line">    public static void main(String[] argd)&#123;</span><br><span class="line">        final BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(10);</span><br><span class="line">        Produce produce = new Produce(blockingQueue);</span><br><span class="line">        Consume consume = new Consume(blockingQueue);</span><br><span class="line">        produce.start();</span><br><span class="line">        consume.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Consume extends Thread&#123;</span><br><span class="line">        private final BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">        Consume(BlockingQueue&lt;Integer&gt; blockingQueue)&#123;</span><br><span class="line">            this.blockingQueue=blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Integer take = blockingQueue.take();</span><br><span class="line">                    System.out.println(&quot;consume:&quot; + take);</span><br><span class="line">                &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Produce extends Thread&#123;</span><br><span class="line">        private final BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">        Produce(BlockingQueue&lt;Integer&gt; blockingQueue)&#123;</span><br><span class="line">            this.blockingQueue=blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = new Random().nextInt(100);</span><br><span class="line">                    blockingQueue.add(i);</span><br><span class="line">                    System.out.println(&quot;produce:&quot;+ i);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用wait和notify实现生产者和消费者"><a href="#使用wait和notify实现生产者和消费者" class="headerlink" title="使用wait和notify实现生产者和消费者"></a>使用wait和notify实现生产者和消费者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class ProduceAndConsumerDemo2 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        int maxSize = 5;</span><br><span class="line">        Produce produce = new Produce(queue,maxSize);</span><br><span class="line">        Consume consume = new Consume(queue,maxSize);</span><br><span class="line">        produce.start();</span><br><span class="line">        consume.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Produce extends Thread&#123;</span><br><span class="line">        private Queue&lt;Integer&gt; queue;</span><br><span class="line">        private int maxSize;</span><br><span class="line"></span><br><span class="line">        Produce(Queue&lt;Integer&gt; queue , int maxSize)&#123;</span><br><span class="line">            this.queue = queue;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                synchronized (queue)&#123;</span><br><span class="line">                    while (queue.size()==maxSize)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;full&quot;);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int i = new Random().nextInt(100);</span><br><span class="line">                    System.out.println(&quot;produce:&quot;+ i);</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Consume extends Thread&#123;</span><br><span class="line">        private Queue&lt;Integer&gt; queue;</span><br><span class="line">        private int maxSize;</span><br><span class="line"></span><br><span class="line">        Consume(Queue&lt;Integer&gt; queue , int maxSize)&#123;</span><br><span class="line">            this.queue = queue;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                synchronized (queue)&#123;</span><br><span class="line">                    while (queue.isEmpty())&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;empty&quot;);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int i = queue.poll();</span><br><span class="line">                    System.out.println(&quot;consume:&quot;+ i);</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>《Java高并发编程详解》</p><p>《实战Java高并发程序设计》</p><p>《Java多线程编程核心技术》</p><p><a href="https://github.com/ZXZxin/ZXBlog/tree/master/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">https://github.com/ZXZxin/ZXBlog/tree/master/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B</a></p><p><a href="https://blog.csdn.net/ll666634/article/details/78615505" target="_blank" rel="noopener">https://blog.csdn.net/ll666634/article/details/78615505</a></p><p><a href="https://blog.csdn.net/cmyperson/article/details/79610870" target="_blank" rel="noopener">https://blog.csdn.net/cmyperson/article/details/79610870</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java多线程基础&quot;&gt;&lt;a href=&quot;#Java多线程基础&quot; class=&quot;headerlink&quot; title=&quot;Java多线程基础&quot;&gt;&lt;/a&gt;Java多线程基础&lt;/h2&gt;&lt;h3 id=&quot;并行基础概念&quot;&gt;&lt;a href=&quot;#并行基础概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记七</title>
    <link href="http://ylovex.cn/2019/07/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
    <id>http://ylovex.cn/2019/07/13/Redis设计与实现笔记七/</id>
    <published>2019-07-13T03:37:37.000Z</published>
    <updated>2019-07-14T03:45:31.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis构建了一个对象系统，包含字符串、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象</p><p>Redis可以在执行命令前，根据对象的类型判断一个对象是否可以执行给定的命令。可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>Redis对象系统实现基于引用计数技术的内存回收机制，还可以通过引用计数技术实现了对象共享机制，通过让多个数据库键共享同一个对象来节约内存</p><p>Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能情况下，空转时长较长的那些键可能会优先被服务器删除</p><h4 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，新创建一个键值对的时候，会创建两个对象，一个用于键一个用于值。</p><p>每个对象都由一个redisObject结构表示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* The actual Redis Object */</span><br><span class="line">/*</span><br><span class="line"> * Redis 对象</span><br><span class="line"> */</span><br><span class="line">#define REDIS_LRU_BITS 24</span><br><span class="line">#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;lru */</span><br><span class="line">#define REDIS_LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    // 对象最后一次被访问的时间</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line"></span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // 指向实际值的指针</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ol><li>type属性记录了对象的类型，键总是一个字符串对象；值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象，当对一个数据库键执行TYPE命令时候，返回的是值对象类型</li><li>对象的ptr指针指向对象的底层实现数据结构，而这个数据结构又对象的enconding属性决定</li></ol><p>enconding属性记录了对象所使用的编码：</p><p><img src="2019071208503.png" alt="32433211"></p><p>每种类型对象都至少使用了两种不同的编码：</p><p><img src="2019071208504.png" alt="213112241"></p><p>根据不同的使用场景为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象编码可以是int、raw、embstr</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保持在字符串对象结构的ptr属性里面（将void*转换为long），并将字符串对象编码设置为int</p><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw</p><p>如果保存的字符串长度小于等于32字节。用embstr编码保存，专门用于保存短字符串，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但是raw编码会调用两次内存分配函数分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数分配一块连续空间，空间中依次包含redisObject和sdshdr两个结构</p><p>可以用long double类型表示的浮点数在Redis中也是作为字符串值保存</p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>编码可以是ziplist或者linkedlist</p><p><img src="2019071208505.png" alt="32314141"></p><p><img src="2019071208506.png" alt="241414141"></p><p>编码转换：当列表对象同时满足以下两个条件，使用ziplist编码</p><ol><li>保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个</li></ol><p>可以在配置文件中list-max-ziplist-value和list-max-ziplist-entries配置</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>编码可以是ziplist或者hashtable</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时候，程序会将保存了键的压缩列表节点推入到压缩列表表尾，然后将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ol><li>保存了同一个键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，后来添加的放在表尾方向</li></ol><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对保存</p><p>编码转换，当哈希对象同时满足：</p><ol><li>保存的所以键值对的键和值的字符串长度都小于64字节</li><li>保存的键值对数量小于512个</li></ol><p>使用ziplist编码，否则编码转化为hashtable</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>编码可以是intset或者hashtable</p><p>hashtablw编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</p><p>编码转换，当满足：</p><ol><li>集合对象保存的所有元素都是整数值</li><li>保存元素数量不超过512</li></ol><p>使用intset编码，否则使用hashtable</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>编码可以是ziplist或者skiplist</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素保存元素的分值，压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾方法</p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表，zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，通过跳跃表可以进行范围型操作比如ZRANK、ZRANGE等，dict字典为有序集合创建了一个从成员到分值的映射，可以用O（1）查找给定成员的分值</p><h4 id="类型检查与命名多态"><a href="#类型检查与命名多态" class="headerlink" title="类型检查与命名多态"></a>类型检查与命名多态</h4><p>命令可以分为两种类型，一种命令可以对任何类型的键执行，比如DEL、EXPIRE、RENAME、TYPE、OBJECT等</p><p>另一种只能对特定类型的键执行，比如SET只能对字符串键执行，HSET只能对哈希键执行</p><h5 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h5><p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令</p><h5 id="多态命令实现"><a href="#多态命令实现" class="headerlink" title="多态命令实现"></a>多态命令实现</h5><p>根据值对象的编码方式，选择正确的命令实现代码执行命令</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p> Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所以整数值，当服务器需要用到值为0到999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象</p><p>Redis只对包含整数值的字符串对象进行共享</p><h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p>redisObject结构包含的lru属性，记录了对象最后一次被命令程序访问的时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h3&gt;&lt;p&gt;Redis构建了一个对象系统，包含字符串、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象&lt;/p&gt;
&lt;p&gt;Redis可以在执行命令
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记六</title>
    <link href="http://ylovex.cn/2019/07/10/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
    <id>http://ylovex.cn/2019/07/10/Redis设计与实现笔记六/</id>
    <published>2019-07-10T03:37:28.000Z</published>
    <updated>2019-07-14T03:43:38.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是列表键和哈希键的底层实现之一。</p><p>使用压缩列表作为列表键底层实现：列表键只包含少量列表项，并且每个列表项要么是小整数值要么是长度比较短的字符串</p><p>使用压缩列表作为哈希键底层实现：哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串</p><h4 id="压缩列表构成"><a href="#压缩列表构成" class="headerlink" title="压缩列表构成"></a>压缩列表构成</h4><p>ziplist是Redis为了节约内存而开发的，各部分如下</p><p><img src="2019071208502.png" alt="31284971924"></p><h4 id="节点构成"><a href="#节点构成" class="headerlink" title="节点构成"></a>节点构成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* 保存 ziplist 节点信息的结构</span><br><span class="line"> */</span><br><span class="line">typedef struct zlentry &#123;</span><br><span class="line"></span><br><span class="line">    // prevrawlen ：前置节点的长度</span><br><span class="line">    // prevrawlensize ：编码 prevrawlen 所需的字节大小</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line"></span><br><span class="line">    // len ：当前节点值的长度</span><br><span class="line">    // lensize ：编码 len 所需的字节大小</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line"></span><br><span class="line">    // 当前节点 header 的大小</span><br><span class="line">    // 等于 prevrawlensize + lensize</span><br><span class="line">    unsigned int headersize;</span><br><span class="line"></span><br><span class="line">    // 当前节点值所使用的编码类型</span><br><span class="line">    unsigned char encoding;</span><br><span class="line"></span><br><span class="line">    // 指向当前节点的指针</span><br><span class="line">    unsigned char *p;</span><br><span class="line"></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，</p><p>添加新节点或者删除节点，可能会引发连锁更新操作，导致需要对压缩列表执行N次空间重分配操作，最坏复杂度O（N^2）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;压缩列表&quot;&gt;&lt;a href=&quot;#压缩列表&quot; class=&quot;headerlink&quot; title=&quot;压缩列表&quot;&gt;&lt;/a&gt;压缩列表&lt;/h3&gt;&lt;p&gt;压缩列表是列表键和哈希键的底层实现之一。&lt;/p&gt;
&lt;p&gt;使用压缩列表作为列表键底层实现：列表键只包含少量列表项，并且每个列表
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>jvm虚拟机执行子系统</title>
    <link href="http://ylovex.cn/2019/07/09/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://ylovex.cn/2019/07/09/jvm虚拟机执行子系统/</id>
    <published>2019-07-09T12:26:37.000Z</published>
    <updated>2019-07-11T12:33:18.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h3><h4 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h4><p>任何一个Class文件都对应着唯一一个类或者接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或者接口也可以通过类加载器直接生成）。</p><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地 排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎 全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存 储数据，这种伪结构中只有两种数据类型：无符号数和表：</p><ol><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个 字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成字符串值。 </li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li></ol><p><img src="201907070950.png" alt="2070950"></p><h5 id="Class类文件结构详解："><a href="#Class类文件结构详解：" class="headerlink" title="Class类文件结构详解："></a>Class类文件结构详解：</h5><ol><li>魔数：每个Class文件的头4个字节称为魔数，唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。值为：0xCAFEBABE。</li><li>版本号：紧接着魔数的4个字节存储的是Class文件的版本号，第5和第6个字节是次版本号，第7和第8个字节是主版本号。java版本号从45开始。</li><li>常量池：紧接着版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，常量池入口需要放置一项u2类型的数据，代表常量池容量计数器，该容量计数从1开始而不是0；常量池主要存在两大类常量：字面量和符号引用，字面量比较接近于java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用则属于编译原理方面的概念，包含：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</li><li>访问标志：常量池结束后，紧接着的两个字符代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口、是否定义为public类型、是否定义为abstract类型、如果是类的话，是否被声明为final等</li><li>类索引、父类索引、接口索引：类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合</li><li>字符表集合：用于描述接口或者类中声明的变量，字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</li><li>方法表集合：结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项</li><li>属性表集合：常用属性如下<ol><li>Code属性；使用位置：方法表；含义：Java代码编译成的字节码指令</li><li>ConstantValue属性；字段表；final关键字定义的常量值</li><li>Deprecated属性；类、方法表、字段表；被声明为deprecated的方法和字段</li><li>Exceptions属性、方法表、方法抛出的异常</li><li>EnclosingMethod属性、方法表、仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</li></ol></li></ol><h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是JVM的类加载机制。</p><h5 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h5><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个 部分统称为连接（Linking）</p><p><img src="201907080950.png" alt="7080950"></p><p>其中，加载、验证、准备、初始化和卸载这5个阶段是确认的，</p><p>解析阶段不一定：在某些情况在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）</p><p>虚拟机严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 </li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化， 则需要先触发其初始化</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个 类），虚拟机会先初始化这个主类</li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后<br>的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。 </li></ol><p>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有 且只有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都 不会触发初始化，称为被动引用：</p><ol><li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li><li>通过数组定义来引用类，不会触发此类的初始化 </li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ol><p>接口也用初始化过程，当一个类在初始化时，要求其父类全部都已经初始 化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使 用到父接口的时候（如引用接口中定义的常量）才会初始化。 </p><h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。JVM把这个阶段的动作放在了虚拟机外部的“类加载器”中实现。未指明从哪里获取，因此有各种花样，比如从JAR包、WAR包，或者网络，或者运行时计算生成比如动态代理、由其他文件生成、从数据库读取等等。</li><li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。即对象类型数据（非对象实例数据）存在方法区。</li></ol><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>验证的目的是确保Class文件的字节流中包含的信号符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>分为四个阶段：</p><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</li><li>元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求</li><li>字节码验证：主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性校验。</li></ol><p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对 程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代 码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify：none参数来关 闭大部分的类验证措施，以缩短虚拟机类加载的时间。 </p><h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><p>这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。</p><p>比如public static int value=123：在准备阶段过后value=0，只有在初始化阶段后，value才等于123；</p><p>但是如何类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，比如 public static final int value=123，编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123.</p><h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p><p>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是 一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引 用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在</p><p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、 checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、 invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个用于 操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析</p><p>对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟 机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识 为已解析状态）从而避免解析动作重复进行。</p><p>对于invokedynamic指令，上面规则则不成立。当碰到某个前面已经由invokedynamic指令 触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生 效。因为invokedynamic指令的目的本来就是用于动态语言支持（目前仅使用Java语言不会生 成这条字节码指令），它所对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有 开始执行代码时就进行解析。</p><p>解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</p><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>是类加载过程的最后一步，类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化阶段，才开始真正执行类中定义的Java程序代码。</p><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通 过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始 化阶段是执行类构造器＜clinit＞（）方法的过程。</p><h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><p>虚拟机把类加载阶段中的通过一个类的全限定名来获取定义此类的二进制字节流这个动作放在了虚拟机外部的“类加载器”中实现。</p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</p><p>比较两个类是否“相等”，只有在这个两个类是由同一个类加载器加载的前提下才有意义。</p><h6 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h6><p>绝大部分Java程序都会使用到3种系统提供的类加载器：</p><ol><li>启动类加载器：这个类将器负责将存放在＜ JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机 识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载） 类库加载到虚拟机内存中</li><li>扩展类加载器：它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系 统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 </li><li>应用程序类加载器：它负责加载用户类路径（ClassPath）上所指定的类 库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一 般情况下这个就是程序中默认的类加载器。</li></ol><p><img src="201907080951.png" alt="7080951"></p><p>上图就是类加载器的双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当 有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系 来实现，而是都使用组合（Composition）关系来复用父加载器的代码</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class＜?＞loadClass（String name,boolean resolve）throws ClassNotFoundException &#123; //首先，检查请求的类是否已经被加载过了 Class c=findLoadedClass（name）； </span><br><span class="line">if（c==null）&#123; </span><br><span class="line">try&#123; </span><br><span class="line">if（parent！=null）&#123; </span><br><span class="line">c=parent.loadClass（name,false）；</span><br><span class="line">&#125;else&#123;</span><br><span class="line">c=findBootstrapClassOrNull（name）；</span><br><span class="line">&#125; </span><br><span class="line">&#125;catch（ClassNotFoundException e）&#123; </span><br><span class="line">//如果父类加载器抛出ClassNotFoundException </span><br><span class="line">//说明父类加载器无法完成加载请求</span><br><span class="line">&#125; </span><br><span class="line">if（c==null）&#123; </span><br><span class="line">//在父类加载器无法加载的时候 </span><br><span class="line">//再调用本身的findClass方法来进行类加载</span><br><span class="line">c=findClass（name）；</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">if（resolve）&#123; </span><br><span class="line">resolveClass（c）； </span><br><span class="line">&#125; return c；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>为什么需要双亲委派模型：</p><ol><li>例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。</li><li>如果不采用双亲委派模型，那么由各个类加载器自己去加载的话，那么系统中会存在多种不同的Object类。</li></ol><h4 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h4><p>执行引擎是Java虚拟机最核心的组成部分之一。</p><h5 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h5><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p><p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p> 每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受 到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p> 一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来 说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有 字节码指令都只针对当前栈帧进行操作。</p><p><img src="201907080953.png" alt="080953"></p><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><p>是一组变量值存储空间，用于存放方法参数和方法 内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数 据项中确定了该方法所需要分配的局部变量表的最大容量</p><p>以变量槽（Slot）为最小单位，到每个Slot都应该能存放一 个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。</p><h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><p>也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的 max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和 double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任 何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值</p><h6 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h6><p>每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为 了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符 号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接</p><h6 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h6><p>当一个方法开始执行后，只有两种方法可以退出：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令</li><li>遇到异常，并且该异常没有在方法体内得到处理</li></ol><h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h5><p>方法调用阶段唯一的任务就是确认被调用方法的版本（即调用哪一个方法），一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实践运行时内存布局中的入口地址。</p><h6 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h6><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段会将其中一部分符号引用转化为直接引用</p><p>这类解析成立前提：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可变。</p><p>符合“编译期可知，运行期不可变”：主要包括静态方法和私有方法。</p><p>Java虚拟机里面提供了5条方法调用字节指令：</p><ol><li>invokestatic：调用静态方法</li><li>invokespecial：调用实例构造器<init>方法，私有方法和父类方法</init></li><li>invokevirtual;调用所有的虚方法</li><li>invokeinterface:调用接口方法，会在运行时再确认一个实现此接口的对象</li><li>invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方 法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令 的分派逻辑是由用户所设定的引导方法决定</li></ol><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的 调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类 加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相 反，其他方法称为虚方法（除去final方法）</p><h6 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h6><p>静态分派：所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型应用是方法重载。</p><p>动态分派：在运行期根据实际类型确定方法执行的颁布的分派过程，重要体现是方法重写</p><h5 id="Java代码编译过程"><a href="#Java代码编译过程" class="headerlink" title="Java代码编译过程"></a>Java代码编译过程</h5><p><img src="201907080952.png" alt="7080952"></p><p>代码编译是由Javac编译器来完成，流程如上图所示。<br>Javac的任务就是将Java源代码编译成Java字节码，也就是JVM能够识别的二进制代码，从表面看是将.java文件转化为.class文件。而实际上是将Java源代码转化成一连串二进制数字，这些二进制数字是有格式的，只有JVM能够真确的识别他们到底代表什么意思。</p><p>具体流程：</p><ol><li>词法分析：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程</li><li>语法分析：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。</li><li>语义分析：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。比如将foreach转化为for循环。</li><li>字节码生成：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构，结果就是生成符合java虚拟机规范的字节码。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;虚拟机执行子系统&quot;&gt;&lt;a href=&quot;#虚拟机执行子系统&quot; class=&quot;headerlink&quot; title=&quot;虚拟机执行子系统&quot;&gt;&lt;/a&gt;虚拟机执行子系统&lt;/h3&gt;&lt;h4 id=&quot;类文件结构&quot;&gt;&lt;a href=&quot;#类文件结构&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="jvm" scheme="http://ylovex.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="http://ylovex.cn/tags/java/"/>
    
      <category term="jvm" scheme="http://ylovex.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记五</title>
    <link href="http://ylovex.cn/2019/07/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <id>http://ylovex.cn/2019/07/08/Redis设计与实现笔记五/</id>
    <published>2019-07-08T03:37:21.000Z</published>
    <updated>2019-07-14T03:41:48.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</p><h4 id="整数集合实现"><a href="#整数集合实现" class="headerlink" title="整数集合实现"></a>整数集合实现</h4><p>用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证不会出现重复元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    </span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line"></span><br><span class="line">    // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line"></span><br><span class="line">    // 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大有序排列，并且数组不包含任何重复项</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当新元素类型比整数集合现有所有元素的类型都要长时候，整数集合需要先升级再把新元素添加</p><p>分为三步：</p><ol><li>根据新元素，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放在正确位上，维持有序性质不变</li><li>将新元素添加到底层数组里面</li></ol><h5 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h5><ol><li>提升灵活性</li><li>节约内存</li></ol><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态</p><h4 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h4><p><img src="2019071208501.png" alt="6876868"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;整数集合&quot;&gt;&lt;a href=&quot;#整数集合&quot; class=&quot;headerlink&quot; title=&quot;整数集合&quot;&gt;&lt;/a&gt;整数集合&lt;/h3&gt;&lt;p&gt;整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-病毒传播</title>
    <link href="http://ylovex.cn/2019/07/07/nowcoder-%E7%97%85%E6%AF%92%E4%BC%A0%E6%92%AD/"/>
    <id>http://ylovex.cn/2019/07/07/nowcoder-病毒传播/</id>
    <published>2019-07-06T23:37:20.000Z</published>
    <updated>2019-07-10T23:57:56.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/3b6060942397444cb0fe5846e230f6d9?tpId=90&amp;tqId=30850&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/3b6060942397444cb0fe5846e230f6d9?tpId=90&amp;tqId=30850&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出一个图G(V,E)，图上有n个点，m条边，所有的边都是无向边。</p><p>最开始，也就是第0天的时候，这n个点中有一个点v感染了病毒，之后的每一天，凡是感染病毒的点都会向它的邻居点传播病毒。经过了t天之后，得到了感染病毒的点集S。要求找出第0天感染病毒的点v。如果v有很多不同的答案，把它们都找出来。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>bfs算法，显然感染源一定是感染的点，先用ArrayLIst生成图，以每个感染的点为起点在t时间内进行广度遍历，将结果与给定的感染集合进行比较，如果一样则该点可以是感染源。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Now_74</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] infected;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt;[] graph;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, k, t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        infected = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        graph = <span class="keyword">new</span> ArrayList[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> v = sc.nextInt();</span><br><span class="line">            graph[u].add(v);</span><br><span class="line">            graph[v].add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        k = sc.nextInt();</span><br><span class="line">        t = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            infected[sc.nextInt()]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(infected[i] &amp;&amp; bfs(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==res.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(res.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(res.get(i)+<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以x为起点传播t天的结果和实际结果比较是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个点被传染需要的时间, 为0表明没有被传染</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp[x]=<span class="number">1</span>;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (! queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp[cur]&gt;t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(Integer e : graph[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[e]==<span class="number">0</span>)&#123;</span><br><span class="line">                   temp[e]=temp[cur]+<span class="number">1</span>;</span><br><span class="line">                   queue.offer(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!infected[i] &amp;&amp; temp[i]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(infected[i] &amp;&amp; temp[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/3b6060942397444
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="bfs" scheme="http://ylovex.cn/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记四</title>
    <link href="http://ylovex.cn/2019/07/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>http://ylovex.cn/2019/07/06/Redis设计与实现笔记四/</id>
    <published>2019-07-06T03:37:07.000Z</published>
    <updated>2019-07-14T03:39:43.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O（logN），最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，或者有序集合中的元素的成员是比较长的字符串时候，Redis就会使用跳跃表来作为有序集合键的底层实现</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p><h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等。 </p><p><img src="201907120850.png" alt="21971250"></p><ol><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点层数（表头节点除外）</li><li>length：记录跳跃表长度（表头节点不计算在内）</li></ol><h5 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">* 跳跃表节点</span><br><span class="line"> */</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line"></span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ol><li>层：level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，一般层数越多访问其他节点的速度就越快。每次创建一个新跳跃表节点的时候，程序都根据幂次定律（越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小。</li><li>前进指针：每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点</li><li>跨度：用于记录两个节点之间的距离</li><li>后退指针：用于从表尾向表头方向访问节点，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</li><li>分值和成员：分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序；成员对象是一个指针，它指向一个字符串对象，而字符串对象保存一个SDS值</li></ol><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象的字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的反向）</p><h5 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h5><p>通过使用zskiplist结构来持有多个跳跃表节点，程序可以更方便地对整个跳跃表进行处理，如何快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 跳跃表</span><br><span class="line"> */</span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line"></span><br><span class="line">    // 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">    // 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line"></span><br><span class="line">    // 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;跳跃表&quot;&gt;&lt;a href=&quot;#跳跃表&quot; class=&quot;headerlink&quot; title=&quot;跳跃表&quot;&gt;&lt;/a&gt;跳跃表&lt;/h3&gt;&lt;p&gt;跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;跳跃表支持平均O
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记三</title>
    <link href="http://ylovex.cn/2019/07/05/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://ylovex.cn/2019/07/05/Redis设计与实现笔记三/</id>
    <published>2019-07-04T22:55:12.000Z</published>
    <updated>2019-07-11T00:22:48.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h3><p>又称符号表、关联数组、映射，是一种保存键值对的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a>哈希表：</h4><p>由dict.h/dictht结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">    //哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    //哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line">    //哈希表大小掩码，用于计算索引值</span><br><span class="line">    //总是等于size-1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    //该哈希表已有节点数量</span><br><span class="line">    unsigned long user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点的数量，sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放在table数组的哪个索引上面。</p><h4 id="哈希表节点："><a href="#哈希表节点：" class="headerlink" title="哈希表节点："></a>哈希表节点：</h4><p>使用dictEntry结构，每个dictEntry结构都保存一个键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    //键</span><br><span class="line">    void *key;</span><br><span class="line">    //值</span><br><span class="line">    union&#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        unt64_t s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    //指向下个哈希表节点，形成链表</span><br><span class="line">    strcut dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><p>key属性保存键，v属性保存值，可以是指针、uint64_t、uint64_t。</p><p>next属性指向另一个哈希表节点指针，解决哈希冲突。</p><p><img src="201907050731.png" alt="207050731"></p><h4 id="字典：-1"><a href="#字典：-1" class="headerlink" title="字典："></a>字典：</h4><p>由dict.h/dict结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    //类型特定函数</span><br><span class="line">    sictType *type;</span><br><span class="line">    //私有数据</span><br><span class="line">    void *privtata;</span><br><span class="line">    //哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    //rehash索引</span><br><span class="line">    //当rehash不在进行时，值为-1</span><br><span class="line">    int trehashidx;/*rehashing not in progress if rehashidx==-1 */</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同的类型的键值对，为创建多态字典而设置的：</p><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p><p>privdata属性则保存了需要传给那些类型特定函数的可选参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType&#123;</span><br><span class="line">    //计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    //复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata,const void *key);</span><br><span class="line">    //复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata,const void *obj);</span><br><span class="line">    //对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata,const void *key1.const void *key2);</span><br><span class="line">    //销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *prevdata,void *key);</span><br><span class="line">    //销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *prevdata,void *obj);</span><br><span class="line">&#125;dictType；</span><br></pre></td></tr></table></figure><p>ht属性是一个包含两项的数组，数组的每一项都是一个dictht哈希表，一般，字典只使用ht[0]，ht[1]用于对ht[0]rehash。</p><p><img src="201907050732.png" alt="2050732"></p><h3 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h3><p>Redis计算哈希值和索引值方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">//使用哈希值的sizemask属性和哈希值，计算索引</span><br><span class="line">//根据情况不同，ht[x]可以是hx[0]或者ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><h3 id="解决键冲突："><a href="#解决键冲突：" class="headerlink" title="解决键冲突："></a>解决键冲突：</h3><p>当有两个或者以上数量的键被分配到哈希表数组的同一个索引上面的时候，产生了冲突。</p><p>使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，从而解决键冲突。</p><p>新节点总是添加到链表的表头位置（复杂度为O(1)）</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash:"></a>rehash:</h3><p>扩展和收缩哈希表通过rehash（重新散列）完成</p><ol><li><p>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性值）</p><p>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n值</p><p>如果执行的收缩，那么ht[1]的大小是第一个大于等于ht[0].used的2^n值</p></li><li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放在ht[1]哈希表指定位置</p></li><li><p>当ht[0]包含所有键值对都迁移到ht[1]后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空白哈希表，为下一次rehash做准备。</p></li></ol><h3 id="哈希表的扩展与收缩："><a href="#哈希表的扩展与收缩：" class="headerlink" title="哈希表的扩展与收缩："></a>哈希表的扩展与收缩：</h3><p>哈希表的负载因子=哈希表已保存节点数量/哈希表大小</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1],二十分多次、渐进式地将ht[0]里面的键值对慢慢rehash。</p><p>在渐进式rehash进行期间，字典的删除、查找、更新等操作会在两个哈希表进行</p><p>渐进式rehash期间，新添加到字典的键值对一律会保存到ht[1]中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字典：&quot;&gt;&lt;a href=&quot;#字典：&quot; class=&quot;headerlink&quot; title=&quot;字典：&quot;&gt;&lt;/a&gt;字典：&lt;/h3&gt;&lt;p&gt;又称符号表、关联数组、映射，是一种保存键值对的抽象数据结构。&lt;/p&gt;
&lt;p&gt;Redis的字典使用哈希表作为底层实现，一个哈希表里面可
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记二</title>
    <link href="http://ylovex.cn/2019/07/03/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://ylovex.cn/2019/07/03/Redis设计与实现笔记二/</id>
    <published>2019-07-03T04:52:07.000Z</published>
    <updated>2019-07-11T00:22:29.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h3><h4 id="链表和链表节点的实现："><a href="#链表和链表节点的实现：" class="headerlink" title="链表和链表节点的实现："></a>链表和链表节点的实现：</h4><p>链表节点使用一个adlist.h/listNode结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">    //前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    //后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    //节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表。</p><p><img src="201907020905.png" alt="27020905"></p><p>使用adlist.h/list来持有链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    //表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    //表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    //链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">    //节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    //节点值释放函数</span><br><span class="line">    void *(*free)(void *ptr);</span><br><span class="line">    //节点值对比函数</span><br><span class="line">    int (*match)(void *pre , void *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure><p><img src="201907020916.png" alt="2020916"></p><p>上图是一个由list结构和三个listNode结构组成的链表。</p><h4 id="Redis链表实现特性"><a href="#Redis链表实现特性" class="headerlink" title="Redis链表实现特性:"></a>Redis链表实现特性:</h4><ol><li>双端：链表节点带有prev和next指针，获取某个节点的前置和后置复杂度都是O(1)</li><li>无环：表头节点的prev和表尾的next都指向NULL，对链表访问都以NULL为终点</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点都是O(1)</li><li>带链表长度计数器：获取链表中节点数量的复杂度为O(1)</li><li>多态：链表节点使用void* 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表：&quot;&gt;&lt;a href=&quot;#链表：&quot; class=&quot;headerlink&quot; title=&quot;链表：&quot;&gt;&lt;/a&gt;链表：&lt;/h3&gt;&lt;h4 id=&quot;链表和链表节点的实现：&quot;&gt;&lt;a href=&quot;#链表和链表节点的实现：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-骰子游戏</title>
    <link href="http://ylovex.cn/2019/07/02/nowcoder-%E9%AA%B0%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://ylovex.cn/2019/07/02/nowcoder-骰子游戏/</id>
    <published>2019-07-01T23:37:01.000Z</published>
    <updated>2019-07-10T23:57:09.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/0e83797c34e54cca91179fe9ad681bc4?tpId=90&amp;tqId=30849&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/0e83797c34e54cca91179fe9ad681bc4?tpId=90&amp;tqId=30849&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>小易参加了一个骰子游戏,这个游戏需要同时投掷n个骰子,每个骰子都是一个印有数字1~6的均匀正方体。<br>小易同时投掷出这n个骰子,如果这n个骰子向上面的数字之和大于等于x,小易就会获得游戏奖励。<br>小易想让你帮他算算他获得奖励的概率有多大。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态规划，用dp[i][j]表示i个骰子产生数字和j的结果数，</span><br><span class="line">初始值dp[1][j]=1(j=1~6),dp[i] [i]=1,dp[i][6*i]=1,</span><br><span class="line">由于第i个骰子的点数可以为1~6，要使i个骰子的数字和为j的话，</span><br><span class="line">则前i-1个骰子的数字和可以为j-1~j-6，</span><br><span class="line">所以得到公式dp[i][j] +=dp[i-1][j-k] (k=1~6)。</span><br></pre></td></tr></table></figure><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Now_73</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> x=sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=x) System.out.print(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">6</span>*n&lt;x) System.out.print(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span>[][] dp=<span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>][<span class="number">6</span>*n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++) dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="number">6</span>*n;j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;j&amp;&amp;k&lt;=<span class="number">6</span>;k++) &#123;</span><br><span class="line">                        dp[i][j]+=dp[i-<span class="number">1</span>][j-k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> total=(<span class="keyword">long</span>)Math.pow(<span class="number">6</span>,n);</span><br><span class="line">            <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;i++) sum+=dp[n][i];</span><br><span class="line">            <span class="keyword">long</span> num=gcd(total-sum,total);</span><br><span class="line">            System.out.print((total-sum)/num+<span class="string">"/"</span>+total/num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a%b==<span class="number">0</span>)?b:gcd(b,a%b);<span class="comment">//求最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/0e83797c34e54cc
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="dp" scheme="http://ylovex.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记一</title>
    <link href="http://ylovex.cn/2019/07/01/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://ylovex.cn/2019/07/01/Redis设计与实现笔记一/</id>
    <published>2019-07-01T13:33:42.000Z</published>
    <updated>2019-07-11T00:23:04.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串："><a href="#简单动态字符串：" class="headerlink" title="简单动态字符串："></a>简单动态字符串：</h3><p>Redis并没有直接使用C语音传统的字符串（以空字符串结尾的字符数组），而是构建了一种名为简单动态字符串（simple dynamic string ， SDS）的抽象类型。</p><p>每个sds.h/sdshdr结构表示一个SDS值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    //记录buf数组中已使用字节的数量</span><br><span class="line">    //等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    </span><br><span class="line">    //记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    </span><br><span class="line">    //字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图展示了一个SDS示例：</p><p><img src="1561985098307.png" alt="1565098307"></p><p>其中：</p><ol><li>free属性的值为0，表示这个SDS没有分配任何未使用的空间</li><li>len属性的值为5，表示这个SDS保存一个5字节长的字符串</li><li>buf属性是一个char类型的数组，最后以空字符‘\0’。</li></ol><p>SDS遵循C字符串以空字符结尾的惯例，保存的空字符的1字节不计算在SDS的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符末尾等操作都是SDS自动完成，对使用者完成透明，遵循空字符结尾可以重用一部分C字符串函数库里面的函数。</p><h4 id="SDS优点："><a href="#SDS优点：" class="headerlink" title="SDS优点："></a>SDS优点：</h4><h5 id="常数复杂度获取字符串的长度："><a href="#常数复杂度获取字符串的长度：" class="headerlink" title="常数复杂度获取字符串的长度："></a>常数复杂度获取字符串的长度：</h5><p>通过使用SDS而不是C字符串，Redis将获取字符串长度所需要的复杂度从O(n)降低到了O(1)。</p><h5 id="杜绝缓冲区溢出："><a href="#杜绝缓冲区溢出：" class="headerlink" title="杜绝缓冲区溢出："></a>杜绝缓冲区溢出：</h5><p>当SDS API需要对SDS进行修改时候，API会先检查SDS空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</p><h5 id="减少修改字符串时候带来的内存重分配次数："><a href="#减少修改字符串时候带来的内存重分配次数：" class="headerlink" title="减少修改字符串时候带来的内存重分配次数："></a>减少修改字符串时候带来的内存重分配次数：</h5><p>对于一个包含N个字符的C字符串，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符），因为C字符串的长度和底层数组的长度之间存在这种关联，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一个内存重分配操作：</p><ol><li>如果程序执行的是增长字符串操作，比如拼接（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小—如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的就是缩短字符串操作，比如截断（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间—如果忘了这步就会产生内存泄漏。</li></ol><p>为了避免C字符串这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度的关联，在SDS中，buf数组的长度不一定是字符数量加一，数组里面可以包含未使用的字节，而这个未使用的字节由SDS的free属性记录。</p><p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h6 id="空间预分配："><a href="#空间预分配：" class="headerlink" title="空间预分配："></a>空间预分配：</h6><p>空间预分配用于优化SDS字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间的时候，还会为SDS分配额外的未使用空间。</p><p>其中，额外分配的未使用空间数量由以下公式决定：</p><ol><li>如果对SDS进行修改之后，SDS的的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间。</li><li>如何对SDS进行修改后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。</li></ol><p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需要的内存重分配次数。</p><h6 id="惰性空间释放："><a href="#惰性空间释放：" class="headerlink" title="惰性空间释放："></a>惰性空间释放：</h6><p>惰性空间释放用于优化SDS字符串缩短操作：当SDS的API需要缩短的SDS保存的字符串时候，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等到将来使用。</p><h5 id="二进制安全："><a href="#二进制安全：" class="headerlink" title="二进制安全："></a>二进制安全：</h5><p>C字符中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使C字符只能保存文本数据，不能保存像图像、音频、视频、压缩文件这样的二进制数据。</p><p>SDS的API都是二进制安全的，所有SDS API都会处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入是什么样，被读取就是什么样。</p><h5 id="兼容部分C字符串函数："><a href="#兼容部分C字符串函数：" class="headerlink" title="兼容部分C字符串函数："></a>兼容部分C字符串函数：</h5><p>通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用&lt;string.h&gt;函数库，从而避免了不必要的代码重复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串：&quot;&gt;&lt;a href=&quot;#简单动态字符串：&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串：&quot;&gt;&lt;/a&gt;简单动态字符串：&lt;/h3&gt;&lt;p&gt;Redis并没有直接使用C语音传统的字符串（以空字符串结尾的字符数组），而是构建了一种名为简
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>jvm自动内存管理机制</title>
    <link href="http://ylovex.cn/2019/06/28/jvm%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://ylovex.cn/2019/06/28/jvm自动内存管理机制/</id>
    <published>2019-06-28T00:11:47.000Z</published>
    <updated>2019-07-11T00:24:12.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM组成："><a href="#JVM组成：" class="headerlink" title="JVM组成："></a>JVM组成：</h3><p>JVM 由类加载器子系统、运行时数据区、执行引擎以及本地方法接口组成。</p><p><img src="201907030747.png" alt="27030747"></p><h3 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p>是当前线程所执行的字节码的行号指示器。字节码解释器工作时候通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都依赖该计数器。</p><p>线程私有，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域。</p><h5 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h5><p>存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>线程私有。</p><p>局部变量表存放编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令地址）。</p><p>其中64位长度的long和double类型数据占用2个局部变量空间（slot），其余数据类型只占1个字节。</p><h5 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h5><p>虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈为虚拟机使用Native方法服务。</p><h5 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h5><p>存放对象实例，是垃圾收集器管理的主要区域。</p><p>线程共享。</p><h5 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h5><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>线程共享。</p><h5 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h5><p>是方法区的一部分。具有动态性，不仅预置入Class文件中常量池的内容可以进入方法区运行时常量池，运行期间也可以将新的常量放入池中。</p><h3 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h3><ol><li>虚拟机遇到一条new指令时，会先去常量池检测能否找到new对应的类的符号引用，并检测这个类是否加载、初始化。</li><li>如果加载检查通过，则分配内存。分配内存有两种方式：⑴指针碰撞，针对连续内存区域；⑵空闲列表，针对不连续内存区域</li><li>内存分配完之后，会对内存初始化零值，保证实例字段能在java代码不赋初值也能使用。</li><li>接下来对对象信息进行设置，把类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息存放在对象头之中</li><li>最后执行用户的Init方法</li></ol><h3 id="对象的内存布局："><a href="#对象的内存布局：" class="headerlink" title="对象的内存布局："></a>对象的内存布局：</h3><ol><li>分为三部分，对象头、实例数据、对齐填充</li><li>对象头：⑴对象自身运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁等。⑵类型指针，虚拟机通过这个来确定这个对象是哪个类的实例。⑶如果对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据。</li><li>实例数据：对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。</li><li>对齐填充：JVM要求对象的起始地址必须是8字节的整数倍，因此当对象实例数据没有对齐时，这部分来补全。</li></ol><h3 id="对象的访问定位："><a href="#对象的访问定位：" class="headerlink" title="对象的访问定位："></a>对象的访问定位：</h3><h5 id="使用句柄访问："><a href="#使用句柄访问：" class="headerlink" title="使用句柄访问："></a>使用句柄访问：</h5><p>Java堆中会划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p><img src="201907030826.png" alt="2010826"></p><h5 id="直接指针访问："><a href="#直接指针访问：" class="headerlink" title="直接指针访问："></a>直接指针访问：</h5><p>那么Java堆对象的布局中就必须考虑如何放置访问类型数据的 相关信息，而reference中存储的直接就是对象地址</p><p><img src="201907030827.png" alt="207030827"></p><h3 id="Java垃圾回收区域："><a href="#Java垃圾回收区域：" class="headerlink" title="Java垃圾回收区域："></a>Java垃圾回收区域：</h3><ol><li>Java垃圾回收只针对堆和方法区的内存。</li><li>程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭，因此不用管。</li></ol><p><img src="201907030830.png" alt="20030830"></p><h3 id="如何确认垃圾："><a href="#如何确认垃圾：" class="headerlink" title="如何确认垃圾："></a>如何确认垃圾：</h3><h5 id="引用计数算法："><a href="#引用计数算法：" class="headerlink" title="引用计数算法："></a>引用计数算法：</h5><p>给对象中添加一个引用计数器，每当有 一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0 的对象就是不可能再被使用的。</p><h5 id="可达性分析算法："><a href="#可达性分析算法：" class="headerlink" title="可达性分析算法："></a>可达性分析算法：</h5><p>这个算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连 （用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达 的，所以它们将会被判定为是可回收的对象。</p><p><img src="201907030836.png" alt="20130836"></p><p>可作为GC Roots对象有：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。 </li><li>方法区中类静态属性引用的对象。 </li><li>方法区中常量引用的对象。 </li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ol><h3 id="垃圾回收算法："><a href="#垃圾回收算法：" class="headerlink" title="垃圾回收算法："></a>垃圾回收算法：</h3><h5 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h5><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有 被标记的对象。</p><p>不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h5 id="复制算法："><a href="#复制算法：" class="headerlink" title="复制算法："></a>复制算法：</h5><p>它将可用内存按容 量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是 对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指 针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p><h5 id="标记-整理算法："><a href="#标记-整理算法：" class="headerlink" title="标记-整理算法："></a>标记-整理算法：</h5><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存 活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h5 id="分代收集："><a href="#分代收集：" class="headerlink" title="分代收集："></a>分代收集：</h5><p>一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付 出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间 对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h3 id="JVM-GC："><a href="#JVM-GC：" class="headerlink" title="JVM GC："></a>JVM GC：</h3><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>要GC就得枚举根节点，如果逐一去检查引用，效率很低。因此JVM使用一组称为OopMap的数据结构，直接知道哪些地方存放着对象引用。</p><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>可能导致引用关系、或者说OopMap内容变化的指令非常多，不可能为每一条指令都生成对应的OopMap，因此有了安全点，在安全点才记录OopMap，在安全点才能进行GC，例如方法调用、循环跳转、异常跳转等，具有这些功能的指令才会产生安全点</p><h5 id="如何让GC发生时线程都跑到安全点"><a href="#如何让GC发生时线程都跑到安全点" class="headerlink" title="如何让GC发生时线程都跑到安全点"></a>如何让GC发生时线程都跑到安全点</h5><p>采用主动式中断思想，GC时，不直接对线程操作，而是设置一个中断标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的</p><h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>如果程序不执行时，比如sleep了，岂不是就进不了安全点？因此有了安全区域，安全区域指在一段代码中，引用关系不会发生变化，在这个区域内GC都是安全的。线程进入安全区域后，会标志自己进入了。JVM要GC时就不会管这些线程。线程要离开安全区域时，必须检查GC是否完成，如果GC完成了线程就继续执行，否则一直等待直到GC完成。</p><h3 id="垃圾收集器："><a href="#垃圾收集器：" class="headerlink" title="垃圾收集器："></a>垃圾收集器：</h3><p><img src="201907030914.png" alt="20130914"></p><h5 id="Serial收集器："><a href="#Serial收集器：" class="headerlink" title="Serial收集器："></a>Serial收集器：</h5><p>单线程，GC时候需要暂停其他所有的工作线程，直到它收集结束。</p><p>JVM运行在Client模式下的默认新生代收集器：简单而高效。</p><p><img src="20190704649.png" alt="2014649"></p><h5 id="ParNew收集器："><a href="#ParNew收集器：" class="headerlink" title="ParNew收集器："></a>ParNew收集器：</h5><p>Serial收集器的多线程版本。</p><p>许多运行在Server模式下虚拟机的首选新生代收集器。</p><p>在单CPU环境次啊ParNew不会有比Serial收集器效果更好，Serial和ParNew都是与CMS配合工作。</p><p><img src="20190704650.png" alt="20704650"></p><h5 id="Parallel-Scavenge收集器："><a href="#Parallel-Scavenge收集器：" class="headerlink" title="Parallel Scavenge收集器："></a>Parallel Scavenge收集器：</h5><p>新生代收集器，使用复制算法。</p><p>关注吞吐量，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p><p><img src="20190704652.png" alt="2004652"></p><h5 id="Serial-Old收集器："><a href="#Serial-Old收集器：" class="headerlink" title="Serial Old收集器："></a>Serial Old收集器：</h5><p>是Seraial收集器的老年代版本，单线程，采用“标记-整理”算法。</p><h5 id="Parallel-Old收集器："><a href="#Parallel-Old收集器：" class="headerlink" title="Parallel Old收集器："></a>Parallel Old收集器：</h5><p>是Parallel Scavenge收集器的老年代版本，“标记-整理”。</p><h5 id="CMS收集器："><a href="#CMS收集器：" class="headerlink" title="CMS收集器："></a>CMS收集器：</h5><p>是一种以获取最短回收停顿时间为目标的收集器。</p><p>基于“标记-清除”。</p><p>初始标记，并发标记，重新标记，并发清除。其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是 标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远 比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起 工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><img src="20190704653.png" alt="204653"></p><p>缺点：对CPU资源非常敏感、无法处理浮动垃圾、基于“标记-清除”，产生大量空间碎片。</p><h5 id="G1收集器："><a href="#G1收集器：" class="headerlink" title="G1收集器："></a>G1收集器：</h5><p>是一款面向服务端应用的垃圾收集器，、并行与并发、分代收集、空间整合、可预测停顿</p><p>将整个Java堆划分多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的。</p><p><img src="20190704654.png" alt="204654"></p><h3 id="内存分配与回收策略："><a href="#内存分配与回收策略：" class="headerlink" title="内存分配与回收策略："></a>内存分配与回收策略：</h3><ol><li>对象优先在Eden分配。</li><li>老年代GC（Full GC/Major GC）一般比新生代GC（Minor GC）慢10倍以上。</li><li>大对象直接进入老年代，大对象指需要大量连续内存空间的Java对象，比如很长的字符串和数组。可通过参数设置。</li><li>长期存活的对象将进入老年代。默认15岁。</li><li>动态对象年龄判定。如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</li><li>空间分配担保。当出现大量对象Minor GC后仍然存活的情况，需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM组成：&quot;&gt;&lt;a href=&quot;#JVM组成：&quot; class=&quot;headerlink&quot; title=&quot;JVM组成：&quot;&gt;&lt;/a&gt;JVM组成：&lt;/h3&gt;&lt;p&gt;JVM 由类加载器子系统、运行时数据区、执行引擎以及本地方法接口组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2
      
    
    </summary>
    
      <category term="jvm" scheme="http://ylovex.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="http://ylovex.cn/tags/java/"/>
    
      <category term="jvm" scheme="http://ylovex.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-数位重排</title>
    <link href="http://ylovex.cn/2019/06/18/nowcoder-%E6%95%B0%E4%BD%8D%E9%87%8D%E6%8E%92/"/>
    <id>http://ylovex.cn/2019/06/18/nowcoder-数位重排/</id>
    <published>2019-06-18T12:32:06.000Z</published>
    <updated>2019-07-10T23:49:12.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/f970201e9f7e4040ab25a40918e27d15?tpId=90&amp;tqId=30847&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f970201e9f7e4040ab25a40918e27d15?tpId=90&amp;tqId=30847&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>牛牛有一个正整数x,牛牛需要把数字x中的数位进行重排得到一个新数(不同于x的数),牛牛想知道这个新数是否可能是原x的倍数。请你来帮他解决这个问题。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>题目要求将x中的数位重排得到的新数是否可能是原x的倍数；只需判断x的2到9的倍数中是否存在由x重排后得到的数。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Now_71&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        boolean[] booleans = new boolean[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            booleans[i] = isCheck(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(booleans[i])&#123;</span><br><span class="line">                System.out.println(&quot;Possible&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(&quot;Impossible&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isCheck(int num) &#123;</span><br><span class="line">        for(int i=2;i&lt;=9;i++)&#123;</span><br><span class="line">            String s1 = String.valueOf(num*i);</span><br><span class="line">            String s2 = String.valueOf(num);</span><br><span class="line">            char[] c1 = s1.toCharArray();</span><br><span class="line">            char[] c2 = s2.toCharArray();</span><br><span class="line">            if(c1.length != c2.length) continue;</span><br><span class="line">            Arrays.sort(c1);</span><br><span class="line">            Arrays.sort(c2);</span><br><span class="line">            String s3 = String.valueOf(c1);</span><br><span class="line">            String s4 = String.valueOf(c2);</span><br><span class="line">            if(s3.equals(s4))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/f970201e9f7e404
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础</title>
    <link href="http://ylovex.cn/2019/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>http://ylovex.cn/2019/06/15/数据库基础/</id>
    <published>2019-06-15T01:30:43.000Z</published>
    <updated>2019-07-11T00:26:37.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据库类别"><a href="#数据库类别" class="headerlink" title="数据库类别"></a>数据库类别</h4><h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。<br>包括：Mysql、Oracle、DB2、Sqlserver</p><h5 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h5><p>NoSQL是非关系型数据库的广义定义，如下小结：<br>NOSQL不是否定关系数据库，而是作为关系数据库的一个重要补充。<br>NOSQL为了高性能、高并发而生，忽略影响高性能、高并发的功能。<br>NOSQL典型产品memcached（纯内存），redis（持久化缓存），mongodb（面向文档）</p><h6 id="键值存储数据库（key-value）"><a href="#键值存储数据库（key-value）" class="headerlink" title="键值存储数据库（key-value）"></a>键值存储数据库（key-value）</h6><p> 键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据库，因为使用key主键访问，所以会获得很高的性能及扩展性。<br>键值数据库主要使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。<br>典型产品：Memcached、Redis、MemcacheDB:</p><h6 id="列存储（Column-oriented）数据库"><a href="#列存储（Column-oriented）数据库" class="headerlink" title="列存储（Column-oriented）数据库:"></a>列存储（Column-oriented）数据库:</h6><p>列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据，比如人类，我们经常会查询某个人的姓名和年龄，而不是薪资。这种情况下姓名和年龄会被放到一个列族中，薪资会被放到另一个列族中。<br>这种数据库通常用来应对分布式存储海量数据。<br>典型产品：Cassandra、HBase</p><h6 id="面向文档（Document-Oriented）数据库"><a href="#面向文档（Document-Oriented）数据库" class="headerlink" title="面向文档（Document-Oriented）数据库:"></a>面向文档（Document-Oriented）数据库:</h6><p>文档型数据库的灵感是来自于Lotus Notes办公软件，而且它同第一种键值数据库类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以 看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。<br>面向文档数据库会将数据以文档形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名词与对应值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或JSONB等多种形式存储。<br>典型产品：MongoDB、CouchDB</p><h6 id="图形数据库"><a href="#图形数据库" class="headerlink" title="图形数据库"></a>图形数据库</h6><p>图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。<br>典型产品：Neo4J、InforGrid</p><h4 id="关系型和非关系型数据库区别"><a href="#关系型和非关系型数据库区别" class="headerlink" title="关系型和非关系型数据库区别"></a>关系型和非关系型数据库区别</h4><p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。<br>优点：</p><ol><li>易于维护：都是使用表结构，格式一致；</li><li>使用方便：SQL语言通用，可用于复杂查询；</li><li>复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</li></ol><p>缺点：</p><ol><li>读写性能比较差，尤其是海量数据的高效率读写；</li><li>固定的表结构，灵活度稍欠；</li><li>不能满足高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</li></ol><p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方式的集合，可以是文档或者键值对等。</p><p>优点：</p><ol><li>格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li><li>速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；</li><li>高扩展性；</li><li>成本低：nosql数据库部署简单，基本都是开源软件。</li></ol><p>缺点：</p><ol><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理； </li><li>数据结构相对复杂，复杂查询方面稍欠。</li></ol><h4 id="Innodb和MyIASM："><a href="#Innodb和MyIASM：" class="headerlink" title="Innodb和MyIASM："></a>Innodb和MyIASM：</h4><p>区别：</p><ol><li>MyIASM是非事务安全的，而InnoDB是事务安全的</li><li>MyIASM锁的粒度是表级的，而InnoDB支持行级锁</li><li>MyIASM不支持外键，InnoDB支持外键</li><li>MyIASM支持全文类型（FullText）索引，而InnoDB不支持全文类型索引</li><li>MyIASM保存了表的行数，InnDB没有保存表的行数</li><li>MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM</li></ol><p>应用场景：</p><ol><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM</li><li>对于一般的Web应用来说，应该选择MyIASM，效率更高，特定场景再用InnoDB</li></ol><h4 id="数据库三大范式："><a href="#数据库三大范式：" class="headerlink" title="数据库三大范式："></a>数据库三大范式：</h4><h6 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h6><p>即表中的列的具有原子性，不可再分解，即列的信息，不能分解, 只要数据库是关系型数据库(MySQL/oracle/db2 /SQL server)，就自动的满足1NF。数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。通俗理解即一个字段只存储一项信息。</p><h6 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h6><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要我们设计一个主键来实现。</p><h6 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h6><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中定义的非主键字段</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>满足ACID条件：原子性、一致性、隔离性、持久性</p><p>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成</p><p>一致性：在事务开始之前和结束后，数据库的完整性没有被破坏</p><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p><p>持久性：事务结束之后，事务的结果是持久性的，即使断电结果也能保存下来</p><p>事务处理主要方法：</p><ol><li>用BEGIN、ROLLBACK、COMMIT实现，BEGIN开始一个事务、ROLLBACK事务回滚、COMMIT事务确认</li><li>直接用SET来改变MySQL的自动提交模式，SET AUTHCOMMIT=0禁止自动提交、SET AUTHCOMMIT=1开启自动提交</li></ol><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><h5 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h5><p>读未提交就是其他事务做到一半还未提交的数值可以被读出来</p><p>脏读：事务可以读取未提交的数据</p><h5 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h5><p>读已提交就是读取其他事务提交后的数值，比如B事务修改了某数据后还没有提交的话，A事务看到的值仍然是修改之前的数值。</p><p>可避免脏读的发生</p><h5 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h5><p>可重复读就是在开始读取数据（A事务开启）时候，即使其他事务修改了数据，但A事务读到的数据不管读几次都是不变的</p><p>可避免脏读、不可重复读的发生：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了</p><p>幻读：可重复读可能产生幻读，A事务开始准备插入一条记录id=6，B事务同时开始并成功插入一条记录id=6，此时A执行插入id=6操作，结果插入失败，因为id=6记录已经存在，这就是幻读。Innodb通过多版本并发控制(MVCC)解决了幻读问题。</p><h5 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h5><p>读加共享锁，写加排他锁</p><p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式（类似于Java多线程中的锁）使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read（可重复读）。</p><h4 id="事务回滚机制"><a href="#事务回滚机制" class="headerlink" title="事务回滚机制"></a>事务回滚机制</h4><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p><p>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p><p>锁分类：</p><ol><li>按操作划分：DML锁，DDL锁</li><li>按锁的粒度划分：表级锁、行级锁、页级锁</li><li>按锁级别划分：共享锁、排他锁</li><li>按加锁方式划分：自动锁、显示锁</li><li>按使用方式划分：乐观锁、悲观锁</li></ol><p>悲观锁：顾名思义，就是很悲观，每次去拿（取）数据的时候都认为别人会修改，所以每次在拿（取）数据的时候都会上锁，这样别人想拿这个数据就会block（阻塞）直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>悲观锁优缺点：悲观并发控制(悲观锁)采用”先取锁再分”的保守策略，为数据处理提供了安全的保证。但在效率方面，加锁机制会产生额外的开销，增加产生死锁的机会。</p><p>乐观锁：乐观锁的机制就是CAS，版本保护就是CAS中的期望值  CAS顾名思义，就是很乐观，每次去拿（取）数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，并发量不是很高的时候可以用，并发量高时，比如抢票，数据就存在Redis这类内存中了，就不存mysql了，mysql太慢了。</p><p>乐观锁优缺点：乐观锁认为事务直接竞争的概率是很小的，在提交的时候才锁定，所以不会产生死锁。但是如果两个事务同时写入数据库的某一行，这时，就会发现乐观锁的弊端。</p><p>行级锁：行级锁分为共享锁和排它锁。行级锁是Mysql中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，只有在通过索引条件检索数据的时候，才使用行级锁，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突概率最低，并发度最高</p><p>表级锁：表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大、发生锁冲突最高，并发度最低</p><p>页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>排它锁(exclusive locck)：排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。</p><p>共享锁(share lock)：共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。获准共享锁的事务只能读数据，不能写数据。</p><p>InnoDB：支持行级锁和表级锁，默认是行级锁</p><p>MyISAM &amp;Memory：这两个存储引擎都是采用表级锁</p><p>锁优化：</p><ol><li>读写分离</li><li>分段加锁</li><li>减少锁持有的时间</li><li>多个线程尽量以相同的顺序去获取资源</li></ol><h4 id="Innodb多版本并发控制（MVCC）"><a href="#Innodb多版本并发控制（MVCC）" class="headerlink" title="Innodb多版本并发控制（MVCC）"></a>Innodb多版本并发控制（MVCC）</h4><p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制所有不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p> InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，（存储的并不是实际的时间值，而是系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。 </p><h4 id="MYSQL索引类型"><a href="#MYSQL索引类型" class="headerlink" title="MYSQL索引类型"></a>MYSQL索引类型</h4><p>MySQL目前主要有以下几种索引类型：普通索引、唯一索引、主键索引、组合索引、全文索引。</p><ol><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有null）</li><li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li><li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>全文索引：对文本的内容进行分词，进行搜索</li></ol><p>普通索引-是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">直接创建索引</span><br><span class="line">CREATE INDEX index_name ON table(column(length))</span><br><span class="line">修改表结构的方式添加索引</span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br><span class="line">创建表的时候同时创建索引</span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br><span class="line">删除索引</span><br><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure><p>唯一索引-与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建唯一索引</span><br><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line">修改表结构</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br><span class="line">创建表的时候直接指定</span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    UNIQUE indexName (title(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>主键索引-是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>组合索引-指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure><p>全文索引-主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建表的适合添加全文索引</span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">);</span><br><span class="line">修改表结构添加全文索引</span><br><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br><span class="line">直接创建索引</span><br><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure><h4 id="索引的作用和优缺点"><a href="#索引的作用和优缺点" class="headerlink" title="索引的作用和优缺点"></a>索引的作用和优缺点</h4><p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入（插入、删除、更新表）的速度，同时也增加了数据库的尺寸大小。</p><p>优点：</p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><p>缺点：</p><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占物理空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。</li><li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ol><p>不建议使用索引情况：</p><ol><li>数据唯一性差的字段不要使用索引：比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。</li><li>频繁更新的字段不要使用索引：比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。</li><li>字段不在where语句出现时不要添加索引：只有在where语句出现，mysql才会去使用索引</li><li>数据量少的表不要使用索引：使用了改善也不大</li><li>另外，如果mysql估计使用全表扫描要比使用索引快，则不会使用索引。</li></ol><h4 id="索引、主键索引、唯一索引、组合索引"><a href="#索引、主键索引、唯一索引、组合索引" class="headerlink" title="索引、主键索引、唯一索引、组合索引"></a>索引、主键索引、唯一索引、组合索引</h4><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。</p><p>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。</p><p>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，不允许有空值，使用关键字 PRIMARY KEY 来创建。</p><p>索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是组合索引。</p><p>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</p><h4 id="主键、外键、唯一索引"><a href="#主键、外键、唯一索引" class="headerlink" title="主键、外键、唯一索引"></a>主键、外键、唯一索引</h4><p>定义：</p><ol><li>主键–唯一标识一条记录，不能有重复的，不允许为空</li><li>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值</li><li>唯一索引–该字段没有重复值，但可以有一个空值</li></ol><p>作用：</p><ol><li>主键–用来保证数据完整性</li><li>外键–用来和其他表建立联系用的</li><li>唯一索引–是提高查询排序的速度</li></ol><p>个数：</p><ol><li>主键–主键只能有一个</li><li>外键–一个表可以有多个外键</li><li>唯一索引–一个表可以有多个唯一索引</li></ol><h4 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h4><p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建表的时候添加FULLTEXT索引</span><br><span class="line">CTREATE TABLE my_table(</span><br><span class="line">id INT(10) PRIMARY KEY,</span><br><span class="line">name VARCHAR(10) NOT NULL,</span><br><span class="line">my_text text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,</span><br><span class="line">FULLTEXT(my_text));</span><br><span class="line">//创建表以后，在需要的时候添加FULLTEXT索引</span><br><span class="line">ALTER my_table ADD FULLTEXT ft_index(my_text);</span><br><span class="line">CREATE INDEX ft_index ON my_table(my_text);</span><br></pre></td></tr></table></figure><p>对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。</p><p>MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。</p><p>在MySQL中，全文索引支队英文有用，目前对中文还不支持。</p><p>在MySQL中，如果检索的字符串太短则无法检索得到预期的结果，检索的字符串长度至少为4字节，此外，如果检索的字符包括停止词，那么停止词会被忽略。</p><h5 id="BTree索引和B-Tree索引"><a href="#BTree索引和B-Tree索引" class="headerlink" title="BTree索引和B+Tree索引"></a>BTree索引和B+Tree索引</h5><h6 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h6><p>BTree是平衡搜索多叉树，设树的度为d（d&gt;1），高度为h，那么BTree要满足以一下条件：</p><ol><li>每个叶子结点的高度一样，等于h；</li><li>每个非叶子结点由n-1个key和n个指针point组成，其中d&lt;=n&lt;=2d,key和point相互间隔，结点两端一定是key；</li><li>叶子结点指针都为null；</li><li>非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；</li></ol><p><img src="201907070713.png" alt="20070713"></p><p>在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。</p><h6 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h6><p>B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：</p><ol><li>B+Tree中的非叶子结点不存储数据，只存储键值；</li><li>B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应的数据的物理地址；</li></ol><p><img src="201907070714.png" alt="270714"></p><p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的一个扇区是整数倍的page（页），页是存储中的一个单位，通常默认为4K，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data域，就可以存储更多的key。带顺序索引的B+TREE。很多存储引擎在B+Tree的基础上进行了优化，添加了指向相邻叶节点的指针，形成了带有顺序访问指针的B+Tree，这样做是为了提高区间查找的效率，只要找到第一个值那么就可以顺序的查找后面的值。</p><h4 id="SQL常见语句"><a href="#SQL常见语句" class="headerlink" title="SQL常见语句"></a>SQL常见语句</h4><p>数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的数据库</span><br><span class="line">SHOW DATABASES ;</span><br><span class="line"># 创建一个数据库</span><br><span class="line">CREATE DATABASE name;</span><br><span class="line"># 删除一个数据库</span><br><span class="line">DROP DATABASE name;</span><br><span class="line"># 使用这个数据库</span><br><span class="line">USE name;</span><br></pre></td></tr></table></figure><p>表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的表</span><br><span class="line">SHOW TABLES ;</span><br><span class="line"># 创建一个表</span><br><span class="line">CREATE TABLE n(id INT, name VARCHAR(10));</span><br><span class="line">CREATE TABLE m(id INT, name VARCHAR(10), PRIMARY KEY (id), FOREIGN KEY (id) REFERENCES n(id), UNIQUE (name));</span><br><span class="line">CREATE TABLE m(id INT, name VARCHAR(10));</span><br><span class="line"># 直接将查询结果导入或复制到新创建的表</span><br><span class="line">CREATE TABLE n SELECT * FROM m;</span><br><span class="line"># 新创建的表与一个存在的表的数据结构类似</span><br><span class="line">CREATE TABLE m LIKE n;</span><br><span class="line"># 创建一个临时表</span><br><span class="line"># 临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</span><br><span class="line">CREATE TEMPORARY TABLE l(id INT, name VARCHAR(10));</span><br><span class="line"># 直接将查询结果导入或复制到新创建的临时表</span><br><span class="line">CREATE TEMPORARY TABLE tt SELECT * FROM n;</span><br><span class="line"># 删除一个存在表</span><br><span class="line">DROP TABLE IF EXISTS m;</span><br><span class="line"># 更改存在表的名称</span><br><span class="line">ALTER TABLE n RENAME m;</span><br><span class="line">RENAME TABLE n TO m;</span><br><span class="line"># 查看表的结构(以下五条语句效果相同）</span><br><span class="line">DESC n;   # 因为简单，所以建议使用（DESC表示descend降序，ASC表示ascend升序）</span><br><span class="line">DESCRIBE n;       #（discribe）</span><br><span class="line">SHOW COLUMNS IN n;</span><br><span class="line">SHOW COLUMNS FROM n;</span><br><span class="line">EXPLAIN n;</span><br><span class="line"># 查看表的创建语句</span><br><span class="line">SHOW CREATE TABLE n;</span><br></pre></td></tr></table></figure><p>表的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加字段</span><br><span class="line">ALTER TABLE n ADD age VARCHAR(2) ;</span><br><span class="line"># 删除字段</span><br><span class="line">ALTER TABLE n DROP age;</span><br><span class="line"># 更改字段属性和属性</span><br><span class="line">ALTER TABLE n CHANGE age a INT;</span><br><span class="line"># 只更改字段属性</span><br><span class="line">ALTER TABLE n MODIFY age VARCHAR(7) ;</span><br></pre></td></tr></table></figure><p>表的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 增加数据</span><br><span class="line">INSERT INTO n VALUES (1, &apos;tom&apos;, &apos;23&apos;), (2, &apos;john&apos;, &apos;22&apos;);</span><br><span class="line">INSERT INTO n SELECT * FROM n;  # 把数据复制一遍重新插入</span><br><span class="line"># 删除数据</span><br><span class="line">DELETE FROM n WHERE id = 2;</span><br><span class="line"># 更改数据</span><br><span class="line">UPDATE n SET name = &apos;tom&apos; WHERE id = 2;</span><br><span class="line"># 数据查找</span><br><span class="line">SELECT * FROM n WHERE name LIKE &apos;%h%&apos;;</span><br><span class="line"># 数据排序(反序)</span><br><span class="line">SELECT * FROM n ORDER BY name, id DESC ;</span><br></pre></td></tr></table></figure><p>键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 添加主键</span><br><span class="line">ALTER TABLE n ADD PRIMARY KEY (id);</span><br><span class="line">ALTER TABLE n ADD CONSTRAINT pk_n PRIMARY KEY (id);   # 主键只有一个，所以定义键名似乎也没有什么用</span><br><span class="line"># 删除主键</span><br><span class="line">ALTER TABLE n DROP PRIMARY KEY ;</span><br><span class="line"># 添加外键</span><br><span class="line">ALTER TABLE m ADD FOREIGN KEY (id) REFERENCES n(id);    # 自动生成键名m_ibfk_1</span><br><span class="line">ALTER TABLE m ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES n(id);   # 使用定义的键名fk_id</span><br><span class="line"># 删除外键</span><br><span class="line">ALTER TABLE m DROP FOREIGN KEY `fk_id`;</span><br><span class="line"># 修改外键</span><br><span class="line">ALTER TABLE m DROP FOREIGN KEY `fk_id`, ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES n(id);    # 删除之后从新建</span><br><span class="line"># 添加唯一键</span><br><span class="line">ALTER TABLE n ADD UNIQUE (name);</span><br><span class="line">ALTER TABLE n ADD UNIQUE u_name (name);</span><br><span class="line">ALTER TABLE n ADD UNIQUE INDEX u_name (name);</span><br><span class="line">ALTER TABLE n ADD CONSTRAINT u_name UNIQUE (name);</span><br><span class="line">CREATE UNIQUE INDEX u_name ON n(name);</span><br><span class="line"># 添加索引</span><br><span class="line">ALTER TABLE n ADD INDEX (age);</span><br><span class="line">ALTER TABLE n ADD INDEX i_age (age);</span><br><span class="line">CREATE INDEX i_age ON n(age);</span><br><span class="line"># 删除索引或唯一键</span><br><span class="line">DROP INDEX u_name ON n;</span><br><span class="line">DROP INDEX i_age ON n;</span><br></pre></td></tr></table></figure><p>视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">CREATE VIEW v AS SELECT id, name FROM n;</span><br><span class="line">CREATE VIEW v(id, name) AS SELECT id, name FROM n;</span><br><span class="line"># 查看视图(与表操作类似)</span><br><span class="line">SELECT * FROM v;</span><br><span class="line">DESC v;</span><br><span class="line"># 查看创建视图语句</span><br><span class="line">SHOW CREATE VIEW v;</span><br><span class="line"># 更改视图</span><br><span class="line">CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</span><br><span class="line">ALTER VIEW v AS SELECT name FROM n ;</span><br><span class="line"># 删除视图</span><br><span class="line">DROP VIEW IF EXISTS v;</span><br></pre></td></tr></table></figure><p>链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 内联接</span><br><span class="line">SELECT * FROM m INNER JOIN n ON m.id = n.id;</span><br><span class="line"># 左外联接</span><br><span class="line">SELECT * FROM m LEFT JOIN n ON m.id = n.id;</span><br><span class="line"># 右外联接</span><br><span class="line">SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</span><br><span class="line"># 交叉联接</span><br><span class="line">SELECT * FROM m CROSS JOIN n;   # 标准写法</span><br><span class="line">SELECT * FROM m, n;</span><br><span class="line"># 类似全连接full join的联接用法</span><br><span class="line">SELECT id,name FROM m</span><br><span class="line">UNION</span><br><span class="line">SELECT id,name FROM n;</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># 聚合函数</span><br><span class="line">SELECT count(id) AS total FROM n;   # 总数</span><br><span class="line">SELECT sum(age) AS all_age FROM n;   # 总和</span><br><span class="line">SELECT avg(age) AS all_age FROM n;   # 平均值</span><br><span class="line">SELECT max(age) AS all_age FROM n;   # 最大值</span><br><span class="line">SELECT min(age) AS all_age FROM n;   # 最小值</span><br><span class="line"># 数学函数</span><br><span class="line">SELECT abs(-5);   # 绝对值</span><br><span class="line">SELECT bin(15), oct(15), hex(15);   # 二进制，八进制，十六进制</span><br><span class="line">SELECT pi();   # 圆周率3.141593</span><br><span class="line">SELECT ceil(5.5);   # 大于x的最小整数值6</span><br><span class="line">SELECT floor(5.5);   # 小于x的最大整数值5</span><br><span class="line">SELECT greatest(3,1,4,1,5,9,2,6);   # 返回集合中最大的值9</span><br><span class="line">SELECT least(3,1,4,1,5,9,2,6);    # 返回集合中最小的值1</span><br><span class="line">SELECT mod(5,3);    # 余数2</span><br><span class="line">SELECT rand();    # 返回０到１内的随机值，每次不一样</span><br><span class="line">SELECT rand(5);   # 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</span><br><span class="line">SELECT round(1415.1415);   # 四舍五入1415</span><br><span class="line">SELECT round(1415.1415, 3);   # 四舍五入三位数1415.142</span><br><span class="line">SELECT round(1415.1415, -1);    # 四舍五入整数位数1420</span><br><span class="line">SELECT truncate(1415.1415, 3);    # 截短为3位小数1415.141</span><br><span class="line">SELECT truncate(1415.1415, -1);   # 截短为-1位小数1410</span><br><span class="line">SELECT sign(-5);    # 符号的值负数-1</span><br><span class="line">SELECT sign(5);    # 符号的值正数1</span><br><span class="line">SELECT sqrt(9);   # 平方根3</span><br><span class="line">SELECT sqrt(9);   # 平方根3</span><br><span class="line"># 字符串函数</span><br><span class="line">SELECT concat(&apos;a&apos;, &apos;p&apos;, &apos;p&apos;, &apos;le&apos;);   # 连接字符串-apple</span><br><span class="line">SELECT concat_ws(&apos;,&apos;, &apos;a&apos;, &apos;p&apos;, &apos;p&apos;, &apos;le&apos;);   # 连接用&apos;,&apos;分割字符串-a,p,p,le</span><br><span class="line">SELECT insert(&apos;chinese&apos;, 3, 2, &apos;IN&apos;);    # 将字符串&apos;chinese&apos;从3位置开始的2个字符替换为&apos;IN&apos;-chINese</span><br><span class="line">SELECT left(&apos;chinese&apos;, 4);   # 返回字符串&apos;chinese&apos;左边的4个字符-chin</span><br><span class="line">SELECT right(&apos;chinese&apos;, 3);   # 返回字符串&apos;chinese&apos;右边的3个字符-ese</span><br><span class="line">SELECT substring(&apos;chinese&apos;, 3);   # 返回字符串&apos;chinese&apos;第三个字符之后的子字符串-inese</span><br><span class="line">SELECT substring(&apos;chinese&apos;, -3);   # 返回字符串&apos;chinese&apos;倒数第三个字符之后的子字符串-ese</span><br><span class="line">SELECT substring(&apos;chinese&apos;, 3, 2);   # 返回字符串&apos;chinese&apos;第三个字符之后的两个字符-in</span><br><span class="line">SELECT trim(&apos; chinese &apos;);    # 切割字符串&apos; chinese &apos;两边的空字符-&apos;chinese&apos;</span><br><span class="line">SELECT ltrim(&apos; chinese &apos;);    # 切割字符串&apos; chinese &apos;两边的空字符-&apos;chinese &apos;</span><br><span class="line">SELECT rtrim(&apos; chinese &apos;);    # 切割字符串&apos; chinese &apos;两边的空字符-&apos; chinese&apos;</span><br><span class="line">SELECT repeat(&apos;boy&apos;, 3);    # 重复字符&apos;boy&apos;三次-&apos;boyboyboy&apos;</span><br><span class="line">SELECT reverse(&apos;chinese&apos;);    # 反向排序-&apos;esenihc&apos;</span><br><span class="line">SELECT length(&apos;chinese&apos;);   # 返回字符串的长度-7</span><br><span class="line">SELECT upper(&apos;chINese&apos;), lower(&apos;chINese&apos;);    # 大写小写 CHINESE    chinese</span><br><span class="line">SELECT ucase(&apos;chINese&apos;), lcase(&apos;chINese&apos;);    # 大写小写 CHINESE    chinese</span><br><span class="line">SELECT position(&apos;i&apos; IN &apos;chinese&apos;);    # 返回&apos;i&apos;在&apos;chinese&apos;的第一个位置-3</span><br><span class="line">SELECT position(&apos;e&apos; IN &apos;chinese&apos;);    # 返回&apos;i&apos;在&apos;chinese&apos;的第一个位置-5</span><br><span class="line">SELECT strcmp(&apos;abc&apos;, &apos;abd&apos;);    # 比较字符串，第一个参数小于第二个返回负数- -1</span><br><span class="line">SELECT strcmp(&apos;abc&apos;, &apos;abb&apos;);    # 比较字符串，第一个参数大于第二个返回正数- 1</span><br><span class="line"># 时间函数</span><br><span class="line">SELECT current_date, current_time, now();    # 2018-01-13   12:33:43    2018-01-13 12:33:43</span><br><span class="line">SELECT hour(current_time), minute(current_time), second(current_time);    # 12  31   34</span><br><span class="line">SELECT year(current_date), month(current_date), week(current_date);   # 2018    1   1</span><br><span class="line">SELECT quarter(current_date);   # 1</span><br><span class="line">SELECT monthname(current_date), dayname(current_date);   # January  Saturday</span><br><span class="line">SELECT dayofweek(current_date), dayofmonth(current_date), dayofyear(current_date);    # 7   13  13</span><br><span class="line"># 控制流函数</span><br><span class="line">SELECT if(3&gt;2, &apos;t&apos;, &apos;f&apos;), if(3&lt;2, &apos;t&apos;, &apos;f&apos;);    # t f</span><br><span class="line">SELECT ifnull(NULL, &apos;t&apos;), ifnull(2, &apos;t&apos;);    # t 2</span><br><span class="line">SELECT isnull(1), isnull(1/0);    # 0 1 是null返回1，不是null返回0</span><br><span class="line">SELECT nullif(&apos;a&apos;, &apos;a&apos;), nullif(&apos;a&apos;, &apos;b&apos;);    # null a 参数相同或成立返回null，不同或不成立则返回第一个参数</span><br><span class="line">SELECT CASE 2</span><br><span class="line">       WHEN 1 THEN &apos;first&apos;</span><br><span class="line">       WHEN 2 THEN &apos;second&apos;</span><br><span class="line">       WHEN 3 THEN &apos;third&apos;</span><br><span class="line">       ELSE &apos;other&apos;</span><br><span class="line">       END ;     # second</span><br><span class="line"># 系统信息函数</span><br><span class="line">SELECT database();    # 当前数据库名-test</span><br><span class="line">SELECT connection_id();   # 当前用户id-306</span><br><span class="line">SELECT user();    # 当前用户-root@localhost</span><br><span class="line">SELECT version();   # 当前mysql版本</span><br><span class="line">SELECT found_rows();    # 返回上次查询的检索行数</span><br></pre></td></tr></table></figure><p>用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 增加用户</span><br><span class="line">CREATE USER &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;test&apos;;</span><br><span class="line">INSERT INTO mysql.user(Host, User, Password) VALUES (&apos;localhost&apos;, &apos;test&apos;, Password(&apos;test&apos;));    # 在用户表中插入用户信息，直接操作User表不推荐</span><br><span class="line"># 删除用户</span><br><span class="line">DROP USER &apos;test&apos;@&apos;localhost&apos;;</span><br><span class="line">DELETE FROM mysql.user WHERE User=&apos;test&apos; AND Host=&apos;localhost&apos;;</span><br><span class="line">FLUSH PRIVILEGES ;</span><br><span class="line"># 更改用户密码</span><br><span class="line">SET PASSWORD FOR &apos;test&apos;@&apos;localhost&apos; = PASSWORD(&apos;test&apos;);</span><br><span class="line">UPDATE mysql.user SET Password=Password(&apos;t&apos;) WHERE User=&apos;test&apos; AND Host=&apos;localhost&apos;;</span><br><span class="line">FLUSH PRIVILEGES ;</span><br><span class="line"># 用户授权</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO test@localhost IDENTIFIED BY &apos;test&apos;;</span><br><span class="line"># 授予用&apos;test&apos;密码登陆成功的test@localhost用户操作所有数据库的所有表的所有的权限</span><br><span class="line">FLUSH PRIVILEGES ;   # 刷新系统权限表,使授予权限生效</span><br><span class="line"># 撤销用户授权</span><br><span class="line">REVOKE DELETE ON *.* FROM &apos;test&apos;@&apos;localhost&apos;;   # 取消该用户的删除权限</span><br></pre></td></tr></table></figure><p>存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 创建存储过程</span><br><span class="line">DELIMITER //    # 无参数</span><br><span class="line">CREATE PROCEDURE getDates()</span><br><span class="line">  BEGIN</span><br><span class="line">    SELECT * FROM test ;</span><br><span class="line">  END //</span><br><span class="line">CREATE PROCEDURE getDates_2(IN id INT)    # in参数</span><br><span class="line">  BEGIN</span><br><span class="line">    SELECT * FROM test WHERE a = id;</span><br><span class="line">  END //</span><br><span class="line">CREATE PROCEDURE getDates_3(OUT sum INT)    # out参数</span><br><span class="line">  BEGIN</span><br><span class="line">    SET sum = (SELECT count(*) FROM test);</span><br><span class="line">  END //</span><br><span class="line">CREATE PROCEDURE getDates_4(INOUT i INT)    # inout参数</span><br><span class="line">  BEGIN</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">  END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"># 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS getDates;</span><br><span class="line"># 修改存储过程的特性</span><br><span class="line">ALTER PROCEDURE getDates MODIFIES SQL DATA ;</span><br><span class="line"># 修改存储过程语句（删除再重建）略</span><br><span class="line"># 查看存储过程</span><br><span class="line">SHOW PROCEDURE STATUS LIKE &apos;getDates&apos;;    # 状态</span><br><span class="line">SHOW CREATE PROCEDURE getDates_3;   # 语句</span><br><span class="line"># 调用存储过程</span><br><span class="line">CALL getDates();</span><br><span class="line">CALL getDates_2(1);</span><br><span class="line">CALL getDates_3(@s);</span><br><span class="line">SELECT @s;</span><br><span class="line">SET @i = 1;</span><br><span class="line">CALL getDates_4(@i);</span><br><span class="line">SELECT @i;    # @i = 2</span><br></pre></td></tr></table></figure><h5 id="SQL语句关键字"><a href="#SQL语句关键字" class="headerlink" title="SQL语句关键字"></a>SQL语句关键字</h5><p>SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。</p><ol><li>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index</li><li>数据操纵：select ,insert,update,delete</li><li>数据控制：revoke</li><li>数据查询：select</li></ol><h5 id="DROP、TRUNCATE、DELETE"><a href="#DROP、TRUNCATE、DELETE" class="headerlink" title="DROP、TRUNCATE、DELETE"></a>DROP、TRUNCATE、DELETE</h5><ol><li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。</li><li>TRUNCATE TABLE一次性地从表中删除所有的数据，不能通过ROLLBACK回滚。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li><li>DROP是DDL，会隐式提交，所以不能回滚，不会触发触发器。</li><li>表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，DELETE操作不会减少表或索引所占用的空间。DROP语句将表所占用的空间全释放掉。</li><li>应用范围：TRUNCATE只能对TABLE使用；DELETE可以是TABLE和VIEW；DROP可以删除表和数据库。</li><li>TRUNCATE和DELETE只删除数据，DROP则删除整个表（结构和数据）。TRUNCATE与不带WHERE的DELETE：只删除数据，而不删除表的结构（定义）；DROP语句将删除表的结构，被依赖的约束（constrain)，触发器（trigger)，索引（index）也会被删除；而依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</li><li>对于外键（FOREIGN KEY）约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带where 子句的 DELETE 语句。TRUNCATE TABLE不能用于参与了索引视图的表。</li></ol><h5 id="MySQL连接方式"><a href="#MySQL连接方式" class="headerlink" title="MySQL连接方式"></a>MySQL连接方式</h5><h6 id="内链接：（相交部分"><a href="#内链接：（相交部分" class="headerlink" title="内链接：（相交部分)"></a>内链接：（相交部分)</h6><p>关键字：inner join on</p><p>语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;</p><p><img src="201907070720.png" alt="270720"></p><h6 id="左链接：（左边部分）"><a href="#左链接：（左边部分）" class="headerlink" title="左链接：（左边部分）"></a>左链接：（左边部分）</h6><p>关键字：left join on / left outer join on</p><p>语句：select * from a_table a left join b_table b on a.a_id = b.b_id;</p><p><img src="201907070721.png" alt="270721"></p><h6 id="右链接：（右边部分）"><a href="#右链接：（右边部分）" class="headerlink" title="右链接：（右边部分）"></a>右链接：（右边部分）</h6><p>关键字：right join on/right outer join on</p><p>语句：select * from a_table a right outer join b_table b on a.a_id = b.b_id;</p><p><img src="201907070722.png" alt="20070722"></p><h6 id="全链接：目前MySQL不支持"><a href="#全链接：目前MySQL不支持" class="headerlink" title="全链接：目前MySQL不支持"></a>全链接：目前MySQL不支持</h6><h4 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h4><ol><li>客户端先发送一条查询给服务器；</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回给存储在缓存中的结果，否则进入下一个阶段；</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回客户端。</li></ol><h4 id="数据库高并发解决方法总结"><a href="#数据库高并发解决方法总结" class="headerlink" title="数据库高并发解决方法总结"></a>数据库高并发解决方法总结</h4><p>一个项目刚开始的时候是为了实现基本功能，随着版本和功能的迭代，大数据和高并发成了软件设计必须考虑的问题！本质很简单，一个是慢，一个是等。两者是相互关联的，因为慢，所以要等，因为等，所以慢，解决了慢，也就解决了等，解决了等，也就解决了慢。<br>关键是如何解决慢和等，核心一个是短，一个是少，一个是分流，最后一种是集群/横向扩张/读写分离/建立主从。</p><p>短是指路径要短：<br>典型的mvc结构是请求-&gt;controller-&gt;model-&gt;dao-&gt;view，然后把页面返回给用户。要想短的话，</p><ol><li>页面静态化-用户可以直接获取页面，不用走那么多流程，比较适用于页面不频繁更新。</li><li>使用缓存-第一次获取数据从数据库准提取，然后保存在缓存中，以后就可以直接从缓存提取数据。不过需要有机制维持缓存和数据库的一致性。</li><li>使用储存过程-那些处理一次请求需要多次访问数据库的操作，可以把操作整合到储存过程，这样只要一次数据库访问就可以了。</li><li>批量读取-高并发情况下，可以把多个请求的查询合并到一次进行，以减少数据库的访问次数</li><li>延迟修改-高并发情况下，可以把多次修改请求，先保存在缓存中，然后定时将缓存中的数据保存到数据库中，风险是可能会断电丢失缓存中的数据，</li><li>使用索引-索引可以看作是特殊的缓存，尽量使用索引就要求where字句中精确的给出索引列的值。</li></ol><p>少是指查询的数据要少</p><ol><li>分表-把本来同一张表的内容，可以按照地区，类别等分成多张表，很简单的一个思路，但是要尽量避免分出来的多表关联查询。</li><li>分离活跃数据-例如登录用户业务，注册用户很多，但是活跃的登录用户很少，可以把活跃用户专门保存一张表，查询是先查询活跃表，没有的话再查总表，这也类似与缓存啦。</li><li>分块-数据库层面的优化，对程序是透明的，查询大数据只用找到相应块就行。</li></ol><p>分流三种:</p><ol><li>集群-将并发请求分配到不同的服务器上，可以是业务服务器，也可以是数据库服务器。</li><li>分布式-分布式是把单次请求的多项业务逻辑分配到多个服务器上，这样可以同步处理很多逻辑，一般使用与特别复杂的业务请求。</li><li>CDN -在域名解析层面的分流，例如将华南地区的用户请求分配到华南的服务器，华中地区的用户请求分配到华中的服务器。</li></ol><h4 id="高并发数据库系统"><a href="#高并发数据库系统" class="headerlink" title="高并发数据库系统"></a>高并发数据库系统</h4><ol><li>数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化</li><li>使用缓存，尽量减少据库 IO</li><li>分布式数据库、分布式缓存</li><li>服务器的负载均衡</li></ol><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h6 id="选择正确的存储引擎"><a href="#选择正确的存储引擎" class="headerlink" title="选择正确的存储引擎"></a>选择正确的存储引擎</h6><p>以 MySQL为例，包括有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。</p><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><h6 id="优化字段的数据类型"><a href="#优化字段的数据类型" class="headerlink" title="优化字段的数据类型"></a>优化字段的数据类型</h6><p>记住一个原则，越小的列会越快。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间。</p><h6 id="为常用的搜索字段添加索引"><a href="#为常用的搜索字段添加索引" class="headerlink" title="为常用的搜索字段添加索引"></a>为常用的搜索字段添加索引</h6><p>索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么最好是为其建立索引，除非你要搜索的字段是大的文本字段，那应该建立全文索引。</p><h6 id="避免使用Select"><a href="#避免使用Select" class="headerlink" title="避免使用Select *"></a>避免使用Select *</h6><p>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。即使你要查询数据表的所有字段，也尽量不要用*通配符，善用内置提供的字段排除定义也许能给带来更多的便利。</p><h6 id="使用-ENUM-而不是-VARCHAR"><a href="#使用-ENUM-而不是-VARCHAR" class="headerlink" title="使用 ENUM 而不是 VARCHAR"></a>使用 ENUM 而不是 VARCHAR</h6><p>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。例如，性别、民族、部门和状态之类的这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p><h6 id="尽可能的使用-NOT-NULL"><a href="#尽可能的使用-NOT-NULL" class="headerlink" title="尽可能的使用 NOT NULL"></a>尽可能的使用 NOT NULL</h6><p>除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。 NULL其实需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。+</p><h6 id="固定长度的表会更快"><a href="#固定长度的表会更快" class="headerlink" title="固定长度的表会更快"></a>固定长度的表会更快</h6><p>如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</p><p>固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p><p>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p><h4 id="SQL语句优化方法"><a href="#SQL语句优化方法" class="headerlink" title="SQL语句优化方法"></a>SQL语句优化方法</h4><ol><li>where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在where子句的末尾.HAVING最后。</li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</li><li>避免在索引列上使用计算</li><li>避免在索引列上使用IS NULL和IS NOT NULL</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li></ol><h4 id="实践中优化MySQL"><a href="#实践中优化MySQL" class="headerlink" title="实践中优化MySQL"></a>实践中优化MySQL</h4><p>从效果上第一条影响最大，后面越来越小。</p><ol><li>SQL语句及索引的优化</li><li>数据库表结构的优化</li><li>系统配置的优化</li><li>硬件的优化</li></ol><h4 id="优化数据库方法"><a href="#优化数据库方法" class="headerlink" title="优化数据库方法"></a>优化数据库方法</h4><ol><li>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM</li><li>使用连接(JOIN)来代替子查询</li><li>适用联合(UNION)来代替手动创建的临时表</li><li>事务处理</li><li>锁定表、优化事务处理</li><li>适用外键，优化锁定表</li><li>建立索引</li><li>优化查询语句</li></ol><h4 id="NULL含义"><a href="#NULL含义" class="headerlink" title="NULL含义"></a>NULL含义</h4><p>NULL这个值表示UNKNOWN(未知)，它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。</p><p>使用IS  NULL来进行NULL判断</p><h4 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h4><p>char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：  </p><p>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足。（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．  </p><p>varchar的适用场景:</p><ol><li>字符串列得最大长度比平均长度大很多。</li><li>字符串很少被更新，容易产生存储碎片 </li><li>使用多字节字符集存储字符串</li></ol><p>char的适用场景:</p><ol><li>存储具有近似得长度（md5值,身份证，手机号）,长度比较短小得字符串（因为varchar需要额外空间记录字符串长度），更适合经常更新得字符串，更新时不会出现页分裂得情况，避免出现存储碎片，获得更好的io性能。</li></ol><h4 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h4><h6 id="not-null：非空约束，强制列不接受空值。"><a href="#not-null：非空约束，强制列不接受空值。" class="headerlink" title="not null：非空约束，强制列不接受空值。"></a>not null：非空约束，强制列不接受空值。</h6><p>例：创建表时，name varchar(6) not null</p><h6 id="unique：唯一性约束"><a href="#unique：唯一性约束" class="headerlink" title="unique：唯一性约束"></a>unique：唯一性约束</h6><p>约束唯一标识数据库表中的每条记录 </p><p>unique和primary key都为数据提供了唯一性约束</p><p>primary key 拥有自动定义的unique约束</p><p>注意：每个表中只能有一个primary key约束，但是可以有多个Unique约束  </p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.name int unique</span><br><span class="line">2.unique(column_name)</span><br><span class="line">3.CONSTRAINT uc_PersonID UNIQUE (Id_P, LastName)：添加多个约束  </span><br><span class="line">4.alter table table_name add unique(column_name)：增加表中的约束  </span><br><span class="line">5.ALTER TABLE table_name DROP CONSTRAINT 主键名：删除约束</span><br></pre></td></tr></table></figure><h6 id="Primary-Key约束"><a href="#Primary-Key约束" class="headerlink" title="Primary Key约束"></a>Primary Key约束</h6><p>约束唯一标识数据库表中的每条记录</p><p>主键必须包含唯一的值，主键列不能为空</p><p>每个表都应该有个主键，但只能有一个主键  </p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① StudentID int not null primary key   创建学生编号为主键</span><br><span class="line">② primary key(StudentID)            创建学生编号为主键</span><br><span class="line">③ primary key(StudentID, Email)      创建学生ID和Email为联合主键</span><br><span class="line">④ alter table table_name add primary key(column_name) 为已存在的列创建主键</span><br><span class="line">⑤ alter table table_name drop primary key  删除主键约束</span><br><span class="line">⑥ alter table table_name drop constraint 主键约束名  删除主键约束</span><br></pre></td></tr></table></figure><h6 id="foreign-key约束"><a href="#foreign-key约束" class="headerlink" title="foreign key约束"></a>foreign key约束</h6><p>一个表中的foreign key指向另一个表的primary key </p><p>foreign key约束用于预防破坏表之间连接的动作</p><p>foreign key约束也能防止非法数据插入外键列，因为它必须是指向的表中的主键值</p><p> 语法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreign key (column_name) references 主表名（主键列名）创建column_name为主表名的外键  </span><br><span class="line">column_name int foreign key references 主表名（主键列名）创建column_name为主表名的外键  </span><br><span class="line">alter table table_name add foreign key (列名) references 主表名（主键列名）为已存在的列创建外键  </span><br><span class="line">alter table table_name drop foreign key 外键约束名 删除外键约束</span><br></pre></td></tr></table></figure><h6 id="check-约束"><a href="#check-约束" class="headerlink" title="check 约束"></a>check 约束</h6><p>check约束用于限制列中的值的范围</p><p>如果对个单个列做check约束，那么该列只可以输入特定数值</p><p>如果一个表定义check约束，那么此约束会在特定的列对值进行限制  </p><p>语法：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StudentID int not null check (StudentID&gt;0) 限制StudentID输入的值要大于0</span><br><span class="line">sex varchar(2) not null check(sex=&apos;男&apos; or sex=&apos;女&apos;) 限制sex的性别只能是男或者女  </span><br><span class="line">alter table table_name add check(列名&gt;0)   向已有的列加入check约束</span><br></pre></td></tr></table></figure><h6 id="default约束："><a href="#default约束：" class="headerlink" title="default约束："></a>default约束：</h6><p>用于向列中插入默认值，若没有规定其他值，那么会将默认值添加到所有的新记录中  </p><p>语法：name varchar(10) default ‘张三’  name默认插入张三的名字</p><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><p>分为以下四类：</p><ol><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ol><p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。</p><h4 id="基本表和视图"><a href="#基本表和视图" class="headerlink" title="基本表和视图"></a>基本表和视图</h4><p>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。</p><p>视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表。</p><h4 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h4><ol><li>视图能够简化用户的操作 </li><li>视图使用户能以多种角度看待同一数据；</li><li>视图为数据库提供了一定程度的逻辑独立性；</li><li>视图能够对机密数据提供安全保护。</li></ol><h4 id="MySQL运维优化"><a href="#MySQL运维优化" class="headerlink" title="MySQL运维优化"></a>MySQL运维优化</h4><ol><li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li><li>mysql库主从读写分离。</li><li>找规律分表，减少单表中的数据量提高查询速度。</li><li>添加缓存机制，比如memcached，apc等。</li><li>不经常改动的页面，生成静态页面。</li><li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</li></ol><h4 id="大流量网站，解决各页面访问量统计问题"><a href="#大流量网站，解决各页面访问量统计问题" class="headerlink" title="大流量网站，解决各页面访问量统计问题"></a>大流量网站，解决各页面访问量统计问题</h4><ol><li>确认服务器是否能支撑当前访问量。</li><li>优化数据库访问。</li><li>禁止外部访问链接（盗链）, 比如图片盗链。</li><li>控制文件下载。</li><li>使用不同主机分流。</li><li>使用浏览统计软件，了解访问量，有针对性的进行优化</li></ol><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>不用连接池的话，就要根据每个请求或者每个用户来建立连接。这样的缺点是显而易见的。</p><ol><li>这样需要建立很多连接，建立连接是要花很多时间的。</li><li>有的用户建立了连接，却没有使用，造成了资源浪费。</li></ol><p>因此需要用连接池，如下先建好5个连接（Tomcat默认的连接是10到100个，可修改），每次请求来了直接用，用完了还回去，如果请求太多，来不及处理，超时会报错（线程池请求太多会排队，不会超时报错）</p><p><img src="201907070814.png" alt="2010814"></p><h4 id="JDBC和ODBC"><a href="#JDBC和ODBC" class="headerlink" title="JDBC和ODBC"></a>JDBC和ODBC</h4><p>JDBC使用起来更方便，ODBC因为是C编写，性能更快一些。</p><p>JDBC：（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，它是Java十三个规范之一。可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。 JDBC的最大特点是它独立于详细的关系数据库。</p><p>ODBC：是微软公司开放服务结构(WOSA，Windows Open Services Architecture)中有关数据库的一个组成部分。一个基于ODBC的应用程序对数据库的操作不依赖数据库类型，能以统一的方式处理全部的数据库。</p><h4 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h4><p><img src="201907070815.png" alt="2070815"></p><p>一句话解释：Slaver读取Master的binlog并顺序执行</p><p>概述：</p><ol><li>MySQL的主从复制是一个异步的复制过程（虽然一般情况下感觉是实时的），在Master与Slave之间实现整个主从复制的过程是由三个线程参与完成的。其中有两个线程（SQL线程和IO线程）在Slave端，另一个线程（I/O线程）在Master端。</li><li>要实现MySQL的主从复制，首先必须打开Master端的binlog记录功能，否则就无法实现。因为整个复制过程实际上就是Slave从Master端获取binlog日志，然后再在Slave上以相同顺序执行获取的binlog日志中的记录的各种SQL操作</li></ol><p>详细过程</p><ol><li>在Slave 服务器上执行sart slave命令开启主从复制开关，开始进行主从复制。</li><li>此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容</li><li>Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。</li><li>当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容</li><li>Slave服务器端的SQL线程会实时检测本地Relay Log 中新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点</li></ol><p>知识点</p><ol><li>3个线程，主库IO，从库IO和SQL及作用</li><li>master.info（从库）作用</li><li>relay-log 作用</li><li>异步复制</li><li>binlog作用（如果需要级联需要开启Binlog）</li></ol><p>小结</p><ol><li>主从复制是异步的逻辑的SQL语句级的复制</li><li>复制时，主库有一个I/O线程，从库有两个线程，I/O和SQL线程</li><li>实现主从复制的必要条件是主库要开启记录binlog功能</li><li>作为复制的所有Mysql节点的server-id都不能相同</li><li>binlog文件只记录对数据库有更改的SQL语句（来自主库内容的变更），不记录任何查询（select，show）语句</li></ol><p>工作中常用主从模式</p><p><img src="201907070816.png" alt="20070816"></p><h4 id="数据库事务断电"><a href="#数据库事务断电" class="headerlink" title="数据库事务断电"></a>数据库事务断电</h4><p>本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？</p><p>我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>数据库的两段锁协议是指所有事务必须分两个阶段对数据项进行加锁和解锁<br>1.扩展阶段<br>在对任何数据项的读、写之前，要申请并获得该数据项的封锁。</p><p>2.收缩阶段<br>每个事务中，所有的封锁请求必须先于解锁请求。<br>例如：事务T遵循两段锁协议，其封锁协议为：<br>BEGIN TRANSACTION;<br>LOCK（A）；READ A; A := A + 100; WRITE A; LOCK(B); UNLOCK(A); READ(B), UNLOCK(B),;<br>COMMIT;     </p><p>可以证明：若并发执行的所有事务均遵守两段锁协议，则对这些并行事务的任何并行调度策略都是可串行化</p><p>需要说明的是，并发执行的所有事务若均遵守两段锁协议，只是这些事务的并行调度策略能可串行化的充分条件，不是必要条件。</p><p>两段锁协议与防止死锁的一次封锁法的区别：一次封锁法要求事务必须一次对所有要使用到的数据项进行加锁，否则不能继续运行。</p><p>显然，一次封锁法符合两段锁协议，但是两段锁协议并不要求一次就要对所有需要用到的数据项进行加锁，因此遵守两段锁协议的事务有可能死锁</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>&lt;<a href="https://blog.csdn.net/aaronthon/article/details/81714528" target="_blank" rel="noopener">https://blog.csdn.net/aaronthon/article/details/81714528</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/c361604199/article/details/79479398" target="_blank" rel="noopener">https://blog.csdn.net/c361604199/article/details/79479398</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/plg17/article/details/78758593" target="_blank" rel="noopener">https://blog.csdn.net/plg17/article/details/78758593</a>&gt;</p><p>&lt;<a href="https://www.cnblogs.com/luyucheng/p/6289714.html" target="_blank" rel="noopener">https://www.cnblogs.com/luyucheng/p/6289714.html</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/tongdanping/article/details/79878302" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79878302</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/yifansj/article/details/79233726" target="_blank" rel="noopener">https://blog.csdn.net/yifansj/article/details/79233726</a>&gt;</p><p>&lt;<a href="https://www.cnblogs.com/zxz1987/p/6538462.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxz1987/p/6538462.html</a>&gt;</p><p>&lt;<a href="https://coding.imooc.com/lesson/132.html#mid=6561" target="_blank" rel="noopener">https://coding.imooc.com/lesson/132.html#mid=6561</a>&gt;</p><p>&lt;<a href="https://coding.imooc.com/lesson/132.html#mid=6562" target="_blank" rel="noopener">https://coding.imooc.com/lesson/132.html#mid=6562</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/qq_23923485/article/details/73456784" target="_blank" rel="noopener">https://blog.csdn.net/qq_23923485/article/details/73456784</a>&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据库类别&quot;&gt;&lt;a href=&quot;#数据库类别&quot; class=&quot;headerlink&quot; title=&quot;数据库类别&quot;&gt;&lt;/a&gt;数据库类别&lt;/h4&gt;&lt;h5 id=&quot;关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;关
      
    
    </summary>
    
      <category term="MySQL" scheme="http://ylovex.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://ylovex.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-最小众倍数</title>
    <link href="http://ylovex.cn/2019/06/11/nowcoder-%E6%9C%80%E5%B0%8F%E4%BC%97%E5%80%8D%E6%95%B0/"/>
    <id>http://ylovex.cn/2019/06/11/nowcoder-最小众倍数/</id>
    <published>2019-06-11T04:52:39.000Z</published>
    <updated>2019-07-10T23:48:48.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/3e9d7d22b7dd4daab695b795d243315b?tpId=90&amp;tqId=30844&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/3e9d7d22b7dd4daab695b795d243315b?tpId=90&amp;tqId=30844&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>定5个正整数, 它们的最小的众倍数是指的能够被其中至少三个数整除的最小正整数。给定5个不同的正整数, 请计算输出它们的最小众倍数。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>先遍历n从1开始，再遍历nums[i]，使用map记录n*nums[i]出现的次数，当该数的次数出现三次的时候即为最小众倍数。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Now_68 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int[] nums = new int[5];</span><br><span class="line">        for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">            nums[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res = getRes(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getRes(int[] nums) &#123;</span><br><span class="line">        Map&lt;Integer , Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int n=1;n&lt;Integer.MAX_VALUE; n++)&#123;</span><br><span class="line">            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                if(map.containsKey(n*nums[i]))&#123;</span><br><span class="line">                    map.put(n*nums[i] , map.get(n*nums[i])+1);</span><br><span class="line">                    if(map.get(n*nums[i])==3)&#123;</span><br><span class="line">                        return n*nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    map.put(n*nums[i] , 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getRes2(int[] nums)&#123;</span><br><span class="line">        for(int n=1;n&lt;Integer.MAX_VALUE;n++)&#123;</span><br><span class="line">            int count=0;</span><br><span class="line">            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                if(n%nums[i]==0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(count&gt;2)&#123;</span><br><span class="line">                    return n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/3e9d7d22b7dd4da
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="遍历" scheme="http://ylovex.cn/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-括号匹配问题</title>
    <link href="http://ylovex.cn/2019/06/07/nowcoder-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://ylovex.cn/2019/06/07/nowcoder-括号匹配问题/</id>
    <published>2019-06-06T23:44:08.000Z</published>
    <updated>2019-07-10T23:47:31.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/380380e6c6b444888ae145593ccbbbca?tpId=90&amp;tqId=30840&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/380380e6c6b444888ae145593ccbbbca?tpId=90&amp;tqId=30840&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>合法的括号匹配序列被定义为:</p><ol><li>空串””是合法的括号序列</li><li>如果”X”和”Y”是合法的序列,那么”XY”也是一个合法的括号序列</li><li>如果”X”是一个合法的序列,那么”(X)”也是一个合法的括号序列</li><li>每个合法的括号序列都可以由上面的规则生成<br>例如””, “()”, “()()()”, “(()())”, “(((())))”都是合法的。 东东现在有一个合法的括号序列s,一次移除</li></ol><p>操作分为两步:</p><ol><li>移除序列s中第一个左括号</li><li>移除序列s中任意一个右括号.保证操作之后s还是一个合法的括号序列<br>东东现在想知道使用上述的移除操作有多少种方案可以把序列s变为空<br>如果两个方案中有一次移除操作移除的是不同的右括号就认为是不同的方案。<br>例如: s = “()()()()()”,输出1, 因为每次都只能选择被移除的左括号所相邻的右括号.<br>s = “(((())))”,输出24, 第一次有4种情况, 第二次有3种情况, … ,依次类推, 4 * 3 * 2 * 1 = 24</li></ol><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>反向遍历，用count记录”)“数量，用res记录结果，每次遍历到”)“则count加一，遍历到”(“则结果乘以count，表示该”(“可以匹配的”)”选择为count数，之后count减一继续遍历，遍历完序列后的res即为方案数量。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Now_64</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String input = bf.readLine();</span><br><span class="line">        <span class="keyword">int</span> len=input.length();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res*=count;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/380380e6c6b4448
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="Stack" scheme="http://ylovex.cn/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-神奇数</title>
    <link href="http://ylovex.cn/2019/06/03/nowcoder-%E7%A5%9E%E5%A5%87%E6%95%B0/"/>
    <id>http://ylovex.cn/2019/06/03/nowcoder-神奇数/</id>
    <published>2019-06-02T23:40:06.000Z</published>
    <updated>2019-07-10T23:47:00.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/56d818ae68134c12b26e81f41ecafb9e?tpId=90&amp;tqId=30841&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/56d818ae68134c12b26e81f41ecafb9e?tpId=90&amp;tqId=30841&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>/**</p><ul><li>东东在一本古籍上看到有一种神奇数,如果能够将一个数的数字分成两组,</li><li>其中一组数字的和等于另一组数字的和,我们就将这个数称为神奇数。</li><li>例如242就是一个神奇数,我们能够将这个数的数字分成两组,</li><li>分别是{2,2}以及{4},而且这两组数的和都是4.东东现在需要统计给定区间中有多少个神奇数,</li><li>即给定区间[l, r],统计这个区间中有多少个神奇数,请你来帮助他。<br>*/</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>设数字X，先求出X的每位数字存在List中，再求出X每位数字和，若为奇数则舍弃，若为偶数则判断是否是神奇数，通过动态规划，dp[i] [j]表示链表前i个数字能否求和得到j，则有dp[i] [j]=dp[i-1] [j] || dp[i-1] [j-list.get(i)];通过逆序循环将dp数组简化为一维数组。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Now_65 &#123;</span><br><span class="line">    public static void main(String[] args)throws IOException&#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String[] strings = bf.readLine().split(&quot; &quot;);</span><br><span class="line">        int left = Integer.parseInt(strings[0]);</span><br><span class="line">        int right = Integer.parseInt(strings[1]);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int num = left ; num&lt;=right ; num++)&#123;</span><br><span class="line">            if(isMagic(num))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMagic(int num) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (num&gt;0)&#123;</span><br><span class="line">            list.add(num%10);</span><br><span class="line">            sum+=num%10;</span><br><span class="line">            num/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum%2 != 0) return false;</span><br><span class="line">        int mid = sum/2;</span><br><span class="line">        int len = list.size();</span><br><span class="line">        boolean[] dp = new boolean[mid+1];</span><br><span class="line">        dp[0]=true;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            for(int j=mid;j&gt;=list.get(i);j--)&#123;</span><br><span class="line">                dp[j]=dp[j-list.get(i)] || dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/56d818ae68134c1
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="动态规划" scheme="http://ylovex.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>web工作方式</title>
    <link href="http://ylovex.cn/2019/05/28/web%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    <id>http://ylovex.cn/2019/05/28/web工作方式/</id>
    <published>2019-05-28T13:30:45.000Z</published>
    <updated>2019-07-10T23:46:21.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web工作方式："><a href="#Web工作方式：" class="headerlink" title="Web工作方式："></a>Web工作方式：</h3><p><em>from:《Go Web 编程》</em></p><p>打开浏览器，输入网址后按下回车，然后显示出浏览内容，这个看似简单的用户行为背后，隐藏的流程一般是：浏览器本身是一个客户端，当你输入 URL 的 时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过IP 地址找到 IP 对应的服务器后，要求建立 TCP 连接，等浏览器发送完 HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容随后断开与该服务器之间的 TCP 连接。</p><p>一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是web浏览器（手机端客户端内部也是浏览器实现的）。</p><p>Web 服务器的工作原理可以简单地归纳为：</p><ol><li>客户机通过 TCP/IP 协议建立到服务器的 TCP 连接 </li><li>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档 </li><li>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端 </li><li>客户机与服务器断开。由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果</li></ol><p>一个简单的 HTTP 事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的 是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。</p><h3 id="URL与DNS解析："><a href="#URL与DNS解析：" class="headerlink" title="URL与DNS解析："></a>URL与DNS解析：</h3><p>URL(Uniform Resource Locator)是“统一资源定位符”的英文缩写，用于描述一个网络上的资源, 基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schema://host[:port#]/path/.../[?query-string][#anchor]</span><br><span class="line">scheme 指定低层使用的协议(例如：http, https, ftp)</span><br><span class="line">host HTTP 服务器的 IP 地址或者域名</span><br><span class="line">port# HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，必须指</span><br><span class="line">明，例如 http://www.cnblogs.com:8080/</span><br><span class="line">path 访问资源的路径</span><br><span class="line">query-string 发送给 http 服务器的数据</span><br><span class="line">anchor 锚</span><br></pre></td></tr></table></figure><p>DNS(Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的 工作。</p><p>更详细的 DNS 解析的过程如下，这个过程有助于我们理解 DNS 的工作模式</p><ol><li>在浏览器中输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</li><li>如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li><li>如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS服务器”，“根 DNS 服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com域的这台服务器。这台负责.com 域的服务器收到请求后，如果自己无法解析，它就会找一 个管理.com 域的下一级 DNS 服务器址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 主机。</li><li>如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS 服务器，由此 DNS 服务器再返回给客户机。</li></ol><p>通过上面的步骤，我们最后获取的是 IP 地址，也就是浏览器最后发起请求的时候是基于 IP来和服务器做信息交互的。</p><h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><p>HTTP 是一种让 Web 服务器与浏览器(客户端)通过 Internet 发送与接收数据的协议,它建立在 TCP 协议之上，一般采用 TCP 的 80 端口。它是一个请求、响应协议–客户端发出一个请 求，服务器响应这个请求。在 HTTP 中，客户端总是通过建立一个连接与发送一个 HTTP 请 求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。 客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的 HTTP 连接。HTTP 协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对 HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web 程 序引入了 Cookie 机制来维护连接的可持续状态。</p><p>HTTP 协议是建立在 TCP 协议之上的，因此 TCP 攻击一样会影响 HTTP 的通讯，例如比较常见的一些攻击：SYN Flood 是当前最流行的 DoS（拒绝服务攻击）与 DdoS（分布式拒 绝服务攻击）的方式之一，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。</p><h3 id="HTTP交互方式："><a href="#HTTP交互方式：" class="headerlink" title="HTTP交互方式："></a>HTTP交互方式：</h3><p>最基本的是GET、POST、PUT、DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET、POST、PUT、DELETE就对应着这个资源的查、改、增、删四个操作。</p><p>GET一般用于获取/查询资源信息，POST一般用于更新资源信息。区别在于：</p><ol><li>GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连。POST方法是把提交数据放在HTTP包的Body中。</li><li>GET提交的数据大小有限制（因为浏览器对URL长度有限制），而POST提交数据没有限制。</li><li>GET方式提交数据，存在安全问题，比如登录页面，通过GET方式的话，用户名和密码都在URL上面，如果页面可以缓存或者其他人可以访问这台机器的，就可以从历史记录中获取账户和密码。</li></ol><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><p>状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。HTTP/1.1协议中定义了5类状态码，由三位数字组成，第一个数字定义了响应的类别。</p><ol><li>1XX：提示信息-表示请求已经被成功接收，继续处理。</li><li>2XX：成功-表示请求已经被成功接收。</li><li>3XX：重定向-要完成请求必须进行更进一步处理。</li><li>4XX：客户端错误-请求有语法错误或请求无法实现。</li><li>5XX：服务器端错误-服务器未能实现合法的请求。</li></ol><table><thead><tr><th>状态码</th><th>状态</th><th align="left">详情</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td align="left">服务器已经处理请求</td></tr><tr><td>301</td><td>永久重定向</td><td align="left">请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</td></tr><tr><td>302</td><td>临时重定向</td><td align="left">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</td></tr><tr><td>303</td><td>请求资源路径改变</td><td align="left">使用GET方法请求新url</td></tr><tr><td>400</td><td>请求错误</td><td align="left">请求的报文中存在语法错误，比如url含有非法字符</td></tr><tr><td>401</td><td>未授权</td><td align="left">未授权，比如访问SpringSecurity限制了权限的资源</td></tr><tr><td>404</td><td>未找到</td><td align="left">服务器找不到请求的网页</td></tr><tr><td>405</td><td>请求错误</td><td align="left">请求的方式（get、post、delete）方法与后台规定的方式不符合</td></tr><tr><td>415</td><td>请求错误</td><td align="left">后台程序不支持提交的content-type</td></tr><tr><td>500</td><td>服务器内部错误</td><td align="left">服务器遇到错误，无法完成请求</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Web工作方式：&quot;&gt;&lt;a href=&quot;#Web工作方式：&quot; class=&quot;headerlink&quot; title=&quot;Web工作方式：&quot;&gt;&lt;/a&gt;Web工作方式：&lt;/h3&gt;&lt;p&gt;&lt;em&gt;from:《Go Web 编程》&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，输入网址后按下
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://ylovex.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="web" scheme="http://ylovex.cn/tags/web/"/>
    
      <category term="http" scheme="http://ylovex.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://ylovex.cn/2019/05/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ylovex.cn/2019/05/25/排序算法总结/</id>
    <published>2019-05-25T12:32:28.000Z</published>
    <updated>2019-07-11T00:25:31.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a>排序算法：</h3><p>稳定：如果a在b前面 ，并且a==b，排序后a仍在b前面</p><p>不稳定：如果a在b前面，并且a==b，排序后a可能在b后面</p><p>时间复杂度：指执行当前算法所消耗的时间</p><p>空间复杂度：值执行当面算法所占用的内存空间</p><p>内排序：所有排序操作都在内存中完成</p><p>外排序：数据放在磁盘中，排序通过磁盘和内存的数据传输进行</p><p><img src="201907060823.png" alt="27060823"></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序:"></a>冒泡排序:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class bubbleS &#123;</span><br><span class="line">    public static void bubbleSort1(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        for(int i=len-1;i&gt;0;i--)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                //比较相邻两数，若前面大则交换</span><br><span class="line">                if(data[j]&gt;data[j+1])&#123;</span><br><span class="line">                    int tem = data[j];</span><br><span class="line">                    data[j]=data[j+1];</span><br><span class="line">                    data[j+1]=tem;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void bubbleSort2(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        for(int i=len-1;i&gt;0;i--)&#123;</span><br><span class="line">            //改进冒泡，如果一次比较都没有交换，则已经排好序，跳出循环</span><br><span class="line">            boolean isSort = true;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                if(data[j]&gt;data[j+1])&#123;</span><br><span class="line">                    int tem = data[j];</span><br><span class="line">                    data[j]=data[j+1];</span><br><span class="line">                    data[j+1]=tem;</span><br><span class="line">                    isSort=false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isSort) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class selectS &#123;</span><br><span class="line">    public static void selectSort1(int[] data)&#123;</span><br><span class="line">        for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">            //记录每次循环中最小数的下标然后和data[i]交换</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            for(int j=i+1;j&lt;data.length;j++)&#123;</span><br><span class="line">                minIndex = data[j]&lt;data[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            int tem = data[i];</span><br><span class="line">            data[i]=data[minIndex];</span><br><span class="line">            data[minIndex]=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class insertS &#123;</span><br><span class="line">    public static void insertSort1(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        for(int i=1;i&lt;len;i++)&#123;//默认第一个数已排好序，从第二个数开始扫描</span><br><span class="line">            int tem = data[i];</span><br><span class="line">            int j = i-1;//将data[i]与前一位data[i-1]比较</span><br><span class="line">            while (j&gt;=0 &amp;&amp; tem&lt;data[j])&#123;//若小于，将前面的数往后移</span><br><span class="line">                data[j+1]=data[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j+1]=tem;//找到位置后插入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class shellS &#123;</span><br><span class="line">    public static void shellSort1(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        int gap = len/2;</span><br><span class="line">        while (gap&gt;0)&#123;</span><br><span class="line">            for(int i=gap;i&lt;len;i++)&#123;</span><br><span class="line">                int tem = data[i];</span><br><span class="line">                int preIndex = i-gap;</span><br><span class="line">                while (preIndex &gt;= 0 &amp;&amp; data[preIndex]&gt;tem)&#123;</span><br><span class="line">                    data[preIndex+gap]=data[preIndex];</span><br><span class="line">                    preIndex-=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                data[preIndex+gap]=tem;</span><br><span class="line">            &#125;</span><br><span class="line">            gap/=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class mergeS &#123;</span><br><span class="line">    public static void mergeSort1(int[] data)&#123;</span><br><span class="line">        if(data==null || data.length==0) return;</span><br><span class="line">        mergeRec(data , 0 , data.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void mergeRec(int[] data , int left , int right)&#123;</span><br><span class="line">        if(left&gt;=right) return;</span><br><span class="line">        int mid = left + (right-left)/2;</span><br><span class="line">        mergeRec(data , left , mid);</span><br><span class="line">        mergeRec(data , mid+1 , right);</span><br><span class="line">        merge(data , left , mid , right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void merge(int[] data , int left , int mid , int right)&#123;</span><br><span class="line">        int[] h = new int[right-left+1];</span><br><span class="line">        int p1 = left , p2=mid+1;</span><br><span class="line">        int k = 0;</span><br><span class="line">        while (p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            h[k++]=data[p1]&lt;=data[p2] ? data[p1++] : data[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (p1&lt;=mid)&#123;</span><br><span class="line">            h[k++]=data[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (p2&lt;=right)&#123;</span><br><span class="line">            h[k++]=data[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">            data[left+i]=h[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class heapS &#123;</span><br><span class="line">    public static void heapSort1(int[] data)&#123;</span><br><span class="line">        if(data==null || data.length&lt;=1) return;</span><br><span class="line">        for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">            siftUp(data , i);//上浮建堆</span><br><span class="line">        &#125;</span><br><span class="line">        int len = data.length-1;</span><br><span class="line">        swap(data , 0 , len);</span><br><span class="line">        while (len&gt;0)&#123;</span><br><span class="line">            siftDown(data , 0 , len);</span><br><span class="line">            swap(data , 0 , --len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void siftUp(int[] data , int i)&#123;</span><br><span class="line">        while (data[i]&gt;data[(i-1)/2])&#123;</span><br><span class="line">            swap(data , i , (i-1)/2);</span><br><span class="line">            i=(i-1)/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void siftDown(int[] data , int i , int heapSize)&#123;</span><br><span class="line">        int left = 2*i+1;</span><br><span class="line">        int right = 2*i+2;</span><br><span class="line">        int maxIdx = i;</span><br><span class="line">        if(left&lt;heapSize &amp;&amp; data[left]&gt;data[maxIdx]) maxIdx=left;</span><br><span class="line">        if(right&lt;heapSize &amp;&amp; data[right]&gt;data[maxIdx]) maxIdx = right;</span><br><span class="line">        if(maxIdx != i)&#123;</span><br><span class="line">            swap(data , i , maxIdx);</span><br><span class="line">            siftDown(data , maxIdx , heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] data , int s1 , int s2)&#123;</span><br><span class="line">        int tem = data[s1];</span><br><span class="line">        data[s1]=data[s2];</span><br><span class="line">        data[s2]=tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class quickS &#123;</span><br><span class="line">    public void quickSort_1(int[] data, int start, int end) &#123;</span><br><span class="line">        if (data == null || start &lt; 0 || end &gt; data.length - 1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid Parameters&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (start == end) return;</span><br><span class="line">        int index = partition(data, start, end);</span><br><span class="line">        if (index &gt; start) &#123;</span><br><span class="line">            quickSort_1(data, start, index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; end) &#123;</span><br><span class="line">            quickSort_1(data, index + 1, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int partition(int[] data, int start, int end) &#123;</span><br><span class="line">        int index = start + (int)(Math.random() * (end - start + 1));</span><br><span class="line">        swap(data, index, end);</span><br><span class="line">        int small = start - 1;</span><br><span class="line">        for (index = start; index &lt; end; index++) &#123;</span><br><span class="line">            if (data[index] &lt; data[end]) &#123;</span><br><span class="line">                small++;</span><br><span class="line">                if (small != index) &#123;</span><br><span class="line">                    swap(data, index, small);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(data, small + 1, end);</span><br><span class="line">        return small + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] data, int i, int j)&#123;</span><br><span class="line">        int temp = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quickSort_2(int[] data, int start, int end) &#123;</span><br><span class="line">        if (data == null || start &gt;= end) return;</span><br><span class="line">        int i = start, j = end;</span><br><span class="line">        int pivotKey = data[start];</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            while (i &lt; j &amp;&amp; data[j] &gt;= pivotKey) j--;</span><br><span class="line">            if (i &lt; j) data[i++] = data[j];</span><br><span class="line">            while (i &lt; j &amp;&amp; data[i] &lt;= pivotKey) i++;</span><br><span class="line">            if (i &lt; j) data[j--] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = pivotKey;</span><br><span class="line">        quickSort_2(data, start, i - 1);</span><br><span class="line">        quickSort_2(data, i + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;排序算法：&quot;&gt;&lt;a href=&quot;#排序算法：&quot; class=&quot;headerlink&quot; title=&quot;排序算法：&quot;&gt;&lt;/a&gt;排序算法：&lt;/h3&gt;&lt;p&gt;稳定：如果a在b前面 ，并且a==b，排序后a仍在b前面&lt;/p&gt;
&lt;p&gt;不稳定：如果a在b前面，并且a==b，排序后
      
    
    </summary>
    
      <category term="数据结构" scheme="http://ylovex.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://ylovex.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://ylovex.cn/2019/05/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ylovex.cn/2019/05/10/单例模式/</id>
    <published>2019-05-10T12:31:47.000Z</published>
    <updated>2019-07-10T23:44:45.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>from 《菜鸟教程》</p><p>是属于创建型模式，提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，这个类负责创建自己的对象，同时也只有单个对象被创建，这个类提供了一个访问其唯一对象的方法，同时不需要实例化就可以直接访问。</p><ol><li>单例类只能有一个实例</li><li>单例类必须自己创建自己的唯一实例</li><li>单例类必须给所有其他对象提供该实例</li></ol><h5 id="单例与静态类"><a href="#单例与静态类" class="headerlink" title="单例与静态类"></a>单例与静态类</h5><ol><li>单例可以继承和被继承，方法可以被重写，而静态方法不可以</li><li>静态方法中产生的对象会在执行后被释放，进而被GC清理，不会一直存在内存中</li><li>静态类会在第一次运行时候初始化，单例模式可以延迟加载</li></ol><h5 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h5><p>Lazy初始化，非多线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h5><p>Lazy初始化，多线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>非Lazy初始化，多线程，类加载时就初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()[</span><br><span class="line">        return instance;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单例模式：&quot;&gt;&lt;a href=&quot;#单例模式：&quot; class=&quot;headerlink&quot; title=&quot;单例模式：&quot;&gt;&lt;/a&gt;单例模式：&lt;/h3&gt;&lt;p&gt;from 《菜鸟教程》&lt;/p&gt;
&lt;p&gt;是属于创建型模式，提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;这种模式涉及到
      
    
    </summary>
    
      <category term="设计模式" scheme="http://ylovex.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://ylovex.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
