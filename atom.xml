<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人生如逆旅，我亦是行人</title>
  
  <subtitle>Desire is the starting point of all achievement</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ylovex.cn/"/>
  <updated>2019-07-10T23:57:56.384Z</updated>
  <id>http://ylovex.cn/</id>
  
  <author>
    <name>Yang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nowcoder-病毒传播</title>
    <link href="http://ylovex.cn/2019/07/07/nowcoder-%E7%97%85%E6%AF%92%E4%BC%A0%E6%92%AD/"/>
    <id>http://ylovex.cn/2019/07/07/nowcoder-病毒传播/</id>
    <published>2019-07-06T23:37:20.000Z</published>
    <updated>2019-07-10T23:57:56.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/3b6060942397444cb0fe5846e230f6d9?tpId=90&amp;tqId=30850&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/3b6060942397444cb0fe5846e230f6d9?tpId=90&amp;tqId=30850&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出一个图G(V,E)，图上有n个点，m条边，所有的边都是无向边。</p><p>最开始，也就是第0天的时候，这n个点中有一个点v感染了病毒，之后的每一天，凡是感染病毒的点都会向它的邻居点传播病毒。经过了t天之后，得到了感染病毒的点集S。要求找出第0天感染病毒的点v。如果v有很多不同的答案，把它们都找出来。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>bfs算法，显然感染源一定是感染的点，先用ArrayLIst生成图，以每个感染的点为起点在t时间内进行广度遍历，将结果与给定的感染集合进行比较，如果一样则该点可以是感染源。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Now_74</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] infected;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt;[] graph;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, k, t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        infected = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        graph = <span class="keyword">new</span> ArrayList[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            graph[i]=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> v = sc.nextInt();</span><br><span class="line">            graph[u].add(v);</span><br><span class="line">            graph[v].add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        k = sc.nextInt();</span><br><span class="line">        t = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            infected[sc.nextInt()]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(infected[i] &amp;&amp; bfs(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==res.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(res.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(res.get(i)+<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以x为起点传播t天的结果和实际结果比较是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个点被传染需要的时间, 为0表明没有被传染</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp[x]=<span class="number">1</span>;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (! queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp[cur]&gt;t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(Integer e : graph[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[e]==<span class="number">0</span>)&#123;</span><br><span class="line">                   temp[e]=temp[cur]+<span class="number">1</span>;</span><br><span class="line">                   queue.offer(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!infected[i] &amp;&amp; temp[i]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(infected[i] &amp;&amp; temp[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/3b6060942397444
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="bfs" scheme="http://ylovex.cn/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记三</title>
    <link href="http://ylovex.cn/2019/07/05/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://ylovex.cn/2019/07/05/Redis设计与实现笔记三/</id>
    <published>2019-07-04T22:55:12.000Z</published>
    <updated>2019-07-05T22:57:39.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h3><p>又称符号表、关联数组、映射，是一种保存键值对的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a>哈希表：</h4><p>由dict.h/dictht结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">    //哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    //哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line">    //哈希表大小掩码，用于计算索引值</span><br><span class="line">    //总是等于size-1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    //该哈希表已有节点数量</span><br><span class="line">    unsigned long user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点的数量，sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放在table数组的哪个索引上面。</p><h4 id="哈希表节点："><a href="#哈希表节点：" class="headerlink" title="哈希表节点："></a>哈希表节点：</h4><p>使用dictEntry结构，每个dictEntry结构都保存一个键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    //键</span><br><span class="line">    void *key;</span><br><span class="line">    //值</span><br><span class="line">    union&#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        unt64_t s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    //指向下个哈希表节点，形成链表</span><br><span class="line">    strcut dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><p>key属性保存键，v属性保存值，可以是指针、uint64_t、uint64_t。</p><p>next属性指向另一个哈希表节点指针，解决哈希冲突。</p><p><img src="201907050731.png" alt="201907050731"></p><h4 id="字典：-1"><a href="#字典：-1" class="headerlink" title="字典："></a>字典：</h4><p>由dict.h/dict结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    //类型特定函数</span><br><span class="line">    sictType *type;</span><br><span class="line">    //私有数据</span><br><span class="line">    void *privtata;</span><br><span class="line">    //哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    //rehash索引</span><br><span class="line">    //当rehash不在进行时，值为-1</span><br><span class="line">    int trehashidx;/*rehashing not in progress if rehashidx==-1 */</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同的类型的键值对，为创建多态字典而设置的：</p><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p><p>privdata属性则保存了需要传给那些类型特定函数的可选参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType&#123;</span><br><span class="line">    //计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    //复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata,const void *key);</span><br><span class="line">    //复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata,const void *obj);</span><br><span class="line">    //对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata,const void *key1.const void *key2);</span><br><span class="line">    //销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *prevdata,void *key);</span><br><span class="line">    //销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *prevdata,void *obj);</span><br><span class="line">&#125;dictType；</span><br></pre></td></tr></table></figure><p>ht属性是一个包含两项的数组，数组的每一项都是一个dictht哈希表，一般，字典只使用ht[0]，ht[1]用于对ht[0]rehash。</p><p><img src="201907050732.png" alt="201907050732"></p><h3 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h3><p>Redis计算哈希值和索引值方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">//使用哈希值的sizemask属性和哈希值，计算索引</span><br><span class="line">//根据情况不同，ht[x]可以是hx[0]或者ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><h3 id="解决键冲突："><a href="#解决键冲突：" class="headerlink" title="解决键冲突："></a>解决键冲突：</h3><p>当有两个或者以上数量的键被分配到哈希表数组的同一个索引上面的时候，产生了冲突。</p><p>使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，从而解决键冲突。</p><p>新节点总是添加到链表的表头位置（复杂度为O(1)）</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash:"></a>rehash:</h3><p>扩展和收缩哈希表通过rehash（重新散列）完成</p><ol><li><p>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性值）</p><p>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n值</p><p>如果执行的收缩，那么ht[1]的大小是第一个大于等于ht[0].used的2^n值</p></li><li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放在ht[1]哈希表指定位置</p></li><li><p>当ht[0]包含所有键值对都迁移到ht[1]后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空白哈希表，为下一次rehash做准备。</p></li></ol><h3 id="哈希表的扩展与收缩："><a href="#哈希表的扩展与收缩：" class="headerlink" title="哈希表的扩展与收缩："></a>哈希表的扩展与收缩：</h3><p>哈希表的负载因子=哈希表已保存节点数量/哈希表大小</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1],二十分多次、渐进式地将ht[0]里面的键值对慢慢rehash。</p><p>在渐进式rehash进行期间，字典的删除、查找、更新等操作会在两个哈希表进行</p><p>渐进式rehash期间，新添加到字典的键值对一律会保存到ht[1]中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字典：&quot;&gt;&lt;a href=&quot;#字典：&quot; class=&quot;headerlink&quot; title=&quot;字典：&quot;&gt;&lt;/a&gt;字典：&lt;/h3&gt;&lt;p&gt;又称符号表、关联数组、映射，是一种保存键值对的抽象数据结构。&lt;/p&gt;
&lt;p&gt;Redis的字典使用哈希表作为底层实现，一个哈希表里面可
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记二</title>
    <link href="http://ylovex.cn/2019/07/03/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://ylovex.cn/2019/07/03/Redis设计与实现笔记二/</id>
    <published>2019-07-03T04:52:07.000Z</published>
    <updated>2019-07-04T05:33:37.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h3><h4 id="链表和链表节点的实现："><a href="#链表和链表节点的实现：" class="headerlink" title="链表和链表节点的实现："></a>链表和链表节点的实现：</h4><p>链表节点使用一个adlist.h/listNode结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">    //前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    //后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    //节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表。</p><p><img src="201907020905.png" alt="201907020905"></p><p>使用adlist.h/list来持有链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    //表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    //表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    //链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">    //节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    //节点值释放函数</span><br><span class="line">    void *(*free)(void *ptr);</span><br><span class="line">    //节点值对比函数</span><br><span class="line">    int (*match)(void *pre , void *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure><p><img src="201907020916.png" alt="201907020916"></p><p>上图是一个由list结构和三个listNode结构组成的链表。</p><h4 id="Redis链表实现特性"><a href="#Redis链表实现特性" class="headerlink" title="Redis链表实现特性:"></a>Redis链表实现特性:</h4><ol><li>双端：链表节点带有prev和next指针，获取某个节点的前置和后置复杂度都是O(1)</li><li>无环：表头节点的prev和表尾的next都指向NULL，对链表访问都以NULL为终点</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点都是O(1)</li><li>带链表长度计数器：获取链表中节点数量的复杂度为O(1)</li><li>多态：链表节点使用void* 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表：&quot;&gt;&lt;a href=&quot;#链表：&quot; class=&quot;headerlink&quot; title=&quot;链表：&quot;&gt;&lt;/a&gt;链表：&lt;/h3&gt;&lt;h4 id=&quot;链表和链表节点的实现：&quot;&gt;&lt;a href=&quot;#链表和链表节点的实现：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-骰子游戏</title>
    <link href="http://ylovex.cn/2019/07/02/nowcoder-%E9%AA%B0%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://ylovex.cn/2019/07/02/nowcoder-骰子游戏/</id>
    <published>2019-07-01T23:37:01.000Z</published>
    <updated>2019-07-10T23:57:09.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/0e83797c34e54cca91179fe9ad681bc4?tpId=90&amp;tqId=30849&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/0e83797c34e54cca91179fe9ad681bc4?tpId=90&amp;tqId=30849&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>小易参加了一个骰子游戏,这个游戏需要同时投掷n个骰子,每个骰子都是一个印有数字1~6的均匀正方体。<br>小易同时投掷出这n个骰子,如果这n个骰子向上面的数字之和大于等于x,小易就会获得游戏奖励。<br>小易想让你帮他算算他获得奖励的概率有多大。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态规划，用dp[i][j]表示i个骰子产生数字和j的结果数，</span><br><span class="line">初始值dp[1][j]=1(j=1~6),dp[i] [i]=1,dp[i][6*i]=1,</span><br><span class="line">由于第i个骰子的点数可以为1~6，要使i个骰子的数字和为j的话，</span><br><span class="line">则前i-1个骰子的数字和可以为j-1~j-6，</span><br><span class="line">所以得到公式dp[i][j] +=dp[i-1][j-k] (k=1~6)。</span><br></pre></td></tr></table></figure><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Now_73</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> x=sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=x) System.out.print(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">6</span>*n&lt;x) System.out.print(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span>[][] dp=<span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>][<span class="number">6</span>*n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++) dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="number">6</span>*n;j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;j&amp;&amp;k&lt;=<span class="number">6</span>;k++) &#123;</span><br><span class="line">                        dp[i][j]+=dp[i-<span class="number">1</span>][j-k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> total=(<span class="keyword">long</span>)Math.pow(<span class="number">6</span>,n);</span><br><span class="line">            <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;i++) sum+=dp[n][i];</span><br><span class="line">            <span class="keyword">long</span> num=gcd(total-sum,total);</span><br><span class="line">            System.out.print((total-sum)/num+<span class="string">"/"</span>+total/num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a%b==<span class="number">0</span>)?b:gcd(b,a%b);<span class="comment">//求最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/0e83797c34e54cc
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="dp" scheme="http://ylovex.cn/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记一</title>
    <link href="http://ylovex.cn/2019/07/01/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://ylovex.cn/2019/07/01/Redis设计与实现笔记一/</id>
    <published>2019-07-01T13:33:42.000Z</published>
    <updated>2019-07-04T05:33:28.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串："><a href="#简单动态字符串：" class="headerlink" title="简单动态字符串："></a>简单动态字符串：</h3><p>Redis并没有直接使用C语音传统的字符串（以空字符串结尾的字符数组），而是构建了一种名为简单动态字符串（simple dynamic string ， SDS）的抽象类型。</p><p>每个sds.h/sdshdr结构表示一个SDS值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    //记录buf数组中已使用字节的数量</span><br><span class="line">    //等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    </span><br><span class="line">    //记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    </span><br><span class="line">    //字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图展示了一个SDS示例：</p><p><img src="1561985098307.png" alt="1561985098307"></p><p>其中：</p><ol><li>free属性的值为0，表示这个SDS没有分配任何未使用的空间</li><li>len属性的值为5，表示这个SDS保存一个5字节长的字符串</li><li>buf属性是一个char类型的数组，最后以空字符‘\0’。</li></ol><p>SDS遵循C字符串以空字符结尾的惯例，保存的空字符的1字节不计算在SDS的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符末尾等操作都是SDS自动完成，对使用者完成透明，遵循空字符结尾可以重用一部分C字符串函数库里面的函数。</p><h4 id="SDS优点："><a href="#SDS优点：" class="headerlink" title="SDS优点："></a>SDS优点：</h4><h5 id="常数复杂度获取字符串的长度："><a href="#常数复杂度获取字符串的长度：" class="headerlink" title="常数复杂度获取字符串的长度："></a>常数复杂度获取字符串的长度：</h5><p>通过使用SDS而不是C字符串，Redis将获取字符串长度所需要的复杂度从O(n)降低到了O(1)。</p><h5 id="杜绝缓冲区溢出："><a href="#杜绝缓冲区溢出：" class="headerlink" title="杜绝缓冲区溢出："></a>杜绝缓冲区溢出：</h5><p>当SDS API需要对SDS进行修改时候，API会先检查SDS空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</p><h5 id="减少修改字符串时候带来的内存重分配次数："><a href="#减少修改字符串时候带来的内存重分配次数：" class="headerlink" title="减少修改字符串时候带来的内存重分配次数："></a>减少修改字符串时候带来的内存重分配次数：</h5><p>对于一个包含N个字符的C字符串，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符），因为C字符串的长度和底层数组的长度之间存在这种关联，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一个内存重分配操作：</p><ol><li>如果程序执行的是增长字符串操作，比如拼接（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小—如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的就是缩短字符串操作，比如截断（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间—如果忘了这步就会产生内存泄漏。</li></ol><p>为了避免C字符串这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度的关联，在SDS中，buf数组的长度不一定是字符数量加一，数组里面可以包含未使用的字节，而这个未使用的字节由SDS的free属性记录。</p><p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h6 id="空间预分配："><a href="#空间预分配：" class="headerlink" title="空间预分配："></a>空间预分配：</h6><p>空间预分配用于优化SDS字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间的时候，还会为SDS分配额外的未使用空间。</p><p>其中，额外分配的未使用空间数量由以下公式决定：</p><ol><li>如果对SDS进行修改之后，SDS的的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间。</li><li>如何对SDS进行修改后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。</li></ol><p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需要的内存重分配次数。</p><h6 id="惰性空间释放："><a href="#惰性空间释放：" class="headerlink" title="惰性空间释放："></a>惰性空间释放：</h6><p>惰性空间释放用于优化SDS字符串缩短操作：当SDS的API需要缩短的SDS保存的字符串时候，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等到将来使用。</p><h5 id="二进制安全："><a href="#二进制安全：" class="headerlink" title="二进制安全："></a>二进制安全：</h5><p>C字符中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使C字符只能保存文本数据，不能保存像图像、音频、视频、压缩文件这样的二进制数据。</p><p>SDS的API都是二进制安全的，所有SDS API都会处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入是什么样，被读取就是什么样。</p><h5 id="兼容部分C字符串函数："><a href="#兼容部分C字符串函数：" class="headerlink" title="兼容部分C字符串函数："></a>兼容部分C字符串函数：</h5><p>通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用&lt;string.h&gt;函数库，从而避免了不必要的代码重复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串：&quot;&gt;&lt;a href=&quot;#简单动态字符串：&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串：&quot;&gt;&lt;/a&gt;简单动态字符串：&lt;/h3&gt;&lt;p&gt;Redis并没有直接使用C语音传统的字符串（以空字符串结尾的字符数组），而是构建了一种名为简
      
    
    </summary>
    
      <category term="Redis" scheme="http://ylovex.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://ylovex.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>jvm自动内存管理机制</title>
    <link href="http://ylovex.cn/2019/06/28/jvm%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://ylovex.cn/2019/06/28/jvm自动内存管理机制/</id>
    <published>2019-06-28T00:11:47.000Z</published>
    <updated>2019-07-04T05:32:44.108Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM组成："><a href="#JVM组成：" class="headerlink" title="JVM组成："></a>JVM组成：</h3><p>JVM 由类加载器子系统、运行时数据区、执行引擎以及本地方法接口组成。</p><p><img src="201907030747.png" alt="201907030747"></p><h3 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p><h5 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h5><p>是当前线程所执行的字节码的行号指示器。字节码解释器工作时候通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都依赖该计数器。</p><p>线程私有，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域。</p><h5 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h5><p>存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>线程私有。</p><p>局部变量表存放编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令地址）。</p><p>其中64位长度的long和double类型数据占用2个局部变量空间（slot），其余数据类型只占1个字节。</p><h5 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h5><p>虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈为虚拟机使用Native方法服务。</p><h5 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h5><p>存放对象实例，是垃圾收集器管理的主要区域。</p><p>线程共享。</p><h5 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h5><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>线程共享。</p><h5 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h5><p>是方法区的一部分。具有动态性，不仅预置入Class文件中常量池的内容可以进入方法区运行时常量池，运行期间也可以将新的常量放入池中。</p><h3 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h3><ol><li>虚拟机遇到一条new指令时，会先去常量池检测能否找到new对应的类的符号引用，并检测这个类是否加载、初始化。</li><li>如果加载检查通过，则分配内存。分配内存有两种方式：⑴指针碰撞，针对连续内存区域；⑵空闲列表，针对不连续内存区域</li><li>内存分配完之后，会对内存初始化零值，保证实例字段能在java代码不赋初值也能使用。</li><li>接下来对对象信息进行设置，把类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息存放在对象头之中</li><li>最后执行用户的Init方法</li></ol><h3 id="对象的内存布局："><a href="#对象的内存布局：" class="headerlink" title="对象的内存布局："></a>对象的内存布局：</h3><ol><li>分为三部分，对象头、实例数据、对齐填充</li><li>对象头：⑴对象自身运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁等。⑵类型指针，虚拟机通过这个来确定这个对象是哪个类的实例。⑶如果对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据。</li><li>实例数据：对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。</li><li>对齐填充：JVM要求对象的起始地址必须是8字节的整数倍，因此当对象实例数据没有对齐时，这部分来补全。</li></ol><h3 id="对象的访问定位："><a href="#对象的访问定位：" class="headerlink" title="对象的访问定位："></a>对象的访问定位：</h3><h5 id="使用句柄访问："><a href="#使用句柄访问：" class="headerlink" title="使用句柄访问："></a>使用句柄访问：</h5><p>Java堆中会划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p><img src="201907030826.png" alt="201907030826"></p><h5 id="直接指针访问："><a href="#直接指针访问：" class="headerlink" title="直接指针访问："></a>直接指针访问：</h5><p>那么Java堆对象的布局中就必须考虑如何放置访问类型数据的 相关信息，而reference中存储的直接就是对象地址</p><p><img src="201907030827.png" alt="201907030827"></p><h3 id="Java垃圾回收区域："><a href="#Java垃圾回收区域：" class="headerlink" title="Java垃圾回收区域："></a>Java垃圾回收区域：</h3><ol><li>Java垃圾回收只针对堆和方法区的内存。</li><li>程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭，因此不用管。</li></ol><p><img src="201907030830.png" alt="201907030830"></p><h3 id="如何确认垃圾："><a href="#如何确认垃圾：" class="headerlink" title="如何确认垃圾："></a>如何确认垃圾：</h3><h5 id="引用计数算法："><a href="#引用计数算法：" class="headerlink" title="引用计数算法："></a>引用计数算法：</h5><p>给对象中添加一个引用计数器，每当有 一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0 的对象就是不可能再被使用的。</p><h5 id="可达性分析算法："><a href="#可达性分析算法：" class="headerlink" title="可达性分析算法："></a>可达性分析算法：</h5><p>这个算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连 （用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达 的，所以它们将会被判定为是可回收的对象。</p><p><img src="201907030836.png" alt="201907030836"></p><p>可作为GC Roots对象有：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。 </li><li>方法区中类静态属性引用的对象。 </li><li>方法区中常量引用的对象。 </li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ol><h3 id="垃圾回收算法："><a href="#垃圾回收算法：" class="headerlink" title="垃圾回收算法："></a>垃圾回收算法：</h3><h5 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h5><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有 被标记的对象。</p><p>不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h5 id="复制算法："><a href="#复制算法：" class="headerlink" title="复制算法："></a>复制算法：</h5><p>它将可用内存按容 量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是 对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指 针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p><h5 id="标记-整理算法："><a href="#标记-整理算法：" class="headerlink" title="标记-整理算法："></a>标记-整理算法：</h5><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存 活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h5 id="分代收集："><a href="#分代收集：" class="headerlink" title="分代收集："></a>分代收集：</h5><p>一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付 出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间 对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h3 id="JVM-GC："><a href="#JVM-GC：" class="headerlink" title="JVM GC："></a>JVM GC：</h3><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>要GC就得枚举根节点，如果逐一去检查引用，效率很低。因此JVM使用一组称为OopMap的数据结构，直接知道哪些地方存放着对象引用。</p><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>可能导致引用关系、或者说OopMap内容变化的指令非常多，不可能为每一条指令都生成对应的OopMap，因此有了安全点，在安全点才记录OopMap，在安全点才能进行GC，例如方法调用、循环跳转、异常跳转等，具有这些功能的指令才会产生安全点</p><h5 id="如何让GC发生时线程都跑到安全点"><a href="#如何让GC发生时线程都跑到安全点" class="headerlink" title="如何让GC发生时线程都跑到安全点"></a>如何让GC发生时线程都跑到安全点</h5><p>采用主动式中断思想，GC时，不直接对线程操作，而是设置一个中断标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的</p><h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>如果程序不执行时，比如sleep了，岂不是就进不了安全点？因此有了安全区域，安全区域指在一段代码中，引用关系不会发生变化，在这个区域内GC都是安全的。线程进入安全区域后，会标志自己进入了。JVM要GC时就不会管这些线程。线程要离开安全区域时，必须检查GC是否完成，如果GC完成了线程就继续执行，否则一直等待直到GC完成。</p><h3 id="垃圾收集器："><a href="#垃圾收集器：" class="headerlink" title="垃圾收集器："></a>垃圾收集器：</h3><p><img src="201907030914.png" alt="201907030914"></p><h5 id="Serial收集器："><a href="#Serial收集器：" class="headerlink" title="Serial收集器："></a>Serial收集器：</h5><p>单线程，GC时候需要暂停其他所有的工作线程，直到它收集结束。</p><p>JVM运行在Client模式下的默认新生代收集器：简单而高效。</p><p><img src="20190704649.png" alt="20190704649"></p><h5 id="ParNew收集器："><a href="#ParNew收集器：" class="headerlink" title="ParNew收集器："></a>ParNew收集器：</h5><p>Serial收集器的多线程版本。</p><p>许多运行在Server模式下虚拟机的首选新生代收集器。</p><p>在单CPU环境次啊ParNew不会有比Serial收集器效果更好，Serial和ParNew都是与CMS配合工作。</p><p><img src="20190704650.png" alt="20190704650"></p><h5 id="Parallel-Scavenge收集器："><a href="#Parallel-Scavenge收集器：" class="headerlink" title="Parallel Scavenge收集器："></a>Parallel Scavenge收集器：</h5><p>新生代收集器，使用复制算法。</p><p>关注吞吐量，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p><p><img src="20190704652.png" alt="20190704652"></p><h5 id="Serial-Old收集器："><a href="#Serial-Old收集器：" class="headerlink" title="Serial Old收集器："></a>Serial Old收集器：</h5><p>是Seraial收集器的老年代版本，单线程，采用“标记-整理”算法。</p><h5 id="Parallel-Old收集器："><a href="#Parallel-Old收集器：" class="headerlink" title="Parallel Old收集器："></a>Parallel Old收集器：</h5><p>是Parallel Scavenge收集器的老年代版本，“标记-整理”。</p><h5 id="CMS收集器："><a href="#CMS收集器：" class="headerlink" title="CMS收集器："></a>CMS收集器：</h5><p>是一种以获取最短回收停顿时间为目标的收集器。</p><p>基于“标记-清除”。</p><p>初始标记，并发标记，重新标记，并发清除。其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是 标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远 比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起 工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><img src="20190704653.png" alt="20190704653"></p><p>缺点：对CPU资源非常敏感、无法处理浮动垃圾、基于“标记-清除”，产生大量空间碎片。</p><h5 id="G1收集器："><a href="#G1收集器：" class="headerlink" title="G1收集器："></a>G1收集器：</h5><p>是一款面向服务端应用的垃圾收集器，、并行与并发、分代收集、空间整合、可预测停顿</p><p>将整个Java堆划分多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的。</p><p><img src="20190704654.png" alt="20190704654"></p><h3 id="内存分配与回收策略："><a href="#内存分配与回收策略：" class="headerlink" title="内存分配与回收策略："></a>内存分配与回收策略：</h3><ol><li>对象优先在Eden分配。</li><li>老年代GC（Full GC/Major GC）一般比新生代GC（Minor GC）慢10倍以上。</li><li>大对象直接进入老年代，大对象指需要大量连续内存空间的Java对象，比如很长的字符串和数组。可通过参数设置。</li><li>长期存活的对象将进入老年代。默认15岁。</li><li>动态对象年龄判定。如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</li><li>空间分配担保。当出现大量对象Minor GC后仍然存活的情况，需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM组成：&quot;&gt;&lt;a href=&quot;#JVM组成：&quot; class=&quot;headerlink&quot; title=&quot;JVM组成：&quot;&gt;&lt;/a&gt;JVM组成：&lt;/h3&gt;&lt;p&gt;JVM 由类加载器子系统、运行时数据区、执行引擎以及本地方法接口组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2
      
    
    </summary>
    
      <category term="jvm" scheme="http://ylovex.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="http://ylovex.cn/tags/java/"/>
    
      <category term="jvm" scheme="http://ylovex.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-数位重排</title>
    <link href="http://ylovex.cn/2019/06/18/nowcoder-%E6%95%B0%E4%BD%8D%E9%87%8D%E6%8E%92/"/>
    <id>http://ylovex.cn/2019/06/18/nowcoder-数位重排/</id>
    <published>2019-06-18T12:32:06.000Z</published>
    <updated>2019-07-10T23:49:12.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/f970201e9f7e4040ab25a40918e27d15?tpId=90&amp;tqId=30847&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f970201e9f7e4040ab25a40918e27d15?tpId=90&amp;tqId=30847&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>牛牛有一个正整数x,牛牛需要把数字x中的数位进行重排得到一个新数(不同于x的数),牛牛想知道这个新数是否可能是原x的倍数。请你来帮他解决这个问题。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>题目要求将x中的数位重排得到的新数是否可能是原x的倍数；只需判断x的2到9的倍数中是否存在由x重排后得到的数。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Now_71&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        boolean[] booleans = new boolean[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            booleans[i] = isCheck(sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(booleans[i])&#123;</span><br><span class="line">                System.out.println(&quot;Possible&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(&quot;Impossible&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isCheck(int num) &#123;</span><br><span class="line">        for(int i=2;i&lt;=9;i++)&#123;</span><br><span class="line">            String s1 = String.valueOf(num*i);</span><br><span class="line">            String s2 = String.valueOf(num);</span><br><span class="line">            char[] c1 = s1.toCharArray();</span><br><span class="line">            char[] c2 = s2.toCharArray();</span><br><span class="line">            if(c1.length != c2.length) continue;</span><br><span class="line">            Arrays.sort(c1);</span><br><span class="line">            Arrays.sort(c2);</span><br><span class="line">            String s3 = String.valueOf(c1);</span><br><span class="line">            String s4 = String.valueOf(c2);</span><br><span class="line">            if(s3.equals(s4))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/f970201e9f7e404
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础</title>
    <link href="http://ylovex.cn/2019/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>http://ylovex.cn/2019/06/15/数据库基础/</id>
    <published>2019-06-15T01:30:43.000Z</published>
    <updated>2019-07-10T23:49:59.136Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据库类别"><a href="#数据库类别" class="headerlink" title="数据库类别"></a>数据库类别</h4><h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。<br>包括：Mysql、Oracle、DB2、Sqlserver</p><h5 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h5><p>NoSQL是非关系型数据库的广义定义，如下小结：<br>NOSQL不是否定关系数据库，而是作为关系数据库的一个重要补充。<br>NOSQL为了高性能、高并发而生，忽略影响高性能、高并发的功能。<br>NOSQL典型产品memcached（纯内存），redis（持久化缓存），mongodb（面向文档）</p><h6 id="键值存储数据库（key-value）"><a href="#键值存储数据库（key-value）" class="headerlink" title="键值存储数据库（key-value）"></a>键值存储数据库（key-value）</h6><p> 键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据库，因为使用key主键访问，所以会获得很高的性能及扩展性。<br>键值数据库主要使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。<br>典型产品：Memcached、Redis、MemcacheDB:</p><h6 id="列存储（Column-oriented）数据库"><a href="#列存储（Column-oriented）数据库" class="headerlink" title="列存储（Column-oriented）数据库:"></a>列存储（Column-oriented）数据库:</h6><p>列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据，比如人类，我们经常会查询某个人的姓名和年龄，而不是薪资。这种情况下姓名和年龄会被放到一个列族中，薪资会被放到另一个列族中。<br>这种数据库通常用来应对分布式存储海量数据。<br>典型产品：Cassandra、HBase</p><h6 id="面向文档（Document-Oriented）数据库"><a href="#面向文档（Document-Oriented）数据库" class="headerlink" title="面向文档（Document-Oriented）数据库:"></a>面向文档（Document-Oriented）数据库:</h6><p>文档型数据库的灵感是来自于Lotus Notes办公软件，而且它同第一种键值数据库类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以 看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。<br>面向文档数据库会将数据以文档形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名词与对应值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或JSONB等多种形式存储。<br>典型产品：MongoDB、CouchDB</p><h6 id="图形数据库"><a href="#图形数据库" class="headerlink" title="图形数据库"></a>图形数据库</h6><p>图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。<br>典型产品：Neo4J、InforGrid</p><h4 id="关系型和非关系型数据库区别"><a href="#关系型和非关系型数据库区别" class="headerlink" title="关系型和非关系型数据库区别"></a>关系型和非关系型数据库区别</h4><p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。<br>优点：</p><ol><li>易于维护：都是使用表结构，格式一致；</li><li>使用方便：SQL语言通用，可用于复杂查询；</li><li>复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</li></ol><p>缺点：</p><ol><li>读写性能比较差，尤其是海量数据的高效率读写；</li><li>固定的表结构，灵活度稍欠；</li><li>不能满足高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</li></ol><p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方式的集合，可以是文档或者键值对等。</p><p>优点：</p><ol><li>格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li><li>速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；</li><li>高扩展性；</li><li>成本低：nosql数据库部署简单，基本都是开源软件。</li></ol><p>缺点：</p><ol><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理； </li><li>数据结构相对复杂，复杂查询方面稍欠。</li></ol><h4 id="Innodb和MyIASM："><a href="#Innodb和MyIASM：" class="headerlink" title="Innodb和MyIASM："></a>Innodb和MyIASM：</h4><p>区别：</p><ol><li>MyIASM是非事务安全的，而InnoDB是事务安全的</li><li>MyIASM锁的粒度是表级的，而InnoDB支持行级锁</li><li>MyIASM不支持外键，InnoDB支持外键</li><li>MyIASM支持全文类型（FullText）索引，而InnoDB不支持全文类型索引</li><li>MyIASM保存了表的行数，InnDB没有保存表的行数</li><li>MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM</li></ol><p>应用场景：</p><ol><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM</li><li>对于一般的Web应用来说，应该选择MyIASM，效率更高，特定场景再用InnoDB</li></ol><h4 id="数据库三大范式："><a href="#数据库三大范式：" class="headerlink" title="数据库三大范式："></a>数据库三大范式：</h4><h6 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h6><p>即表中的列的具有原子性，不可再分解，即列的信息，不能分解, 只要数据库是关系型数据库(MySQL/oracle/db2 /SQL server)，就自动的满足1NF。数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。通俗理解即一个字段只存储一项信息。</p><h6 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h6><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要我们设计一个主键来实现。</p><h6 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h6><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中定义的非主键字段</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>满足ACID条件：原子性、一致性、隔离性、持久性</p><p>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成</p><p>一致性：在事务开始之前和结束后，数据库的完整性没有被破坏</p><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p><p>持久性：事务结束之后，事务的结果是持久性的，即使断电结果也能保存下来</p><p>事务处理主要方法：</p><ol><li>用BEGIN、ROLLBACK、COMMIT实现，BEGIN开始一个事务、ROLLBACK事务回滚、COMMIT事务确认</li><li>直接用SET来改变MySQL的自动提交模式，SET AUTHCOMMIT=0禁止自动提交、SET AUTHCOMMIT=1开启自动提交</li></ol><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><h5 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h5><p>读未提交就是其他事务做到一半还未提交的数值可以被读出来</p><p>脏读：事务可以读取未提交的数据</p><h5 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h5><p>读已提交就是读取其他事务提交后的数值，比如B事务修改了某数据后还没有提交的话，A事务看到的值仍然是修改之前的数值。</p><p>可避免脏读的发生</p><h5 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h5><p>可重复读就是在开始读取数据（A事务开启）时候，即使其他事务修改了数据，但A事务读到的数据不管读几次都是不变的</p><p>可避免脏读、不可重复读的发生：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了</p><p>幻读：可重复读可能产生幻读，A事务开始准备插入一条记录id=6，B事务同时开始并成功插入一条记录id=6，此时A执行插入id=6操作，结果插入失败，因为id=6记录已经存在，这就是幻读。Innodb通过多版本并发控制(MVCC)解决了幻读问题。</p><h5 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h5><p>读加共享锁，写加排他锁</p><p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式（类似于Java多线程中的锁）使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read（可重复读）。</p><h4 id="事务回滚机制"><a href="#事务回滚机制" class="headerlink" title="事务回滚机制"></a>事务回滚机制</h4><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p><p>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p><p>锁分类：</p><ol><li>按操作划分：DML锁，DDL锁</li><li>按锁的粒度划分：表级锁、行级锁、页级锁</li><li>按锁级别划分：共享锁、排他锁</li><li>按加锁方式划分：自动锁、显示锁</li><li>按使用方式划分：乐观锁、悲观锁</li></ol><p>悲观锁：顾名思义，就是很悲观，每次去拿（取）数据的时候都认为别人会修改，所以每次在拿（取）数据的时候都会上锁，这样别人想拿这个数据就会block（阻塞）直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>悲观锁优缺点：悲观并发控制(悲观锁)采用”先取锁再分”的保守策略，为数据处理提供了安全的保证。但在效率方面，加锁机制会产生额外的开销，增加产生死锁的机会。</p><p>乐观锁：乐观锁的机制就是CAS，版本保护就是CAS中的期望值  CAS顾名思义，就是很乐观，每次去拿（取）数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，并发量不是很高的时候可以用，并发量高时，比如抢票，数据就存在Redis这类内存中了，就不存mysql了，mysql太慢了。</p><p>乐观锁优缺点：乐观锁认为事务直接竞争的概率是很小的，在提交的时候才锁定，所以不会产生死锁。但是如果两个事务同时写入数据库的某一行，这时，就会发现乐观锁的弊端。</p><p>行级锁：行级锁分为共享锁和排它锁。行级锁是Mysql中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，只有在通过索引条件检索数据的时候，才使用行级锁，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突概率最低，并发度最高</p><p>表级锁：表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大、发生锁冲突最高，并发度最低</p><p>页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>排它锁(exclusive locck)：排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。</p><p>共享锁(share lock)：共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。获准共享锁的事务只能读数据，不能写数据。</p><p>InnoDB：支持行级锁和表级锁，默认是行级锁</p><p>MyISAM &amp;Memory：这两个存储引擎都是采用表级锁</p><p>锁优化：</p><ol><li>读写分离</li><li>分段加锁</li><li>减少锁持有的时间</li><li>多个线程尽量以相同的顺序去获取资源</li></ol><h4 id="Innodb多版本并发控制（MVCC）"><a href="#Innodb多版本并发控制（MVCC）" class="headerlink" title="Innodb多版本并发控制（MVCC）"></a>Innodb多版本并发控制（MVCC）</h4><p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制所有不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p> InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，（存储的并不是实际的时间值，而是系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。 </p><h4 id="MYSQL索引类型"><a href="#MYSQL索引类型" class="headerlink" title="MYSQL索引类型"></a>MYSQL索引类型</h4><p>MySQL目前主要有以下几种索引类型：普通索引、唯一索引、主键索引、组合索引、全文索引。</p><ol><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有null）</li><li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li><li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>全文索引：对文本的内容进行分词，进行搜索</li></ol><p>普通索引-是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">直接创建索引</span><br><span class="line">CREATE INDEX index_name ON table(column(length))</span><br><span class="line">修改表结构的方式添加索引</span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br><span class="line">创建表的时候同时创建索引</span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br><span class="line">删除索引</span><br><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure><p>唯一索引-与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建唯一索引</span><br><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line">修改表结构</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br><span class="line">创建表的时候直接指定</span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    UNIQUE indexName (title(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>主键索引-是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>组合索引-指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure><p>全文索引-主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建表的适合添加全文索引</span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">);</span><br><span class="line">修改表结构添加全文索引</span><br><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br><span class="line">直接创建索引</span><br><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure><h4 id="索引的作用和优缺点"><a href="#索引的作用和优缺点" class="headerlink" title="索引的作用和优缺点"></a>索引的作用和优缺点</h4><p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入（插入、删除、更新表）的速度，同时也增加了数据库的尺寸大小。</p><p>优点：</p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><p>缺点：</p><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占物理空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。</li><li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ol><p>不建议使用索引情况：</p><ol><li>数据唯一性差的字段不要使用索引：比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。</li><li>频繁更新的字段不要使用索引：比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。</li><li>字段不在where语句出现时不要添加索引：只有在where语句出现，mysql才会去使用索引</li><li>数据量少的表不要使用索引：使用了改善也不大</li><li>另外，如果mysql估计使用全表扫描要比使用索引快，则不会使用索引。</li></ol><h4 id="索引、主键索引、唯一索引、组合索引"><a href="#索引、主键索引、唯一索引、组合索引" class="headerlink" title="索引、主键索引、唯一索引、组合索引"></a>索引、主键索引、唯一索引、组合索引</h4><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。</p><p>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。</p><p>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，不允许有空值，使用关键字 PRIMARY KEY 来创建。</p><p>索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是组合索引。</p><p>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</p><h4 id="主键、外键、唯一索引"><a href="#主键、外键、唯一索引" class="headerlink" title="主键、外键、唯一索引"></a>主键、外键、唯一索引</h4><p>定义：</p><ol><li>主键–唯一标识一条记录，不能有重复的，不允许为空</li><li>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值</li><li>唯一索引–该字段没有重复值，但可以有一个空值</li></ol><p>作用：</p><ol><li>主键–用来保证数据完整性</li><li>外键–用来和其他表建立联系用的</li><li>唯一索引–是提高查询排序的速度</li></ol><p>个数：</p><ol><li>主键–主键只能有一个</li><li>外键–一个表可以有多个外键</li><li>唯一索引–一个表可以有多个唯一索引</li></ol><h4 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h4><p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建表的时候添加FULLTEXT索引</span><br><span class="line">CTREATE TABLE my_table(</span><br><span class="line">id INT(10) PRIMARY KEY,</span><br><span class="line">name VARCHAR(10) NOT NULL,</span><br><span class="line">my_text text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,</span><br><span class="line">FULLTEXT(my_text));</span><br><span class="line">//创建表以后，在需要的时候添加FULLTEXT索引</span><br><span class="line">ALTER my_table ADD FULLTEXT ft_index(my_text);</span><br><span class="line">CREATE INDEX ft_index ON my_table(my_text);</span><br></pre></td></tr></table></figure><p>对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。</p><p>MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。</p><p>在MySQL中，全文索引支队英文有用，目前对中文还不支持。</p><p>在MySQL中，如果检索的字符串太短则无法检索得到预期的结果，检索的字符串长度至少为4字节，此外，如果检索的字符包括停止词，那么停止词会被忽略。</p><h5 id="BTree索引和B-Tree索引"><a href="#BTree索引和B-Tree索引" class="headerlink" title="BTree索引和B+Tree索引"></a>BTree索引和B+Tree索引</h5><h6 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h6><p>BTree是平衡搜索多叉树，设树的度为d（d&gt;1），高度为h，那么BTree要满足以一下条件：</p><ol><li>每个叶子结点的高度一样，等于h；</li><li>每个非叶子结点由n-1个key和n个指针point组成，其中d&lt;=n&lt;=2d,key和point相互间隔，结点两端一定是key；</li><li>叶子结点指针都为null；</li><li>非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；</li></ol><p><img src="201907070713.png" alt="201907070713"></p><p>在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。</p><h6 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h6><p>B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：</p><ol><li>B+Tree中的非叶子结点不存储数据，只存储键值；</li><li>B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应的数据的物理地址；</li></ol><p><img src="201907070714.png" alt="201907070714"></p><p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的一个扇区是整数倍的page（页），页是存储中的一个单位，通常默认为4K，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data域，就可以存储更多的key。带顺序索引的B+TREE。很多存储引擎在B+Tree的基础上进行了优化，添加了指向相邻叶节点的指针，形成了带有顺序访问指针的B+Tree，这样做是为了提高区间查找的效率，只要找到第一个值那么就可以顺序的查找后面的值。</p><h4 id="SQL常见语句"><a href="#SQL常见语句" class="headerlink" title="SQL常见语句"></a>SQL常见语句</h4><p>数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的数据库</span><br><span class="line">SHOW DATABASES ;</span><br><span class="line"># 创建一个数据库</span><br><span class="line">CREATE DATABASE name;</span><br><span class="line"># 删除一个数据库</span><br><span class="line">DROP DATABASE name;</span><br><span class="line"># 使用这个数据库</span><br><span class="line">USE name;</span><br></pre></td></tr></table></figure><p>表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的表</span><br><span class="line">SHOW TABLES ;</span><br><span class="line"># 创建一个表</span><br><span class="line">CREATE TABLE n(id INT, name VARCHAR(10));</span><br><span class="line">CREATE TABLE m(id INT, name VARCHAR(10), PRIMARY KEY (id), FOREIGN KEY (id) REFERENCES n(id), UNIQUE (name));</span><br><span class="line">CREATE TABLE m(id INT, name VARCHAR(10));</span><br><span class="line"># 直接将查询结果导入或复制到新创建的表</span><br><span class="line">CREATE TABLE n SELECT * FROM m;</span><br><span class="line"># 新创建的表与一个存在的表的数据结构类似</span><br><span class="line">CREATE TABLE m LIKE n;</span><br><span class="line"># 创建一个临时表</span><br><span class="line"># 临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</span><br><span class="line">CREATE TEMPORARY TABLE l(id INT, name VARCHAR(10));</span><br><span class="line"># 直接将查询结果导入或复制到新创建的临时表</span><br><span class="line">CREATE TEMPORARY TABLE tt SELECT * FROM n;</span><br><span class="line"># 删除一个存在表</span><br><span class="line">DROP TABLE IF EXISTS m;</span><br><span class="line"># 更改存在表的名称</span><br><span class="line">ALTER TABLE n RENAME m;</span><br><span class="line">RENAME TABLE n TO m;</span><br><span class="line"># 查看表的结构(以下五条语句效果相同）</span><br><span class="line">DESC n;   # 因为简单，所以建议使用（DESC表示descend降序，ASC表示ascend升序）</span><br><span class="line">DESCRIBE n;       #（discribe）</span><br><span class="line">SHOW COLUMNS IN n;</span><br><span class="line">SHOW COLUMNS FROM n;</span><br><span class="line">EXPLAIN n;</span><br><span class="line"># 查看表的创建语句</span><br><span class="line">SHOW CREATE TABLE n;</span><br></pre></td></tr></table></figure><p>表的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加字段</span><br><span class="line">ALTER TABLE n ADD age VARCHAR(2) ;</span><br><span class="line"># 删除字段</span><br><span class="line">ALTER TABLE n DROP age;</span><br><span class="line"># 更改字段属性和属性</span><br><span class="line">ALTER TABLE n CHANGE age a INT;</span><br><span class="line"># 只更改字段属性</span><br><span class="line">ALTER TABLE n MODIFY age VARCHAR(7) ;</span><br></pre></td></tr></table></figure><p>表的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 增加数据</span><br><span class="line">INSERT INTO n VALUES (1, &apos;tom&apos;, &apos;23&apos;), (2, &apos;john&apos;, &apos;22&apos;);</span><br><span class="line">INSERT INTO n SELECT * FROM n;  # 把数据复制一遍重新插入</span><br><span class="line"># 删除数据</span><br><span class="line">DELETE FROM n WHERE id = 2;</span><br><span class="line"># 更改数据</span><br><span class="line">UPDATE n SET name = &apos;tom&apos; WHERE id = 2;</span><br><span class="line"># 数据查找</span><br><span class="line">SELECT * FROM n WHERE name LIKE &apos;%h%&apos;;</span><br><span class="line"># 数据排序(反序)</span><br><span class="line">SELECT * FROM n ORDER BY name, id DESC ;</span><br></pre></td></tr></table></figure><p>键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 添加主键</span><br><span class="line">ALTER TABLE n ADD PRIMARY KEY (id);</span><br><span class="line">ALTER TABLE n ADD CONSTRAINT pk_n PRIMARY KEY (id);   # 主键只有一个，所以定义键名似乎也没有什么用</span><br><span class="line"># 删除主键</span><br><span class="line">ALTER TABLE n DROP PRIMARY KEY ;</span><br><span class="line"># 添加外键</span><br><span class="line">ALTER TABLE m ADD FOREIGN KEY (id) REFERENCES n(id);    # 自动生成键名m_ibfk_1</span><br><span class="line">ALTER TABLE m ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES n(id);   # 使用定义的键名fk_id</span><br><span class="line"># 删除外键</span><br><span class="line">ALTER TABLE m DROP FOREIGN KEY `fk_id`;</span><br><span class="line"># 修改外键</span><br><span class="line">ALTER TABLE m DROP FOREIGN KEY `fk_id`, ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES n(id);    # 删除之后从新建</span><br><span class="line"># 添加唯一键</span><br><span class="line">ALTER TABLE n ADD UNIQUE (name);</span><br><span class="line">ALTER TABLE n ADD UNIQUE u_name (name);</span><br><span class="line">ALTER TABLE n ADD UNIQUE INDEX u_name (name);</span><br><span class="line">ALTER TABLE n ADD CONSTRAINT u_name UNIQUE (name);</span><br><span class="line">CREATE UNIQUE INDEX u_name ON n(name);</span><br><span class="line"># 添加索引</span><br><span class="line">ALTER TABLE n ADD INDEX (age);</span><br><span class="line">ALTER TABLE n ADD INDEX i_age (age);</span><br><span class="line">CREATE INDEX i_age ON n(age);</span><br><span class="line"># 删除索引或唯一键</span><br><span class="line">DROP INDEX u_name ON n;</span><br><span class="line">DROP INDEX i_age ON n;</span><br></pre></td></tr></table></figure><p>视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">CREATE VIEW v AS SELECT id, name FROM n;</span><br><span class="line">CREATE VIEW v(id, name) AS SELECT id, name FROM n;</span><br><span class="line"># 查看视图(与表操作类似)</span><br><span class="line">SELECT * FROM v;</span><br><span class="line">DESC v;</span><br><span class="line"># 查看创建视图语句</span><br><span class="line">SHOW CREATE VIEW v;</span><br><span class="line"># 更改视图</span><br><span class="line">CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</span><br><span class="line">ALTER VIEW v AS SELECT name FROM n ;</span><br><span class="line"># 删除视图</span><br><span class="line">DROP VIEW IF EXISTS v;</span><br></pre></td></tr></table></figure><p>链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 内联接</span><br><span class="line">SELECT * FROM m INNER JOIN n ON m.id = n.id;</span><br><span class="line"># 左外联接</span><br><span class="line">SELECT * FROM m LEFT JOIN n ON m.id = n.id;</span><br><span class="line"># 右外联接</span><br><span class="line">SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</span><br><span class="line"># 交叉联接</span><br><span class="line">SELECT * FROM m CROSS JOIN n;   # 标准写法</span><br><span class="line">SELECT * FROM m, n;</span><br><span class="line"># 类似全连接full join的联接用法</span><br><span class="line">SELECT id,name FROM m</span><br><span class="line">UNION</span><br><span class="line">SELECT id,name FROM n;</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># 聚合函数</span><br><span class="line">SELECT count(id) AS total FROM n;   # 总数</span><br><span class="line">SELECT sum(age) AS all_age FROM n;   # 总和</span><br><span class="line">SELECT avg(age) AS all_age FROM n;   # 平均值</span><br><span class="line">SELECT max(age) AS all_age FROM n;   # 最大值</span><br><span class="line">SELECT min(age) AS all_age FROM n;   # 最小值</span><br><span class="line"># 数学函数</span><br><span class="line">SELECT abs(-5);   # 绝对值</span><br><span class="line">SELECT bin(15), oct(15), hex(15);   # 二进制，八进制，十六进制</span><br><span class="line">SELECT pi();   # 圆周率3.141593</span><br><span class="line">SELECT ceil(5.5);   # 大于x的最小整数值6</span><br><span class="line">SELECT floor(5.5);   # 小于x的最大整数值5</span><br><span class="line">SELECT greatest(3,1,4,1,5,9,2,6);   # 返回集合中最大的值9</span><br><span class="line">SELECT least(3,1,4,1,5,9,2,6);    # 返回集合中最小的值1</span><br><span class="line">SELECT mod(5,3);    # 余数2</span><br><span class="line">SELECT rand();    # 返回０到１内的随机值，每次不一样</span><br><span class="line">SELECT rand(5);   # 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</span><br><span class="line">SELECT round(1415.1415);   # 四舍五入1415</span><br><span class="line">SELECT round(1415.1415, 3);   # 四舍五入三位数1415.142</span><br><span class="line">SELECT round(1415.1415, -1);    # 四舍五入整数位数1420</span><br><span class="line">SELECT truncate(1415.1415, 3);    # 截短为3位小数1415.141</span><br><span class="line">SELECT truncate(1415.1415, -1);   # 截短为-1位小数1410</span><br><span class="line">SELECT sign(-5);    # 符号的值负数-1</span><br><span class="line">SELECT sign(5);    # 符号的值正数1</span><br><span class="line">SELECT sqrt(9);   # 平方根3</span><br><span class="line">SELECT sqrt(9);   # 平方根3</span><br><span class="line"># 字符串函数</span><br><span class="line">SELECT concat(&apos;a&apos;, &apos;p&apos;, &apos;p&apos;, &apos;le&apos;);   # 连接字符串-apple</span><br><span class="line">SELECT concat_ws(&apos;,&apos;, &apos;a&apos;, &apos;p&apos;, &apos;p&apos;, &apos;le&apos;);   # 连接用&apos;,&apos;分割字符串-a,p,p,le</span><br><span class="line">SELECT insert(&apos;chinese&apos;, 3, 2, &apos;IN&apos;);    # 将字符串&apos;chinese&apos;从3位置开始的2个字符替换为&apos;IN&apos;-chINese</span><br><span class="line">SELECT left(&apos;chinese&apos;, 4);   # 返回字符串&apos;chinese&apos;左边的4个字符-chin</span><br><span class="line">SELECT right(&apos;chinese&apos;, 3);   # 返回字符串&apos;chinese&apos;右边的3个字符-ese</span><br><span class="line">SELECT substring(&apos;chinese&apos;, 3);   # 返回字符串&apos;chinese&apos;第三个字符之后的子字符串-inese</span><br><span class="line">SELECT substring(&apos;chinese&apos;, -3);   # 返回字符串&apos;chinese&apos;倒数第三个字符之后的子字符串-ese</span><br><span class="line">SELECT substring(&apos;chinese&apos;, 3, 2);   # 返回字符串&apos;chinese&apos;第三个字符之后的两个字符-in</span><br><span class="line">SELECT trim(&apos; chinese &apos;);    # 切割字符串&apos; chinese &apos;两边的空字符-&apos;chinese&apos;</span><br><span class="line">SELECT ltrim(&apos; chinese &apos;);    # 切割字符串&apos; chinese &apos;两边的空字符-&apos;chinese &apos;</span><br><span class="line">SELECT rtrim(&apos; chinese &apos;);    # 切割字符串&apos; chinese &apos;两边的空字符-&apos; chinese&apos;</span><br><span class="line">SELECT repeat(&apos;boy&apos;, 3);    # 重复字符&apos;boy&apos;三次-&apos;boyboyboy&apos;</span><br><span class="line">SELECT reverse(&apos;chinese&apos;);    # 反向排序-&apos;esenihc&apos;</span><br><span class="line">SELECT length(&apos;chinese&apos;);   # 返回字符串的长度-7</span><br><span class="line">SELECT upper(&apos;chINese&apos;), lower(&apos;chINese&apos;);    # 大写小写 CHINESE    chinese</span><br><span class="line">SELECT ucase(&apos;chINese&apos;), lcase(&apos;chINese&apos;);    # 大写小写 CHINESE    chinese</span><br><span class="line">SELECT position(&apos;i&apos; IN &apos;chinese&apos;);    # 返回&apos;i&apos;在&apos;chinese&apos;的第一个位置-3</span><br><span class="line">SELECT position(&apos;e&apos; IN &apos;chinese&apos;);    # 返回&apos;i&apos;在&apos;chinese&apos;的第一个位置-5</span><br><span class="line">SELECT strcmp(&apos;abc&apos;, &apos;abd&apos;);    # 比较字符串，第一个参数小于第二个返回负数- -1</span><br><span class="line">SELECT strcmp(&apos;abc&apos;, &apos;abb&apos;);    # 比较字符串，第一个参数大于第二个返回正数- 1</span><br><span class="line"># 时间函数</span><br><span class="line">SELECT current_date, current_time, now();    # 2018-01-13   12:33:43    2018-01-13 12:33:43</span><br><span class="line">SELECT hour(current_time), minute(current_time), second(current_time);    # 12  31   34</span><br><span class="line">SELECT year(current_date), month(current_date), week(current_date);   # 2018    1   1</span><br><span class="line">SELECT quarter(current_date);   # 1</span><br><span class="line">SELECT monthname(current_date), dayname(current_date);   # January  Saturday</span><br><span class="line">SELECT dayofweek(current_date), dayofmonth(current_date), dayofyear(current_date);    # 7   13  13</span><br><span class="line"># 控制流函数</span><br><span class="line">SELECT if(3&gt;2, &apos;t&apos;, &apos;f&apos;), if(3&lt;2, &apos;t&apos;, &apos;f&apos;);    # t f</span><br><span class="line">SELECT ifnull(NULL, &apos;t&apos;), ifnull(2, &apos;t&apos;);    # t 2</span><br><span class="line">SELECT isnull(1), isnull(1/0);    # 0 1 是null返回1，不是null返回0</span><br><span class="line">SELECT nullif(&apos;a&apos;, &apos;a&apos;), nullif(&apos;a&apos;, &apos;b&apos;);    # null a 参数相同或成立返回null，不同或不成立则返回第一个参数</span><br><span class="line">SELECT CASE 2</span><br><span class="line">       WHEN 1 THEN &apos;first&apos;</span><br><span class="line">       WHEN 2 THEN &apos;second&apos;</span><br><span class="line">       WHEN 3 THEN &apos;third&apos;</span><br><span class="line">       ELSE &apos;other&apos;</span><br><span class="line">       END ;     # second</span><br><span class="line"># 系统信息函数</span><br><span class="line">SELECT database();    # 当前数据库名-test</span><br><span class="line">SELECT connection_id();   # 当前用户id-306</span><br><span class="line">SELECT user();    # 当前用户-root@localhost</span><br><span class="line">SELECT version();   # 当前mysql版本</span><br><span class="line">SELECT found_rows();    # 返回上次查询的检索行数</span><br></pre></td></tr></table></figure><p>用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 增加用户</span><br><span class="line">CREATE USER &apos;test&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;test&apos;;</span><br><span class="line">INSERT INTO mysql.user(Host, User, Password) VALUES (&apos;localhost&apos;, &apos;test&apos;, Password(&apos;test&apos;));    # 在用户表中插入用户信息，直接操作User表不推荐</span><br><span class="line"># 删除用户</span><br><span class="line">DROP USER &apos;test&apos;@&apos;localhost&apos;;</span><br><span class="line">DELETE FROM mysql.user WHERE User=&apos;test&apos; AND Host=&apos;localhost&apos;;</span><br><span class="line">FLUSH PRIVILEGES ;</span><br><span class="line"># 更改用户密码</span><br><span class="line">SET PASSWORD FOR &apos;test&apos;@&apos;localhost&apos; = PASSWORD(&apos;test&apos;);</span><br><span class="line">UPDATE mysql.user SET Password=Password(&apos;t&apos;) WHERE User=&apos;test&apos; AND Host=&apos;localhost&apos;;</span><br><span class="line">FLUSH PRIVILEGES ;</span><br><span class="line"># 用户授权</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO test@localhost IDENTIFIED BY &apos;test&apos;;</span><br><span class="line"># 授予用&apos;test&apos;密码登陆成功的test@localhost用户操作所有数据库的所有表的所有的权限</span><br><span class="line">FLUSH PRIVILEGES ;   # 刷新系统权限表,使授予权限生效</span><br><span class="line"># 撤销用户授权</span><br><span class="line">REVOKE DELETE ON *.* FROM &apos;test&apos;@&apos;localhost&apos;;   # 取消该用户的删除权限</span><br></pre></td></tr></table></figure><p>存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 创建存储过程</span><br><span class="line">DELIMITER //    # 无参数</span><br><span class="line">CREATE PROCEDURE getDates()</span><br><span class="line">  BEGIN</span><br><span class="line">    SELECT * FROM test ;</span><br><span class="line">  END //</span><br><span class="line">CREATE PROCEDURE getDates_2(IN id INT)    # in参数</span><br><span class="line">  BEGIN</span><br><span class="line">    SELECT * FROM test WHERE a = id;</span><br><span class="line">  END //</span><br><span class="line">CREATE PROCEDURE getDates_3(OUT sum INT)    # out参数</span><br><span class="line">  BEGIN</span><br><span class="line">    SET sum = (SELECT count(*) FROM test);</span><br><span class="line">  END //</span><br><span class="line">CREATE PROCEDURE getDates_4(INOUT i INT)    # inout参数</span><br><span class="line">  BEGIN</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">  END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"># 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS getDates;</span><br><span class="line"># 修改存储过程的特性</span><br><span class="line">ALTER PROCEDURE getDates MODIFIES SQL DATA ;</span><br><span class="line"># 修改存储过程语句（删除再重建）略</span><br><span class="line"># 查看存储过程</span><br><span class="line">SHOW PROCEDURE STATUS LIKE &apos;getDates&apos;;    # 状态</span><br><span class="line">SHOW CREATE PROCEDURE getDates_3;   # 语句</span><br><span class="line"># 调用存储过程</span><br><span class="line">CALL getDates();</span><br><span class="line">CALL getDates_2(1);</span><br><span class="line">CALL getDates_3(@s);</span><br><span class="line">SELECT @s;</span><br><span class="line">SET @i = 1;</span><br><span class="line">CALL getDates_4(@i);</span><br><span class="line">SELECT @i;    # @i = 2</span><br></pre></td></tr></table></figure><h5 id="SQL语句关键字"><a href="#SQL语句关键字" class="headerlink" title="SQL语句关键字"></a>SQL语句关键字</h5><p>SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。</p><ol><li>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index</li><li>数据操纵：select ,insert,update,delete</li><li>数据控制：revoke</li><li>数据查询：select</li></ol><h5 id="DROP、TRUNCATE、DELETE"><a href="#DROP、TRUNCATE、DELETE" class="headerlink" title="DROP、TRUNCATE、DELETE"></a>DROP、TRUNCATE、DELETE</h5><ol><li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。</li><li>TRUNCATE TABLE一次性地从表中删除所有的数据，不能通过ROLLBACK回滚。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li><li>DROP是DDL，会隐式提交，所以不能回滚，不会触发触发器。</li><li>表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，DELETE操作不会减少表或索引所占用的空间。DROP语句将表所占用的空间全释放掉。</li><li>应用范围：TRUNCATE只能对TABLE使用；DELETE可以是TABLE和VIEW；DROP可以删除表和数据库。</li><li>TRUNCATE和DELETE只删除数据，DROP则删除整个表（结构和数据）。TRUNCATE与不带WHERE的DELETE：只删除数据，而不删除表的结构（定义）；DROP语句将删除表的结构，被依赖的约束（constrain)，触发器（trigger)，索引（index）也会被删除；而依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</li><li>对于外键（FOREIGN KEY）约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带where 子句的 DELETE 语句。TRUNCATE TABLE不能用于参与了索引视图的表。</li></ol><h5 id="MySQL连接方式"><a href="#MySQL连接方式" class="headerlink" title="MySQL连接方式"></a>MySQL连接方式</h5><h6 id="内链接：（相交部分"><a href="#内链接：（相交部分" class="headerlink" title="内链接：（相交部分)"></a>内链接：（相交部分)</h6><p>关键字：inner join on</p><p>语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;</p><p><img src="201907070720.png" alt="201907070720"></p><h6 id="左链接：（左边部分）"><a href="#左链接：（左边部分）" class="headerlink" title="左链接：（左边部分）"></a>左链接：（左边部分）</h6><p>关键字：left join on / left outer join on</p><p>语句：select * from a_table a left join b_table b on a.a_id = b.b_id;</p><p><img src="201907070721.png" alt="201907070721"></p><h6 id="右链接：（右边部分）"><a href="#右链接：（右边部分）" class="headerlink" title="右链接：（右边部分）"></a>右链接：（右边部分）</h6><p>关键字：right join on/right outer join on</p><p>语句：select * from a_table a right outer join b_table b on a.a_id = b.b_id;</p><p><img src="201907070722.png" alt="201907070722"></p><h6 id="全链接：目前MySQL不支持"><a href="#全链接：目前MySQL不支持" class="headerlink" title="全链接：目前MySQL不支持"></a>全链接：目前MySQL不支持</h6><h4 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h4><ol><li>客户端先发送一条查询给服务器；</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回给存储在缓存中的结果，否则进入下一个阶段；</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回客户端。</li></ol><h4 id="数据库高并发解决方法总结"><a href="#数据库高并发解决方法总结" class="headerlink" title="数据库高并发解决方法总结"></a>数据库高并发解决方法总结</h4><p>一个项目刚开始的时候是为了实现基本功能，随着版本和功能的迭代，大数据和高并发成了软件设计必须考虑的问题！本质很简单，一个是慢，一个是等。两者是相互关联的，因为慢，所以要等，因为等，所以慢，解决了慢，也就解决了等，解决了等，也就解决了慢。<br>关键是如何解决慢和等，核心一个是短，一个是少，一个是分流，最后一种是集群/横向扩张/读写分离/建立主从。</p><p>短是指路径要短：<br>典型的mvc结构是请求-&gt;controller-&gt;model-&gt;dao-&gt;view，然后把页面返回给用户。要想短的话，</p><ol><li>页面静态化-用户可以直接获取页面，不用走那么多流程，比较适用于页面不频繁更新。</li><li>使用缓存-第一次获取数据从数据库准提取，然后保存在缓存中，以后就可以直接从缓存提取数据。不过需要有机制维持缓存和数据库的一致性。</li><li>使用储存过程-那些处理一次请求需要多次访问数据库的操作，可以把操作整合到储存过程，这样只要一次数据库访问就可以了。</li><li>批量读取-高并发情况下，可以把多个请求的查询合并到一次进行，以减少数据库的访问次数</li><li>延迟修改-高并发情况下，可以把多次修改请求，先保存在缓存中，然后定时将缓存中的数据保存到数据库中，风险是可能会断电丢失缓存中的数据，</li><li>使用索引-索引可以看作是特殊的缓存，尽量使用索引就要求where字句中精确的给出索引列的值。</li></ol><p>少是指查询的数据要少</p><ol><li>分表-把本来同一张表的内容，可以按照地区，类别等分成多张表，很简单的一个思路，但是要尽量避免分出来的多表关联查询。</li><li>分离活跃数据-例如登录用户业务，注册用户很多，但是活跃的登录用户很少，可以把活跃用户专门保存一张表，查询是先查询活跃表，没有的话再查总表，这也类似与缓存啦。</li><li>分块-数据库层面的优化，对程序是透明的，查询大数据只用找到相应块就行。</li></ol><p>分流三种:</p><ol><li>集群-将并发请求分配到不同的服务器上，可以是业务服务器，也可以是数据库服务器。</li><li>分布式-分布式是把单次请求的多项业务逻辑分配到多个服务器上，这样可以同步处理很多逻辑，一般使用与特别复杂的业务请求。</li><li>CDN -在域名解析层面的分流，例如将华南地区的用户请求分配到华南的服务器，华中地区的用户请求分配到华中的服务器。</li></ol><h4 id="高并发数据库系统"><a href="#高并发数据库系统" class="headerlink" title="高并发数据库系统"></a>高并发数据库系统</h4><ol><li>数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化</li><li>使用缓存，尽量减少据库 IO</li><li>分布式数据库、分布式缓存</li><li>服务器的负载均衡</li></ol><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h6 id="选择正确的存储引擎"><a href="#选择正确的存储引擎" class="headerlink" title="选择正确的存储引擎"></a>选择正确的存储引擎</h6><p>以 MySQL为例，包括有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。</p><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><h6 id="优化字段的数据类型"><a href="#优化字段的数据类型" class="headerlink" title="优化字段的数据类型"></a>优化字段的数据类型</h6><p>记住一个原则，越小的列会越快。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间。</p><h6 id="为常用的搜索字段添加索引"><a href="#为常用的搜索字段添加索引" class="headerlink" title="为常用的搜索字段添加索引"></a>为常用的搜索字段添加索引</h6><p>索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么最好是为其建立索引，除非你要搜索的字段是大的文本字段，那应该建立全文索引。</p><h6 id="避免使用Select"><a href="#避免使用Select" class="headerlink" title="避免使用Select *"></a>避免使用Select *</h6><p>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。即使你要查询数据表的所有字段，也尽量不要用*通配符，善用内置提供的字段排除定义也许能给带来更多的便利。</p><h6 id="使用-ENUM-而不是-VARCHAR"><a href="#使用-ENUM-而不是-VARCHAR" class="headerlink" title="使用 ENUM 而不是 VARCHAR"></a>使用 ENUM 而不是 VARCHAR</h6><p>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。例如，性别、民族、部门和状态之类的这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p><h6 id="尽可能的使用-NOT-NULL"><a href="#尽可能的使用-NOT-NULL" class="headerlink" title="尽可能的使用 NOT NULL"></a>尽可能的使用 NOT NULL</h6><p>除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。 NULL其实需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。+</p><h6 id="固定长度的表会更快"><a href="#固定长度的表会更快" class="headerlink" title="固定长度的表会更快"></a>固定长度的表会更快</h6><p>如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</p><p>固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p><p>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p><h4 id="SQL语句优化方法"><a href="#SQL语句优化方法" class="headerlink" title="SQL语句优化方法"></a>SQL语句优化方法</h4><ol><li>where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在where子句的末尾.HAVING最后。</li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</li><li>避免在索引列上使用计算</li><li>避免在索引列上使用IS NULL和IS NOT NULL</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li></ol><h4 id="实践中优化MySQL"><a href="#实践中优化MySQL" class="headerlink" title="实践中优化MySQL"></a>实践中优化MySQL</h4><p>从效果上第一条影响最大，后面越来越小。</p><ol><li>SQL语句及索引的优化</li><li>数据库表结构的优化</li><li>系统配置的优化</li><li>硬件的优化</li></ol><h4 id="优化数据库方法"><a href="#优化数据库方法" class="headerlink" title="优化数据库方法"></a>优化数据库方法</h4><ol><li>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM</li><li>使用连接(JOIN)来代替子查询</li><li>适用联合(UNION)来代替手动创建的临时表</li><li>事务处理</li><li>锁定表、优化事务处理</li><li>适用外键，优化锁定表</li><li>建立索引</li><li>优化查询语句</li></ol><h4 id="NULL含义"><a href="#NULL含义" class="headerlink" title="NULL含义"></a>NULL含义</h4><p>NULL这个值表示UNKNOWN(未知)，它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。</p><p>使用IS  NULL来进行NULL判断</p><h4 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h4><p>char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：  </p><p>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足。（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．  </p><p>varchar的适用场景:</p><ol><li>字符串列得最大长度比平均长度大很多。</li><li>字符串很少被更新，容易产生存储碎片 </li><li>使用多字节字符集存储字符串</li></ol><p>char的适用场景:</p><ol><li>存储具有近似得长度（md5值,身份证，手机号）,长度比较短小得字符串（因为varchar需要额外空间记录字符串长度），更适合经常更新得字符串，更新时不会出现页分裂得情况，避免出现存储碎片，获得更好的io性能。</li></ol><h4 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h4><h6 id="not-null：非空约束，强制列不接受空值。"><a href="#not-null：非空约束，强制列不接受空值。" class="headerlink" title="not null：非空约束，强制列不接受空值。"></a>not null：非空约束，强制列不接受空值。</h6><p>例：创建表时，name varchar(6) not null</p><h6 id="unique：唯一性约束"><a href="#unique：唯一性约束" class="headerlink" title="unique：唯一性约束"></a>unique：唯一性约束</h6><p>约束唯一标识数据库表中的每条记录 </p><p>unique和primary key都为数据提供了唯一性约束</p><p>primary key 拥有自动定义的unique约束</p><p>注意：每个表中只能有一个primary key约束，但是可以有多个Unique约束  </p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.name int unique</span><br><span class="line">2.unique(column_name)</span><br><span class="line">3.CONSTRAINT uc_PersonID UNIQUE (Id_P, LastName)：添加多个约束  </span><br><span class="line">4.alter table table_name add unique(column_name)：增加表中的约束  </span><br><span class="line">5.ALTER TABLE table_name DROP CONSTRAINT 主键名：删除约束</span><br></pre></td></tr></table></figure><h6 id="Primary-Key约束"><a href="#Primary-Key约束" class="headerlink" title="Primary Key约束"></a>Primary Key约束</h6><p>约束唯一标识数据库表中的每条记录</p><p>主键必须包含唯一的值，主键列不能为空</p><p>每个表都应该有个主键，但只能有一个主键  </p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① StudentID int not null primary key   创建学生编号为主键</span><br><span class="line">② primary key(StudentID)            创建学生编号为主键</span><br><span class="line">③ primary key(StudentID, Email)      创建学生ID和Email为联合主键</span><br><span class="line">④ alter table table_name add primary key(column_name) 为已存在的列创建主键</span><br><span class="line">⑤ alter table table_name drop primary key  删除主键约束</span><br><span class="line">⑥ alter table table_name drop constraint 主键约束名  删除主键约束</span><br></pre></td></tr></table></figure><h6 id="foreign-key约束"><a href="#foreign-key约束" class="headerlink" title="foreign key约束"></a>foreign key约束</h6><p>一个表中的foreign key指向另一个表的primary key </p><p>foreign key约束用于预防破坏表之间连接的动作</p><p>foreign key约束也能防止非法数据插入外键列，因为它必须是指向的表中的主键值</p><p> 语法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreign key (column_name) references 主表名（主键列名）创建column_name为主表名的外键  </span><br><span class="line">column_name int foreign key references 主表名（主键列名）创建column_name为主表名的外键  </span><br><span class="line">alter table table_name add foreign key (列名) references 主表名（主键列名）为已存在的列创建外键  </span><br><span class="line">alter table table_name drop foreign key 外键约束名 删除外键约束</span><br></pre></td></tr></table></figure><h6 id="check-约束"><a href="#check-约束" class="headerlink" title="check 约束"></a>check 约束</h6><p>check约束用于限制列中的值的范围</p><p>如果对个单个列做check约束，那么该列只可以输入特定数值</p><p>如果一个表定义check约束，那么此约束会在特定的列对值进行限制  </p><p>语法：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StudentID int not null check (StudentID&gt;0) 限制StudentID输入的值要大于0</span><br><span class="line">sex varchar(2) not null check(sex=&apos;男&apos; or sex=&apos;女&apos;) 限制sex的性别只能是男或者女  </span><br><span class="line">alter table table_name add check(列名&gt;0)   向已有的列加入check约束</span><br></pre></td></tr></table></figure><h6 id="default约束："><a href="#default约束：" class="headerlink" title="default约束："></a>default约束：</h6><p>用于向列中插入默认值，若没有规定其他值，那么会将默认值添加到所有的新记录中  </p><p>语法：name varchar(10) default ‘张三’  name默认插入张三的名字</p><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><p>分为以下四类：</p><ol><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ol><p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。</p><h4 id="基本表和视图"><a href="#基本表和视图" class="headerlink" title="基本表和视图"></a>基本表和视图</h4><p>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。</p><p>视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表。</p><h4 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h4><ol><li>视图能够简化用户的操作 </li><li>视图使用户能以多种角度看待同一数据；</li><li>视图为数据库提供了一定程度的逻辑独立性；</li><li>视图能够对机密数据提供安全保护。</li></ol><h4 id="MySQL运维优化"><a href="#MySQL运维优化" class="headerlink" title="MySQL运维优化"></a>MySQL运维优化</h4><ol><li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li><li>mysql库主从读写分离。</li><li>找规律分表，减少单表中的数据量提高查询速度。</li><li>添加缓存机制，比如memcached，apc等。</li><li>不经常改动的页面，生成静态页面。</li><li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</li></ol><h4 id="大流量网站，解决各页面访问量统计问题"><a href="#大流量网站，解决各页面访问量统计问题" class="headerlink" title="大流量网站，解决各页面访问量统计问题"></a>大流量网站，解决各页面访问量统计问题</h4><ol><li>确认服务器是否能支撑当前访问量。</li><li>优化数据库访问。</li><li>禁止外部访问链接（盗链）, 比如图片盗链。</li><li>控制文件下载。</li><li>使用不同主机分流。</li><li>使用浏览统计软件，了解访问量，有针对性的进行优化</li></ol><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>不用连接池的话，就要根据每个请求或者每个用户来建立连接。这样的缺点是显而易见的。</p><ol><li>这样需要建立很多连接，建立连接是要花很多时间的。</li><li>有的用户建立了连接，却没有使用，造成了资源浪费。</li></ol><p>因此需要用连接池，如下先建好5个连接（Tomcat默认的连接是10到100个，可修改），每次请求来了直接用，用完了还回去，如果请求太多，来不及处理，超时会报错（线程池请求太多会排队，不会超时报错）</p><p><img src="201907070814.png" alt="201907070814"></p><h4 id="JDBC和ODBC"><a href="#JDBC和ODBC" class="headerlink" title="JDBC和ODBC"></a>JDBC和ODBC</h4><p>JDBC使用起来更方便，ODBC因为是C编写，性能更快一些。</p><p>JDBC：（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，它是Java十三个规范之一。可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。 JDBC的最大特点是它独立于详细的关系数据库。</p><p>ODBC：是微软公司开放服务结构(WOSA，Windows Open Services Architecture)中有关数据库的一个组成部分。一个基于ODBC的应用程序对数据库的操作不依赖数据库类型，能以统一的方式处理全部的数据库。</p><h4 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h4><p><img src="201907070815.png" alt="201907070815"></p><p>一句话解释：Slaver读取Master的binlog并顺序执行</p><p>概述：</p><ol><li>MySQL的主从复制是一个异步的复制过程（虽然一般情况下感觉是实时的），在Master与Slave之间实现整个主从复制的过程是由三个线程参与完成的。其中有两个线程（SQL线程和IO线程）在Slave端，另一个线程（I/O线程）在Master端。</li><li>要实现MySQL的主从复制，首先必须打开Master端的binlog记录功能，否则就无法实现。因为整个复制过程实际上就是Slave从Master端获取binlog日志，然后再在Slave上以相同顺序执行获取的binlog日志中的记录的各种SQL操作</li></ol><p>详细过程</p><ol><li>在Slave 服务器上执行sart slave命令开启主从复制开关，开始进行主从复制。</li><li>此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容</li><li>Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。</li><li>当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容</li><li>Slave服务器端的SQL线程会实时检测本地Relay Log 中新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点</li></ol><p>知识点</p><ol><li>3个线程，主库IO，从库IO和SQL及作用</li><li>master.info（从库）作用</li><li>relay-log 作用</li><li>异步复制</li><li>binlog作用（如果需要级联需要开启Binlog）</li></ol><p>小结</p><ol><li>主从复制是异步的逻辑的SQL语句级的复制</li><li>复制时，主库有一个I/O线程，从库有两个线程，I/O和SQL线程</li><li>实现主从复制的必要条件是主库要开启记录binlog功能</li><li>作为复制的所有Mysql节点的server-id都不能相同</li><li>binlog文件只记录对数据库有更改的SQL语句（来自主库内容的变更），不记录任何查询（select，show）语句</li></ol><p>工作中常用主从模式</p><p><img src="201907070816.png" alt="201907070816"></p><h4 id="数据库事务断电"><a href="#数据库事务断电" class="headerlink" title="数据库事务断电"></a>数据库事务断电</h4><p>本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？</p><p>我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><p>数据库的两段锁协议是指所有事务必须分两个阶段对数据项进行加锁和解锁<br>1.扩展阶段<br>在对任何数据项的读、写之前，要申请并获得该数据项的封锁。</p><p>2.收缩阶段<br>每个事务中，所有的封锁请求必须先于解锁请求。<br>例如：事务T遵循两段锁协议，其封锁协议为：<br>BEGIN TRANSACTION;<br>LOCK（A）；READ A; A := A + 100; WRITE A; LOCK(B); UNLOCK(A); READ(B), UNLOCK(B),;<br>COMMIT;     </p><p>可以证明：若并发执行的所有事务均遵守两段锁协议，则对这些并行事务的任何并行调度策略都是可串行化</p><p>需要说明的是，并发执行的所有事务若均遵守两段锁协议，只是这些事务的并行调度策略能可串行化的充分条件，不是必要条件。</p><p>两段锁协议与防止死锁的一次封锁法的区别：一次封锁法要求事务必须一次对所有要使用到的数据项进行加锁，否则不能继续运行。</p><p>显然，一次封锁法符合两段锁协议，但是两段锁协议并不要求一次就要对所有需要用到的数据项进行加锁，因此遵守两段锁协议的事务有可能死锁</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>&lt;<a href="https://blog.csdn.net/aaronthon/article/details/81714528" target="_blank" rel="noopener">https://blog.csdn.net/aaronthon/article/details/81714528</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/c361604199/article/details/79479398" target="_blank" rel="noopener">https://blog.csdn.net/c361604199/article/details/79479398</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/plg17/article/details/78758593" target="_blank" rel="noopener">https://blog.csdn.net/plg17/article/details/78758593</a>&gt;</p><p>&lt;<a href="https://www.cnblogs.com/luyucheng/p/6289714.html" target="_blank" rel="noopener">https://www.cnblogs.com/luyucheng/p/6289714.html</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/tongdanping/article/details/79878302" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79878302</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/yifansj/article/details/79233726" target="_blank" rel="noopener">https://blog.csdn.net/yifansj/article/details/79233726</a>&gt;</p><p>&lt;<a href="https://www.cnblogs.com/zxz1987/p/6538462.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxz1987/p/6538462.html</a>&gt;</p><p>&lt;<a href="https://coding.imooc.com/lesson/132.html#mid=6561" target="_blank" rel="noopener">https://coding.imooc.com/lesson/132.html#mid=6561</a>&gt;</p><p>&lt;<a href="https://coding.imooc.com/lesson/132.html#mid=6562" target="_blank" rel="noopener">https://coding.imooc.com/lesson/132.html#mid=6562</a>&gt;</p><p>&lt;<a href="https://blog.csdn.net/qq_23923485/article/details/73456784" target="_blank" rel="noopener">https://blog.csdn.net/qq_23923485/article/details/73456784</a>&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据库类别&quot;&gt;&lt;a href=&quot;#数据库类别&quot; class=&quot;headerlink&quot; title=&quot;数据库类别&quot;&gt;&lt;/a&gt;数据库类别&lt;/h4&gt;&lt;h5 id=&quot;关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;关
      
    
    </summary>
    
      <category term="MySQL" scheme="http://ylovex.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://ylovex.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-最小众倍数</title>
    <link href="http://ylovex.cn/2019/06/11/nowcoder-%E6%9C%80%E5%B0%8F%E4%BC%97%E5%80%8D%E6%95%B0/"/>
    <id>http://ylovex.cn/2019/06/11/nowcoder-最小众倍数/</id>
    <published>2019-06-11T04:52:39.000Z</published>
    <updated>2019-07-10T23:48:48.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/3e9d7d22b7dd4daab695b795d243315b?tpId=90&amp;tqId=30844&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/3e9d7d22b7dd4daab695b795d243315b?tpId=90&amp;tqId=30844&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>定5个正整数, 它们的最小的众倍数是指的能够被其中至少三个数整除的最小正整数。给定5个不同的正整数, 请计算输出它们的最小众倍数。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>先遍历n从1开始，再遍历nums[i]，使用map记录n*nums[i]出现的次数，当该数的次数出现三次的时候即为最小众倍数。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Now_68 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int[] nums = new int[5];</span><br><span class="line">        for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">            nums[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res = getRes(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getRes(int[] nums) &#123;</span><br><span class="line">        Map&lt;Integer , Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int n=1;n&lt;Integer.MAX_VALUE; n++)&#123;</span><br><span class="line">            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                if(map.containsKey(n*nums[i]))&#123;</span><br><span class="line">                    map.put(n*nums[i] , map.get(n*nums[i])+1);</span><br><span class="line">                    if(map.get(n*nums[i])==3)&#123;</span><br><span class="line">                        return n*nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    map.put(n*nums[i] , 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getRes2(int[] nums)&#123;</span><br><span class="line">        for(int n=1;n&lt;Integer.MAX_VALUE;n++)&#123;</span><br><span class="line">            int count=0;</span><br><span class="line">            for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                if(n%nums[i]==0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(count&gt;2)&#123;</span><br><span class="line">                    return n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/3e9d7d22b7dd4da
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="遍历" scheme="http://ylovex.cn/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-括号匹配问题</title>
    <link href="http://ylovex.cn/2019/06/07/nowcoder-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://ylovex.cn/2019/06/07/nowcoder-括号匹配问题/</id>
    <published>2019-06-06T23:44:08.000Z</published>
    <updated>2019-07-10T23:47:31.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/380380e6c6b444888ae145593ccbbbca?tpId=90&amp;tqId=30840&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/380380e6c6b444888ae145593ccbbbca?tpId=90&amp;tqId=30840&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>合法的括号匹配序列被定义为:</p><ol><li>空串””是合法的括号序列</li><li>如果”X”和”Y”是合法的序列,那么”XY”也是一个合法的括号序列</li><li>如果”X”是一个合法的序列,那么”(X)”也是一个合法的括号序列</li><li>每个合法的括号序列都可以由上面的规则生成<br>例如””, “()”, “()()()”, “(()())”, “(((())))”都是合法的。 东东现在有一个合法的括号序列s,一次移除</li></ol><p>操作分为两步:</p><ol><li>移除序列s中第一个左括号</li><li>移除序列s中任意一个右括号.保证操作之后s还是一个合法的括号序列<br>东东现在想知道使用上述的移除操作有多少种方案可以把序列s变为空<br>如果两个方案中有一次移除操作移除的是不同的右括号就认为是不同的方案。<br>例如: s = “()()()()()”,输出1, 因为每次都只能选择被移除的左括号所相邻的右括号.<br>s = “(((())))”,输出24, 第一次有4种情况, 第二次有3种情况, … ,依次类推, 4 * 3 * 2 * 1 = 24</li></ol><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>反向遍历，用count记录”)“数量，用res记录结果，每次遍历到”)“则count加一，遍历到”(“则结果乘以count，表示该”(“可以匹配的”)”选择为count数，之后count减一继续遍历，遍历完序列后的res即为方案数量。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Now_64</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String input = bf.readLine();</span><br><span class="line">        <span class="keyword">int</span> len=input.length();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res*=count;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/380380e6c6b4448
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="Stack" scheme="http://ylovex.cn/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-神奇数</title>
    <link href="http://ylovex.cn/2019/06/03/nowcoder-%E7%A5%9E%E5%A5%87%E6%95%B0/"/>
    <id>http://ylovex.cn/2019/06/03/nowcoder-神奇数/</id>
    <published>2019-06-02T23:40:06.000Z</published>
    <updated>2019-07-10T23:47:00.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目来源："><a href="#题目来源：" class="headerlink" title="题目来源："></a>题目来源：</h3><p><a href="https://www.nowcoder.com/practice/56d818ae68134c12b26e81f41ecafb9e?tpId=90&amp;tqId=30841&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/56d818ae68134c12b26e81f41ecafb9e?tpId=90&amp;tqId=30841&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>/**</p><ul><li>东东在一本古籍上看到有一种神奇数,如果能够将一个数的数字分成两组,</li><li>其中一组数字的和等于另一组数字的和,我们就将这个数称为神奇数。</li><li>例如242就是一个神奇数,我们能够将这个数的数字分成两组,</li><li>分别是{2,2}以及{4},而且这两组数的和都是4.东东现在需要统计给定区间中有多少个神奇数,</li><li>即给定区间[l, r],统计这个区间中有多少个神奇数,请你来帮助他。<br>*/</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>设数字X，先求出X的每位数字存在List中，再求出X每位数字和，若为奇数则舍弃，若为偶数则判断是否是神奇数，通过动态规划，dp[i] [j]表示链表前i个数字能否求和得到j，则有dp[i] [j]=dp[i-1] [j] || dp[i-1] [j-list.get(i)];通过逆序循环将dp数组简化为一维数组。</p><h3 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Now_65 &#123;</span><br><span class="line">    public static void main(String[] args)throws IOException&#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String[] strings = bf.readLine().split(&quot; &quot;);</span><br><span class="line">        int left = Integer.parseInt(strings[0]);</span><br><span class="line">        int right = Integer.parseInt(strings[1]);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int num = left ; num&lt;=right ; num++)&#123;</span><br><span class="line">            if(isMagic(num))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMagic(int num) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (num&gt;0)&#123;</span><br><span class="line">            list.add(num%10);</span><br><span class="line">            sum+=num%10;</span><br><span class="line">            num/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum%2 != 0) return false;</span><br><span class="line">        int mid = sum/2;</span><br><span class="line">        int len = list.size();</span><br><span class="line">        boolean[] dp = new boolean[mid+1];</span><br><span class="line">        dp[0]=true;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            for(int j=mid;j&gt;=list.get(i);j--)&#123;</span><br><span class="line">                dp[j]=dp[j-list.get(i)] || dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目来源：&quot;&gt;&lt;a href=&quot;#题目来源：&quot; class=&quot;headerlink&quot; title=&quot;题目来源：&quot;&gt;&lt;/a&gt;题目来源：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/56d818ae68134c1
      
    
    </summary>
    
      <category term="nowcoder" scheme="http://ylovex.cn/categories/nowcoder/"/>
    
    
      <category term="code" scheme="http://ylovex.cn/tags/code/"/>
    
      <category term="动态规划" scheme="http://ylovex.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>web工作方式</title>
    <link href="http://ylovex.cn/2019/05/28/web%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    <id>http://ylovex.cn/2019/05/28/web工作方式/</id>
    <published>2019-05-28T13:30:45.000Z</published>
    <updated>2019-07-10T23:46:21.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web工作方式："><a href="#Web工作方式：" class="headerlink" title="Web工作方式："></a>Web工作方式：</h3><p><em>from:《Go Web 编程》</em></p><p>打开浏览器，输入网址后按下回车，然后显示出浏览内容，这个看似简单的用户行为背后，隐藏的流程一般是：浏览器本身是一个客户端，当你输入 URL 的 时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过IP 地址找到 IP 对应的服务器后，要求建立 TCP 连接，等浏览器发送完 HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容随后断开与该服务器之间的 TCP 连接。</p><p>一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是web浏览器（手机端客户端内部也是浏览器实现的）。</p><p>Web 服务器的工作原理可以简单地归纳为：</p><ol><li>客户机通过 TCP/IP 协议建立到服务器的 TCP 连接 </li><li>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档 </li><li>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端 </li><li>客户机与服务器断开。由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果</li></ol><p>一个简单的 HTTP 事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的 是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。</p><h3 id="URL与DNS解析："><a href="#URL与DNS解析：" class="headerlink" title="URL与DNS解析："></a>URL与DNS解析：</h3><p>URL(Uniform Resource Locator)是“统一资源定位符”的英文缩写，用于描述一个网络上的资源, 基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schema://host[:port#]/path/.../[?query-string][#anchor]</span><br><span class="line">scheme 指定低层使用的协议(例如：http, https, ftp)</span><br><span class="line">host HTTP 服务器的 IP 地址或者域名</span><br><span class="line">port# HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，必须指</span><br><span class="line">明，例如 http://www.cnblogs.com:8080/</span><br><span class="line">path 访问资源的路径</span><br><span class="line">query-string 发送给 http 服务器的数据</span><br><span class="line">anchor 锚</span><br></pre></td></tr></table></figure><p>DNS(Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的 工作。</p><p>更详细的 DNS 解析的过程如下，这个过程有助于我们理解 DNS 的工作模式</p><ol><li>在浏览器中输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</li><li>如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li><li>如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS服务器”，“根 DNS 服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com域的这台服务器。这台负责.com 域的服务器收到请求后，如果自己无法解析，它就会找一 个管理.com 域的下一级 DNS 服务器址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 主机。</li><li>如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS 服务器，由此 DNS 服务器再返回给客户机。</li></ol><p>通过上面的步骤，我们最后获取的是 IP 地址，也就是浏览器最后发起请求的时候是基于 IP来和服务器做信息交互的。</p><h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><p>HTTP 是一种让 Web 服务器与浏览器(客户端)通过 Internet 发送与接收数据的协议,它建立在 TCP 协议之上，一般采用 TCP 的 80 端口。它是一个请求、响应协议–客户端发出一个请 求，服务器响应这个请求。在 HTTP 中，客户端总是通过建立一个连接与发送一个 HTTP 请 求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。 客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的 HTTP 连接。HTTP 协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对 HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web 程 序引入了 Cookie 机制来维护连接的可持续状态。</p><p>HTTP 协议是建立在 TCP 协议之上的，因此 TCP 攻击一样会影响 HTTP 的通讯，例如比较常见的一些攻击：SYN Flood 是当前最流行的 DoS（拒绝服务攻击）与 DdoS（分布式拒 绝服务攻击）的方式之一，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。</p><h3 id="HTTP交互方式："><a href="#HTTP交互方式：" class="headerlink" title="HTTP交互方式："></a>HTTP交互方式：</h3><p>最基本的是GET、POST、PUT、DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET、POST、PUT、DELETE就对应着这个资源的查、改、增、删四个操作。</p><p>GET一般用于获取/查询资源信息，POST一般用于更新资源信息。区别在于：</p><ol><li>GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连。POST方法是把提交数据放在HTTP包的Body中。</li><li>GET提交的数据大小有限制（因为浏览器对URL长度有限制），而POST提交数据没有限制。</li><li>GET方式提交数据，存在安全问题，比如登录页面，通过GET方式的话，用户名和密码都在URL上面，如果页面可以缓存或者其他人可以访问这台机器的，就可以从历史记录中获取账户和密码。</li></ol><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><p>状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。HTTP/1.1协议中定义了5类状态码，由三位数字组成，第一个数字定义了响应的类别。</p><ol><li>1XX：提示信息-表示请求已经被成功接收，继续处理。</li><li>2XX：成功-表示请求已经被成功接收。</li><li>3XX：重定向-要完成请求必须进行更进一步处理。</li><li>4XX：客户端错误-请求有语法错误或请求无法实现。</li><li>5XX：服务器端错误-服务器未能实现合法的请求。</li></ol><table><thead><tr><th>状态码</th><th>状态</th><th align="left">详情</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td align="left">服务器已经处理请求</td></tr><tr><td>301</td><td>永久重定向</td><td align="left">请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</td></tr><tr><td>302</td><td>临时重定向</td><td align="left">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</td></tr><tr><td>303</td><td>请求资源路径改变</td><td align="left">使用GET方法请求新url</td></tr><tr><td>400</td><td>请求错误</td><td align="left">请求的报文中存在语法错误，比如url含有非法字符</td></tr><tr><td>401</td><td>未授权</td><td align="left">未授权，比如访问SpringSecurity限制了权限的资源</td></tr><tr><td>404</td><td>未找到</td><td align="left">服务器找不到请求的网页</td></tr><tr><td>405</td><td>请求错误</td><td align="left">请求的方式（get、post、delete）方法与后台规定的方式不符合</td></tr><tr><td>415</td><td>请求错误</td><td align="left">后台程序不支持提交的content-type</td></tr><tr><td>500</td><td>服务器内部错误</td><td align="left">服务器遇到错误，无法完成请求</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Web工作方式：&quot;&gt;&lt;a href=&quot;#Web工作方式：&quot; class=&quot;headerlink&quot; title=&quot;Web工作方式：&quot;&gt;&lt;/a&gt;Web工作方式：&lt;/h3&gt;&lt;p&gt;&lt;em&gt;from:《Go Web 编程》&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，输入网址后按下
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://ylovex.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="web" scheme="http://ylovex.cn/tags/web/"/>
    
      <category term="http" scheme="http://ylovex.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://ylovex.cn/2019/05/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ylovex.cn/2019/05/25/排序算法总结/</id>
    <published>2019-05-25T12:32:28.000Z</published>
    <updated>2019-07-10T23:45:10.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a>排序算法：</h3><p>稳定：如果a在b前面 ，并且a==b，排序后a仍在b前面</p><p>不稳定：如果a在b前面，并且a==b，排序后a可能在b后面</p><p>时间复杂度：指执行当前算法所消耗的时间</p><p>空间复杂度：值执行当面算法所占用的内存空间</p><p>内排序：所有排序操作都在内存中完成</p><p>外排序：数据放在磁盘中，排序通过磁盘和内存的数据传输进行</p><p><img src="201907060823.png" alt="201907060823"></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序:"></a>冒泡排序:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class bubbleS &#123;</span><br><span class="line">    public static void bubbleSort1(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        for(int i=len-1;i&gt;0;i--)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                //比较相邻两数，若前面大则交换</span><br><span class="line">                if(data[j]&gt;data[j+1])&#123;</span><br><span class="line">                    int tem = data[j];</span><br><span class="line">                    data[j]=data[j+1];</span><br><span class="line">                    data[j+1]=tem;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void bubbleSort2(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        for(int i=len-1;i&gt;0;i--)&#123;</span><br><span class="line">            //改进冒泡，如果一次比较都没有交换，则已经排好序，跳出循环</span><br><span class="line">            boolean isSort = true;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                if(data[j]&gt;data[j+1])&#123;</span><br><span class="line">                    int tem = data[j];</span><br><span class="line">                    data[j]=data[j+1];</span><br><span class="line">                    data[j+1]=tem;</span><br><span class="line">                    isSort=false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isSort) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class selectS &#123;</span><br><span class="line">    public static void selectSort1(int[] data)&#123;</span><br><span class="line">        for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">            //记录每次循环中最小数的下标然后和data[i]交换</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            for(int j=i+1;j&lt;data.length;j++)&#123;</span><br><span class="line">                minIndex = data[j]&lt;data[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            int tem = data[i];</span><br><span class="line">            data[i]=data[minIndex];</span><br><span class="line">            data[minIndex]=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class insertS &#123;</span><br><span class="line">    public static void insertSort1(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        for(int i=1;i&lt;len;i++)&#123;//默认第一个数已排好序，从第二个数开始扫描</span><br><span class="line">            int tem = data[i];</span><br><span class="line">            int j = i-1;//将data[i]与前一位data[i-1]比较</span><br><span class="line">            while (j&gt;=0 &amp;&amp; tem&lt;data[j])&#123;//若小于，将前面的数往后移</span><br><span class="line">                data[j+1]=data[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j+1]=tem;//找到位置后插入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class shellS &#123;</span><br><span class="line">    public static void shellSort1(int[] data)&#123;</span><br><span class="line">        int len = data.length;</span><br><span class="line">        int gap = len/2;</span><br><span class="line">        while (gap&gt;0)&#123;</span><br><span class="line">            for(int i=gap;i&lt;len;i++)&#123;</span><br><span class="line">                int tem = data[i];</span><br><span class="line">                int preIndex = i-gap;</span><br><span class="line">                while (preIndex &gt;= 0 &amp;&amp; data[preIndex]&gt;tem)&#123;</span><br><span class="line">                    data[preIndex+gap]=data[preIndex];</span><br><span class="line">                    preIndex-=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                data[preIndex+gap]=tem;</span><br><span class="line">            &#125;</span><br><span class="line">            gap/=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class mergeS &#123;</span><br><span class="line">    public static void mergeSort1(int[] data)&#123;</span><br><span class="line">        if(data==null || data.length==0) return;</span><br><span class="line">        mergeRec(data , 0 , data.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void mergeRec(int[] data , int left , int right)&#123;</span><br><span class="line">        if(left&gt;=right) return;</span><br><span class="line">        int mid = left + (right-left)/2;</span><br><span class="line">        mergeRec(data , left , mid);</span><br><span class="line">        mergeRec(data , mid+1 , right);</span><br><span class="line">        merge(data , left , mid , right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void merge(int[] data , int left , int mid , int right)&#123;</span><br><span class="line">        int[] h = new int[right-left+1];</span><br><span class="line">        int p1 = left , p2=mid+1;</span><br><span class="line">        int k = 0;</span><br><span class="line">        while (p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            h[k++]=data[p1]&lt;=data[p2] ? data[p1++] : data[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (p1&lt;=mid)&#123;</span><br><span class="line">            h[k++]=data[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (p2&lt;=right)&#123;</span><br><span class="line">            h[k++]=data[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">            data[left+i]=h[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class heapS &#123;</span><br><span class="line">    public static void heapSort1(int[] data)&#123;</span><br><span class="line">        if(data==null || data.length&lt;=1) return;</span><br><span class="line">        for(int i=0;i&lt;data.length;i++)&#123;</span><br><span class="line">            siftUp(data , i);//上浮建堆</span><br><span class="line">        &#125;</span><br><span class="line">        int len = data.length-1;</span><br><span class="line">        swap(data , 0 , len);</span><br><span class="line">        while (len&gt;0)&#123;</span><br><span class="line">            siftDown(data , 0 , len);</span><br><span class="line">            swap(data , 0 , --len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void siftUp(int[] data , int i)&#123;</span><br><span class="line">        while (data[i]&gt;data[(i-1)/2])&#123;</span><br><span class="line">            swap(data , i , (i-1)/2);</span><br><span class="line">            i=(i-1)/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void siftDown(int[] data , int i , int heapSize)&#123;</span><br><span class="line">        int left = 2*i+1;</span><br><span class="line">        int right = 2*i+2;</span><br><span class="line">        int maxIdx = i;</span><br><span class="line">        if(left&lt;heapSize &amp;&amp; data[left]&gt;data[maxIdx]) maxIdx=left;</span><br><span class="line">        if(right&lt;heapSize &amp;&amp; data[right]&gt;data[maxIdx]) maxIdx = right;</span><br><span class="line">        if(maxIdx != i)&#123;</span><br><span class="line">            swap(data , i , maxIdx);</span><br><span class="line">            siftDown(data , maxIdx , heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] data , int s1 , int s2)&#123;</span><br><span class="line">        int tem = data[s1];</span><br><span class="line">        data[s1]=data[s2];</span><br><span class="line">        data[s2]=tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class quickS &#123;</span><br><span class="line">    public void quickSort_1(int[] data, int start, int end) &#123;</span><br><span class="line">        if (data == null || start &lt; 0 || end &gt; data.length - 1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid Parameters&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (start == end) return;</span><br><span class="line">        int index = partition(data, start, end);</span><br><span class="line">        if (index &gt; start) &#123;</span><br><span class="line">            quickSort_1(data, start, index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; end) &#123;</span><br><span class="line">            quickSort_1(data, index + 1, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int partition(int[] data, int start, int end) &#123;</span><br><span class="line">        int index = start + (int)(Math.random() * (end - start + 1));</span><br><span class="line">        swap(data, index, end);</span><br><span class="line">        int small = start - 1;</span><br><span class="line">        for (index = start; index &lt; end; index++) &#123;</span><br><span class="line">            if (data[index] &lt; data[end]) &#123;</span><br><span class="line">                small++;</span><br><span class="line">                if (small != index) &#123;</span><br><span class="line">                    swap(data, index, small);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(data, small + 1, end);</span><br><span class="line">        return small + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] data, int i, int j)&#123;</span><br><span class="line">        int temp = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quickSort_2(int[] data, int start, int end) &#123;</span><br><span class="line">        if (data == null || start &gt;= end) return;</span><br><span class="line">        int i = start, j = end;</span><br><span class="line">        int pivotKey = data[start];</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            while (i &lt; j &amp;&amp; data[j] &gt;= pivotKey) j--;</span><br><span class="line">            if (i &lt; j) data[i++] = data[j];</span><br><span class="line">            while (i &lt; j &amp;&amp; data[i] &lt;= pivotKey) i++;</span><br><span class="line">            if (i &lt; j) data[j--] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = pivotKey;</span><br><span class="line">        quickSort_2(data, start, i - 1);</span><br><span class="line">        quickSort_2(data, i + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;排序算法：&quot;&gt;&lt;a href=&quot;#排序算法：&quot; class=&quot;headerlink&quot; title=&quot;排序算法：&quot;&gt;&lt;/a&gt;排序算法：&lt;/h3&gt;&lt;p&gt;稳定：如果a在b前面 ，并且a==b，排序后a仍在b前面&lt;/p&gt;
&lt;p&gt;不稳定：如果a在b前面，并且a==b，排序后
      
    
    </summary>
    
      <category term="数据结构" scheme="http://ylovex.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://ylovex.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://ylovex.cn/2019/05/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ylovex.cn/2019/05/10/单例模式/</id>
    <published>2019-05-10T12:31:47.000Z</published>
    <updated>2019-07-10T23:44:45.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>from 《菜鸟教程》</p><p>是属于创建型模式，提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，这个类负责创建自己的对象，同时也只有单个对象被创建，这个类提供了一个访问其唯一对象的方法，同时不需要实例化就可以直接访问。</p><ol><li>单例类只能有一个实例</li><li>单例类必须自己创建自己的唯一实例</li><li>单例类必须给所有其他对象提供该实例</li></ol><h5 id="单例与静态类"><a href="#单例与静态类" class="headerlink" title="单例与静态类"></a>单例与静态类</h5><ol><li>单例可以继承和被继承，方法可以被重写，而静态方法不可以</li><li>静态方法中产生的对象会在执行后被释放，进而被GC清理，不会一直存在内存中</li><li>静态类会在第一次运行时候初始化，单例模式可以延迟加载</li></ol><h5 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h5><p>Lazy初始化，非多线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h5><p>Lazy初始化，多线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>非Lazy初始化，多线程，类加载时就初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()[</span><br><span class="line">        return instance;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单例模式：&quot;&gt;&lt;a href=&quot;#单例模式：&quot; class=&quot;headerlink&quot; title=&quot;单例模式：&quot;&gt;&lt;/a&gt;单例模式：&lt;/h3&gt;&lt;p&gt;from 《菜鸟教程》&lt;/p&gt;
&lt;p&gt;是属于创建型模式，提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;这种模式涉及到
      
    
    </summary>
    
      <category term="设计模式" scheme="http://ylovex.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://ylovex.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java Map笔记</title>
    <link href="http://ylovex.cn/2019/05/02/java-map%E7%AC%94%E8%AE%B0/"/>
    <id>http://ylovex.cn/2019/05/02/java-map笔记/</id>
    <published>2019-05-02T13:54:41.000Z</published>
    <updated>2019-07-10T23:44:27.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h3><p><img src="20196301206.png" alt="hashmap"></p><p>参考<a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6059914.html</a></p><p>Entry内部结构为：</p><p><img src="20196301211.png" alt="entry"></p><ol><li>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，即链地址法。HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对和一个hash值和一个指向下一个Entry的next指针。</li><li>如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即</li><li>如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，操作是创建新节点，把该新节点插入到链表中的头部，该新节点的next指针指向原来的头结点 ，即需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。</li><li>所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</li><li>当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作</li><li>如果key为null，就会插入到table[0]的位置也就是数组头。如果key=null，则hash值直接赋0</li><li>存key时，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回：这就是为什么HashMap不能有两个相同的key的原因。</li><li>计算hash值之后，如何通过hash值均匀的存到数组里？当然是取模，但取模消耗大，因此HashMap用的&amp;运算符（按位与操作）来实现的：hashCode &amp; (length-1)。</li><li>这里就隐含了为什么数组长度length一定要是2的n次方。当length不是2的n次方的时候，length-1的二进制最后一位肯定是0，在&amp;操作时，一个为0，无论另一个为1还是0，最终&amp;操作结果都是0，这就造成了结果的二进制的最后一位都是0，这就导致了所有数据都存储在2的倍数位上，所以说，所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</li></ol><p>存储过程：</p><ol><li><p>传入key和value，判断key是否为null，如果为null，则调用putForNullKey，以null作为key存储到哈希表中； </p><p> 　　2.  然后计算key的hash值，根据hash值搜索在哈希表table中的索引位置，若当前索引位置不为null，则对该位置的Entry链表进行遍历，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回，结束；<br>   　　3.  否则调用addEntry，用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部</p></li></ol><p>读取过程：</p><ol><li>调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null。</li></ol><h3 id="JDK1-8前后HashMap区别"><a href="#JDK1-8前后HashMap区别" class="headerlink" title="JDK1.8前后HashMap区别"></a>JDK1.8前后HashMap区别</h3><ol><li>在JDK1.8以前版本中，HashMap的实现是数组+链表，它的缺点是即使哈希函数选择的再好，也很难达到元素百分百均匀分布，而且当HashMap中有大量元素都存到同一个桶中时，这个桶会有一个很长的链表，此时遍历的时间复杂度就是O(n)，当然这是最糟糕的情况。</li><li>在JDK1.8及以后的版本中引入了红黑树结构，HashMap的实现就变成了数组+链表或数组+红黑树。添加元素时，若桶中链表个数超过8，链表会转换成红黑树；删除元素、扩容时，若桶中结构为红黑树并且树中元素个数较少时会进行修剪或直接还原成链表结构，以提高后续操作性能；遍历、查找时，由于使用红黑树结构，红黑树遍历的时间复杂度为 O(logn)，所以性能得到提升。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h3><p>HashMap扩容可以分为三种情况：</p><ol><li><p>使用默认构造方法初始化HashMap。HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。</p></li><li><p>指定初始容量的构造方法初始化HashMap。初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。</p></li><li><p>HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。</p></li></ol><p>HashMap是先插入数据再进行扩容的，但是如果是刚刚初始化容器的时候是先扩容再插入数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://blog.csdn.net/pange1991/article/details/82347284" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/82347284</a></p><h3 id="HashMap多线程问题"><a href="#HashMap多线程问题" class="headerlink" title="HashMap多线程问题"></a>HashMap多线程问题</h3><p>HashMap在多线程情况下出现死循环主要是在1.7情况下面，存在多线程时候应该使用ConcurrentHashMap。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                //循环取出原数组中每一个链表，e本身也是一个链表的节点，同时包含下一个节点的连接,</span><br><span class="line">                //此处e表示第一个节点，next表示链表的下一个节点</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">               //计算在新数组中的存储位置</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                //将原数组链表的第一个元素的next指向新数组，若新数组中已经存在元素，</span><br><span class="line">                //则这个元素为第一个元素，next属性为原节点地址</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                //将新数组的头节点指向e，此时e(原数组中的第一个元素)已经成功的转移到了新数据中</span><br><span class="line">                e = next;</span><br><span class="line">                //继续处理原数组中剩下的节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.jianshu.com/p/1ff9f3dee207" target="_blank" rel="noopener">https://www.jianshu.com/p/1ff9f3dee207</a></p><h3 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h3><ol><li>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。 </li><li>Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</li><li>并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li></ol><h3 id="HashTable和synchronizedMap和ConcurrentHashMap"><a href="#HashTable和synchronizedMap和ConcurrentHashMap" class="headerlink" title="HashTable和synchronizedMap和ConcurrentHashMap"></a>HashTable和synchronizedMap和ConcurrentHashMap</h3><p>HashTable、synchronizedMap效率低下</p><ol><li><p>现在基本不用HashTable。HashTable容器使用synchronized来保证线程安全，但是锁的是整个hash表，当一个线程使用 put 方法时，另一个线程不但不可以使用 put 方法，连 get 方法都不可以。</p></li><li><p>synchronizedMap比HashTable强一分钱，synchronizedMap提供一个不同步的基类和一个同步的包装。允许需要同步的用户可以拥有同步，而不需要同步的用户则不必为同步付出代价，get方法与HashTable一样锁住整个hash表，区别是get()和put()之类的简单操作可以在不需要额外同步的情况下安全地完成。但多个操作组成的操作序列却可能导致数据争用，总之就是不好用。</p></li></ol><p>ConcurrentHashMap效率高，因为用了分段锁（JDK8之前），16个</p><ol><li>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁</li><li>那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率</li><li>这就是 ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，默认分成16个段，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li><li>上面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个hash表。</li></ol><h3 id="ConcurrentHashMap-JDK1-8"><a href="#ConcurrentHashMap-JDK1-8" class="headerlink" title="ConcurrentHashMap JDK1.8"></a>ConcurrentHashMap JDK1.8</h3><p>基本结构：Node&lt;K,V&gt;数组+链表（红黑树）的结构。</p><ol><li>而对于锁的粒度，调整为对每个数组元素加锁（Node），即没有分段锁了，而是Node锁，粒度更小。</li><li>使用CAS操作来确保Node的一些操作的原子性，这种方式代替了锁。</li><li>ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，但同时降低了读一致性。ConcurrentHashMap的get操作上面并没有加锁。所以在多线程操作的过程中，并不能完全的保证一致性。这里和1.7当中类似，是弱一致性的体现。</li><li>代码中使用synchronized而不是ReentrantLock，说明JDK8中synchronized有了足够的优化。</li><li>然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。</li><li>因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O(n)变为O(logN)。</li><li>ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响。</li><li>HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性。</li></ol><h3 id="HashMap读取与写入"><a href="#HashMap读取与写入" class="headerlink" title="HashMap读取与写入"></a>HashMap读取与写入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HashMap实现原理&quot;&gt;&lt;a href=&quot;#HashMap实现原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap实现原理&quot;&gt;&lt;/a&gt;HashMap实现原理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;20196301206.png&quot; alt=&quot;ha
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
      <category term="Map" scheme="http://ylovex.cn/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>LMS算法</title>
    <link href="http://ylovex.cn/2019/04/25/LMS%E7%AE%97%E6%B3%95/"/>
    <id>http://ylovex.cn/2019/04/25/LMS算法/</id>
    <published>2019-04-25T12:07:05.000Z</published>
    <updated>2019-07-10T23:43:56.328Z</updated>
    
    <content type="html"><![CDATA[<p>自适应滤波就是利用前一时刻获得的滤波器参数来自动调节现时刻的滤波器参数，以适应信号和噪声随时间变化的统计特性，从而实现最优滤波。</p><p><img src="2019629001.jpg" alt="jpg"></p><p>主输入端接收带噪信号，参考端为噪声信号，其中参考信号vi是与主输入端中信号s无关但与vo相关的噪声信号，利用量输入信号的相关性和有用信号与噪声的独立性，使参考信号尽可能逼近主输入端中的vo并相减从而抵消掉主输入端中的噪声干扰，最终得到有用信号。</p><p><strong>算法代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function [yn,w,en,itr]=LMSALG(xn,dn,M,mu,itr)</span><br><span class="line">% LMS(Least Mean Squre)算法</span><br><span class="line">% 输入参数:</span><br><span class="line">%     xn   输入的信号序列      (列向量) </span><br><span class="line">%     dn   所期望的响应序列    (列向量) </span><br><span class="line">%     M    滤波器的阶数        (标量)  </span><br><span class="line">%     mu   收敛因子(步长)      (标量)     要求大于0,小于xn的相关矩阵最大特征值的倒数      </span><br><span class="line">%     itr  迭代次数            (标量)     默认为xn的长度,M &lt; itr &lt;= length(xn) </span><br><span class="line">% 输出参数:  </span><br><span class="line">%     w    滤波器的权值矩阵     (矩阵) </span><br><span class="line">%          大小为M*itr,  </span><br><span class="line">%     en   误差序列(itr*1)    (列向量)   </span><br><span class="line">%     yn   实际输出序列         (列向量)</span><br><span class="line"></span><br><span class="line">% 确定迭代次数，若输入迭代次数itr，则设置为itr；若没有该参数，则设置为输入信号长度</span><br><span class="line">% 参数个数必须为4个或5个</span><br><span class="line">if nargin == 4    %  4个时递归迭代的次数为xn的长度</span><br><span class="line">    itr = length(xn);</span><br><span class="line">elseif nargin == 5     %  5个时需满足 M &lt; itr &lt; length(xn)     </span><br><span class="line">    if itr &gt; length(xn) || itr &lt; M          </span><br><span class="line">        error(&apos;迭代次数过大或过小!&apos;);     </span><br><span class="line">    end</span><br><span class="line">else</span><br><span class="line">    error(&apos;请检查输入参数的个数!&apos;); </span><br><span class="line">end  % 初始化参数</span><br><span class="line"></span><br><span class="line">en = zeros(itr,1);     % 误差序列,en(k)表示第k次迭代时预期输出与实际输入的误差</span><br><span class="line">w  = zeros(itr,M);     % 每一行代表一个加权参量,每一列代表-次迭代,初始为0</span><br><span class="line">% w权系数取为矩阵主要是为了判断该算法的收敛性</span><br><span class="line">xn_r=xn&apos;; %%%%参考行向量</span><br><span class="line">dn_r=dn&apos;; %%%%nmr行向量</span><br><span class="line">% 迭代计算</span><br><span class="line">for kitr = M:itr    % 第k次迭代</span><br><span class="line">    x = xn(kitr:-1:kitr-M+1);    % 滤波器M个抽头的输入</span><br><span class="line">    y = w(kitr-1,:)*x;    % 滤波器的输出 </span><br><span class="line">    en(kitr) = dn(kitr) - y;     % 第k次迭代的误差</span><br><span class="line">    % 滤波器权值计算的迭代式</span><br><span class="line">    w(kitr,:) = w(kitr-1,:) + 2*mu*en(kitr)*x&apos;;%%xn(kitr-M+1:kitr)&apos;;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%%%方法一、直接使用filter函数来进行滤波处理</span><br><span class="line">CancellationData = filter(w(end,:),1,xn_r);  % 直接使用filter函数来进行滤波处理</span><br><span class="line">yn = dn_r-CancellationData;</span><br><span class="line">yn = yn(M+1:end);% 去掉与滤波系数长度对应的前N个点</span><br><span class="line">yn=yn&apos;; %%输出行向量</span><br><span class="line"></span><br><span class="line">% % 求最优时滤波器的输出序列</span><br><span class="line">% yn = zeros(size(xn)); </span><br><span class="line">% for kitr = M:length(xn)</span><br><span class="line">%     x = xn(kitr:-1:kitr-M+1);</span><br><span class="line">%     yn(kitr) = dn(kitr) - w(end,:)*x;   % w(:,end)为最后一次迭代生成的滤波器系数</span><br><span class="line">% end</span><br><span class="line">% yn = yn(M:end);  % 前面M个数据没有经过滤波处理，所以设置成inf，绘图时不显示</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自适应滤波就是利用前一时刻获得的滤波器参数来自动调节现时刻的滤波器参数，以适应信号和噪声随时间变化的统计特性，从而实现最优滤波。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2019629001.jpg&quot; alt=&quot;jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;主输入端接收带噪信号，参考端为噪声信号，其
      
    
    </summary>
    
      <category term="信号处理" scheme="http://ylovex.cn/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
      <category term="lms" scheme="http://ylovex.cn/tags/lms/"/>
    
  </entry>
  
  <entry>
    <title>Java Set笔记</title>
    <link href="http://ylovex.cn/2019/04/20/java-set%E7%AC%94%E8%AE%B0/"/>
    <id>http://ylovex.cn/2019/04/20/java-set笔记/</id>
    <published>2019-04-20T13:54:41.000Z</published>
    <updated>2019-07-10T23:43:32.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Set种类"><a href="#Set种类" class="headerlink" title="Set种类"></a>Set种类</h3><p>Set接口的特性，Set接口继承了Collection接口，Set集合中不能包含重复的元素，每个元素必须是唯一的，你只要将元素加入set中，重复的元素会自动移除。</p><p>Java中提供了HashSet、TreeSet、LinkedHashSet三种常用的Set实现。</p><h3 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h3><p>HashSet底层通过HashMap实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="line">     * default initial capacity (16) and load factor (0.75).</span><br><span class="line">     */</span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashSet存储元素是无序的，元素的哈希码进行存储的，HashSet根据每个存储对象的哈希码值（调用hashCode方法获得），用固定的算法算出它的存储索引，把存储对象存放在一个叫做散列表的相应位置中，如果对应的位置没有其它元素，就只需要直接存入；如果该位置已经有元素了，就会将新对象跟该位置的所有对象进行比较（调用equals（）方法），以查看容器中是否已经存在该对象，若不存在，就存放该对象，若已经存在，就直接使用该对象。</p><p>HashSet的存储结构是个链表数组，每一个数组元素就是一个链表，类似这种数据结构称为散列表。数组用于存储元素，该存储元素对应的数组下标是调用hashCode方法返回的存储元素的哈希码。当后加入元素的哈希码与已经加入的元素哈希码相同时，HashSet就会创建一个链表，将相同哈希码的元素存入一个链表，并将该链表的头指针存储到哈希码对应的数组元素中。</p><h3 id="HashSet和TreeSet"><a href="#HashSet和TreeSet" class="headerlink" title="HashSet和TreeSet"></a>HashSet和TreeSet</h3><p>HashSet底层数据结构是哈希表，TreeSet底层数据结构是红黑树。</p><p>TreeSet保证元素的排序方式：</p><ol><li>自然排序(这种排序方式可以理解成元素本身具备比较性)让元素所属的类实现Comparable接口。</li><li>比较器排序(这种排序可以理解成集合类具备比较性)让集合构造方法接收Comparator的实现类对象，实现方式可以用匿名类来实现。</li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>是HashSet子类，LinkedHashSet集合也是根据元素hashCode值来决定元素存储位置，但它同时使用链表维护元素的次序，这样使的元素看起来是以插入的顺序保存的。也就是说当遍历LinkedHashSet集合里的元素时，HashSet将会按元素的添加顺序来访问集合里的元素。</p><p>LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但是在迭代访问Set里的全部元素时，将有很好的性能，因为它以列表来维护内部顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Set种类&quot;&gt;&lt;a href=&quot;#Set种类&quot; class=&quot;headerlink&quot; title=&quot;Set种类&quot;&gt;&lt;/a&gt;Set种类&lt;/h3&gt;&lt;p&gt;Set接口的特性，Set接口继承了Collection接口，Set集合中不能包含重复的元素，每个元素必须是唯一的，你
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
      <category term="Set" scheme="http://ylovex.cn/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Java List笔记</title>
    <link href="http://ylovex.cn/2019/04/14/java-list%E7%AC%94%E8%AE%B0/"/>
    <id>http://ylovex.cn/2019/04/14/java-list笔记/</id>
    <published>2019-04-14T13:54:41.000Z</published>
    <updated>2019-07-10T23:43:19.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List是一个接口，继承于Collenction接口，它代表着有序的队列。</p><p>​     ps：java.util.Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法；javautil.Collections是一个包装类，它包含各种有关集合操作的静态多态方法，该类不能实例化，服务于Collection框架。</p><p>ArrayList：底层是用数组实现。</p><p>LinkedList：底层是通过双向链表实现。</p><p>Vector：通过数组实现，线程安全。</p><h3 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h3><p>默认初始容量为10.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>扩容，默认为1.5倍方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><p>ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。</p><p>对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。</p><p>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p><p>对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对 ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。</p><p>在ArrayList集合中添加或者删除一个元素时，当前的列表所所有的元素都会被移动。而LinkedList集合中添加或者删除一个元素的开销是固定的。</p><p>LinkedList集合不支持高效的随机随机访问（RandomAccess），因为可能产生二次项的行为。</p><p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。</p><h3 id="Arrays-asList-方法"><a href="#Arrays-asList-方法" class="headerlink" title="Arrays.asList()方法"></a>Arrays.asList()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] a = &#123;1,2,3,4&#125;;</span><br><span class="line">        List a_list = Arrays.asList(a);</span><br><span class="line">        System.out.println(a_list.size());//size=1</span><br><span class="line">        Integer[] b = &#123;1,2,3,4&#125;;</span><br><span class="line">        List b_list = Arrays.asList(b);</span><br><span class="line">        System.out.println(b_list.size());//size=4</span><br></pre></td></tr></table></figure><p>Arrays.asList方法返回的是List，通过Arrays类的一个内部类实现，内部用的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反应到List中，对List调用add/remove方法会抛出异常。</p><p>使用ArrayList方法实现为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(a));</span><br></pre></td></tr></table></figure><h3 id="ArrayList线程不安全"><a href="#ArrayList线程不安全" class="headerlink" title="ArrayList线程不安全"></a>ArrayList线程不安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为ArrayList本身不是线程安全的，通过Collections.synchronizedList可以将其包装成一个线程安全的List。</p><h3 id="Vector和ArrayList"><a href="#Vector和ArrayList" class="headerlink" title="Vector和ArrayList"></a>Vector和ArrayList</h3><p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h3&gt;&lt;p&gt;List是一个接口，继承于Collenction接口，它代表着有序的队列。&lt;/p&gt;
&lt;p&gt;​     ps：java.uti
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
      <category term="List" scheme="http://ylovex.cn/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础知识</title>
    <link href="http://ylovex.cn/2019/04/10/java-%E5%9F%BA%E7%A1%80/"/>
    <id>http://ylovex.cn/2019/04/10/java-基础/</id>
    <published>2019-04-10T13:43:41.000Z</published>
    <updated>2019-07-10T23:43:04.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h3><ol><li>面向过程：是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。</li><li>面向对象：是以“对象”为中心的编程思想。</li><li>面向对象三大特性：封装、继承、多态。因为一切皆对象，所以一切都需要“封装”成类。“继承”让我们设计相似的东西的时候更方便，而“多态”让我们使用类似的东西的时候可以不用去思考它们微弱的不同。我们关心的不是过程，而是接口，而接口来自对象，故名为面向对象。</li></ol><h3 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h3><ol><li>封装：通过隐藏类的内部实现机制，对外界提供已经定义好的接口进行访问。对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。</li><li>继承：是从已有的类得到继承信息创建新的类的过程，继承可以表示为is-a关系，让我们设计相似的东西的时候更加的方便。</li><li>多态：可以分为方法重载和方法重写两种方式，方法重载是在编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致；方法重写是运行时多态（也称为后绑定），实现方法重写：1.方法重写，子类继承父类并重写父类方法；2.用父类型引用来引用子类型对象，实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li></ol><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol><li><p>Java的反射机制允许我们动态的调用某个对象的方法、构造函数、获取某个对象的属性等；</p></li><li><p>无需在编码的时候确定调用的对象</p></li><li><p>实现方式：</p><ol><li><p>先获取这个类的class实例，比如:Class&lt;?&gt; myClass =Class.<strong>forName</strong>(“myClassName”);</p></li><li><p>然后通过这个类实例获得一个类对象，比如：Object myClassObject = myClass.newInstance();</p></li><li><p>然后调用Class类的对象的<strong>getMethod</strong>获取method对象;</p></li><li><p>获取method对象后调用method.<strong>invoke</strong>方法获取这个类的field、method、construct等，在这一步中，JVM默认如果调用次数小于15次，会调用native方法实现反射，累积调用大于15次之后，会由java代码创建出字节码来实现反射。</p></li></ol></li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h5 id="实现了Collection接口的集合类："><a href="#实现了Collection接口的集合类：" class="headerlink" title="实现了Collection接口的集合类："></a>实现了Collection接口的集合类：</h5><ol><li><p>Collection&lt;–List&lt;–Vector</p></li><li><p>Collection&lt;–List&lt;–ArrayList</p></li><li><p>Collection&lt;–List&lt;–LinkedList</p></li><li><p>Collection&lt;–Set&lt;–HashSet </p></li><li><p>Collection&lt;–Set&lt;–HashSet&lt;–LinkedHashSet</p></li><li><p>Collection&lt;–Set&lt;–SortedSet&lt;–TreeSet</p></li></ol><h5 id="实现了Map接口，和Collection接口没关系，但都属于集合类的一部分："><a href="#实现了Map接口，和Collection接口没关系，但都属于集合类的一部分：" class="headerlink" title="实现了Map接口，和Collection接口没关系，但都属于集合类的一部分："></a>实现了Map接口，和Collection接口没关系，但都属于集合类的一部分：</h5><ol><li><p>HashMap</p></li><li><p>HashTable</p></li><li><p>LinkedHashMap</p></li><li><p>TreeMap</p></li><li><p>SynchronizedMap</p></li><li><p>ConcurrentHashMap</p></li><li></li></ol><h3 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h3><h5 id="被final声明的对象即表示“我不想这个对象再被改变”，因此："><a href="#被final声明的对象即表示“我不想这个对象再被改变”，因此：" class="headerlink" title="被final声明的对象即表示“我不想这个对象再被改变”，因此："></a>被final声明的对象即表示“我不想这个对象再被改变”，因此：</h5><ol><li>被final声明的方法：这个方法不可以被子类重写</li><li>被final声明的类：这个类不能被继承</li><li>被final声明的变量：引用不能改变，常和static关键字一起使用作为常量<br>final关键字的好处：</li><li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li><li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li><li>使用final关键字，JVM会对方法、变量及类进行优化。</li></ol><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><ol><li>static用来修饰成员变量和成员方法，也可以形成静态static代码块。</li><li>static对象可以在它的任何对象创建之前访问，无需引用任何对象。</li><li>因此主要作用是构造全局变量和全局方法。</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>boolean byte char ：都是一个字节</p></li><li><p>short int long float double ：int是4个字节，负2的31次方到正2的31次方减1</p></li><li><p>String Enum Array</p></li><li><p>Object</p><p>ps：负数使用补码表示</p><p>Primitive type:  int,long,float…</p><p>Object: Integer,Long,Float,String…</p><p>Primitive type:</p><ol><li>值类型</li><li>用a==b判断相等</li></ol><p>Object：</p><ol><li>引用类型</li><li>用a==b判断是否为同一个Object</li><li>用a.equals(b),或者Obeject.equals(a,b)判断是否相等</li><li>两个Object如果不是同一个Object，即使值相等用==判断也是false</li></ol></li></ol><h3 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h3><h6 id="基于空间的考虑："><a href="#基于空间的考虑：" class="headerlink" title="基于空间的考虑："></a>基于空间的考虑：</h6><ol><li>数组的存储空间是静态，连续分布的，初始化的过大造成空间浪费，过小又将使空间溢出机会增多。而链表的存储空间是动态分布的，只要内存空间尚有空闲，就不会产生溢出；链表中每个节点出了数据域外，还有链域（指向下一个节点），这样空间利用率就会变高。</li><li>数组从栈中分配空间，对于程序员方便快速，但是自由度小。链表从堆中分配空间，自由度大但是申请管理比较麻烦。</li><li>数组中的数据在内存中按顺序存储的，而链表是随机存储的。</li></ol><h6 id="基于时间的考虑："><a href="#基于时间的考虑：" class="headerlink" title="基于时间的考虑："></a>基于时间的考虑：</h6><ol><li>数组查询快，插入与删除慢，单链表查询慢，插入与删除快。细说的话：数组中任意节点都可以在O（1）内直接存储访问，而链表中的节点，需从头指针顺着链表扫描才能获取到；而链表任意位置进行插入和删除，都只需要修改指针，而数组中插入删除节点，平均要移动一半的节点。</li></ol><h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><table><thead><tr><th></th><th>public</th><th>protected</th><th>defailt</th><th>private</th></tr></thead><tbody><tr><td>同一个类</td><td>True</td><td>True</td><td>True</td><td>True</td></tr><tr><td>同一个包</td><td>True</td><td>True</td><td>True</td><td>False</td></tr><tr><td>子父类</td><td>True</td><td>True</td><td>False</td><td>False</td></tr><tr><td>不同包</td><td>True</td><td>False</td><td>False</td><td>False</td></tr></tbody></table><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>抽象类就是比普通类多了一些抽象方法而已，其他部分和普通类完全一样；而接口是特殊的抽象类。<br>作用上看：</p><ol><li><p>接口与抽象类结构有点像，但功能完全不同</p></li><li><p>接口是强调合约、约束关系，即你要与我合作，必须实现我的功能；抽象类没这个功能</p></li></ol><p>语法上看：</p><ol><li>都不能被实例化</li><li>接口是特殊的抽象类</li><li>接口不能有实现，Java8中可以有添加default关键字的默认实现和静态方法实现。</li><li>接口中的成员变量必须是public static final修饰（编译器默认会添加上），因此是常量</li><li>一个类可以实现多个接口但只能继承一个抽象类</li></ol><p>什么是接口？</p><ol><li>从表现来说：定义了很多函数，但是这些函数都没有实现，这就是接口。从作用来说：起到一个合约规范的作用。我要告诉你和我打交道的东西有什么约束</li><li>接口中的方法只能用public和abstract修饰或者不修饰</li><li>接口中的属性默认都是public static final，因此是常量</li></ol><h3 id="equal与"><a href="#equal与" class="headerlink" title="equal与=="></a>equal与==</h3><p>对于字符串变量：</p><p>==：比较两个对象在内存中的首地址</p><p>equals：比较字符串中所包含的内容是否相同</p><p>对于非字符串变量：</p><p>==和equals都是比较对象在堆内存中的首地址。</p><h3 id="装箱及拆箱"><a href="#装箱及拆箱" class="headerlink" title="装箱及拆箱"></a>装箱及拆箱</h3><p>Integer i = 10; //装箱</p><p>int n = i ;//拆箱</p><p>装箱就是自动将基本数据类型转换为包装器类型。</p><p>拆箱就是自动将包装器类型转换为基本数据类型。</p><h3 id="hashCode方法及作用"><a href="#hashCode方法及作用" class="headerlink" title="hashCode方法及作用"></a>hashCode方法及作用</h3><p>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的 字段等）映射成一个数值，这个数值称作为散列值。</p><p>1、在Java集合中有两类，一类是List，一类是Set。他们之间的区别就在于List集合中的元素是有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知<br>2、当集合要添加新的对象时，先调用这个对象的 hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode 值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址<br>3、所以hashCode在上面扮演的角色为快速寻域（寻找某个对象在集合中区域位置）</p><p>在重写equals方法的同时，必须重写hashCode方法。为什么这么说呢？<br>1、让equals方法和hashCode方法始终在逻辑上保持一致性<br>2、即让equals认为相等的两个对象，这两个对象同时调用hashCode方法，返回的值也是一样的</p><h3 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h3><p>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p><p>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</p><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p><p>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p><p>Date Time API − 加强对日期与时间的处理。</p><p>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p><p>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p><h3 id="Java-NIO框架对比"><a href="#Java-NIO框架对比" class="headerlink" title="Java NIO框架对比"></a>Java NIO框架对比</h3><p>Mina</p><p>Mina(Multipurpose Infrastructure for Network Applications) 是 Apache 组织一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 Mina 版本2.04支持基于 Java NIO 技术的 TCP/UDP 应用程序开发、串口通讯程序，Mina 所支持的功能也在进一步的扩展中。</p><p>Netty</p><p>Netty是一款异步的事件驱动的网络应用框架和工具，用于快速开发可维护的高性能、高扩展性协议服务器和客户端。也就是说，Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器。</p><p>Grizzly</p><p>Grizzly是一种应用程序框架，专门解决编写成千上万用户访问服务器时候产生的各种问题。使用JAVA NIO作为基础，并隐藏其编程的复杂性。容易使用的高性能的API。带来非阻塞socketd到协议处理层。利用高性能的缓冲和缓冲管理使用高性能的线程池。</p><p>xSocket</p><p>xSocket是一个轻量级的基于nio的服务器框架用于开发高性能、可扩展、多线程的服务器。该框架封装了线程处理、异步读/写等方面。（只是对Java的NIO做了最简单的封装，以便于开发使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象和面向过程&quot;&gt;&lt;a href=&quot;#面向对象和面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向对象和面向过程&quot;&gt;&lt;/a&gt;面向对象和面向过程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面向过程：是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然
      
    
    </summary>
    
      <category term="Java" scheme="http://ylovex.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ylovex.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://ylovex.cn/2019/04/03/my-first-blog/"/>
    <id>http://ylovex.cn/2019/04/03/my-first-blog/</id>
    <published>2019-04-03T13:41:41.000Z</published>
    <updated>2019-07-10T23:42:47.694Z</updated>
    
    <content type="html"><![CDATA[<p>Desire is the starting point of all achievement</p><p>渴望是所有成就的原点。</p><p>love xy </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Desire is the starting point of all achievement&lt;/p&gt;
&lt;p&gt;渴望是所有成就的原点。&lt;/p&gt;
&lt;p&gt;love xy &lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="http://ylovex.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="http://ylovex.cn/tags/Life/"/>
    
  </entry>
  
</feed>
