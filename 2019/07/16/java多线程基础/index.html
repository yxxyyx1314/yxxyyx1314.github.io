<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Yang Peng's blogs"><meta name="keywords" content="cs,java,go"><title>java多线程基础 | 人生如逆旅，我亦是行人</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java多线程基础</h1><a id="logo" href="/.">人生如逆旅，我亦是行人</a><p class="description">Desire is the starting point of all achievement</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">java多线程基础</h1><div class="post-meta"><a href="/2019/07/16/java多线程基础/#comments" class="comment-count"></a><p><span class="date">Jul 16, 2019</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h2><h3 id="并行基础概念"><a href="#并行基础概念" class="headerlink" title="并行基础概念"></a>并行基础概念</h3><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>同步和异步通常是形容一次方法的调用，同步方法调用一旦开始，调用者必须等到方法调用返回后才能继续后续的行为；异步调用更像一个消息传递，一旦开始，方法调用就会立即放回，调用者可以继续后续的操作，而异步方法通常会在另外一个线程中“真实”的执行。</p>
<h5 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h5><p>并发侧重于多个任务交替执行，并行是真实的同时执行，真实的并行只可能出现在多核CPU中</p>
<h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是一次只能有一个线程使用，一旦临界区资源被占用，其他线程想到使用这个资源必须等待</p>
<h5 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h5><p>当一个线程占用了临界区资源，其他所以需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起，这种情况就是阻塞。</p>
<h5 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h5><p>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>饥饿是某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。</p>
<p>活锁是两个线程主动将资源释放给对方用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。</p>
<h5 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h5><p>可以分为阻塞、无饥饿、无障碍、无锁、无等待等</p>
<p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当使用synchronized关键字或者重入锁，得到的就是阻塞的线程</p>
<p>如果线程之间是有优先级的，那么线程调度的时候总会倾向于满足高优先级的线程，对于非公平锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。但如果锁是公平的，满足先来后到，那么饥饿就不会产生</p>
<p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方挂起，对于无障碍线程，当检测到多个线程修改共享数据就会立即对自己所做的修改进行回滚，确保数据安全，如果没有数据竞争发生就可以顺利完成任务</p>
<p>无锁的并行都是无障碍的，在无锁的情况下，所有的线程都尝试对临界区进行访问，但不同的是无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区</p>
<p>无等待在无锁的基础上更进一步，要求所有的线程都必须在有限步内完成，一种典型的无等待结构就是RCU（Read-Copy-Update）基本思想是对数据的读可以不就控制，但在写数据的时候，先取得原始数据的副本，接着只修改副本数据，修改完成后，在合适的时机回写数据</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>是指一个操作是不可中断的，即使是多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰</p>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>是指一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改</p>
<h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致</p>
<h3 id="Java并行基础"><a href="#Java并行基础" class="headerlink" title="Java并行基础"></a>Java并行基础</h3><h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</p>
<p>线程是程序执行的最小单位，使用多线程而不是多进程进行并发程序设计是因为线程间的切换和调度的成本远小于进程</p>
<h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><p><img src="201907160001.png" alt="37812319"></p>
<h5 id="New状态"><a href="#New状态" class="headerlink" title="New状态"></a>New状态</h5><p>当使用new创建一个Thread对象时候，此时并不处于执行状态</p>
<h5 id="Runnable状态"><a href="#Runnable状态" class="headerlink" title="Runnable状态"></a>Runnable状态</h5><p>调用start方法后，那么此时才是真正在JVM进程中创建了一个线程，该状态线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权</p>
<h5 id="Running状态"><a href="#Running状态" class="headerlink" title="Running状态"></a>Running状态</h5><p>可运行状态（Runnable）的线程获得CPU时间片，执行程序代码</p>
<h5 id="Blocked状态"><a href="#Blocked状态" class="headerlink" title="Blocked状态"></a>Blocked状态</h5><p>是指线程因为某种原因放弃了cpu的使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<ol>
<li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li>
<li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>
<li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或运行在当前线程里的其它线程调用了join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ol>
<h5 id="Dead状态"><a href="#Dead状态" class="headerlink" title="Dead状态"></a>Dead状态</h5><p>线程run(),main()方法执行结束，或者因为异常退出了run()方法，则该线程结束生命周期</p>
<h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><h5 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h5><p>只需要使用new关键字创建一个线程对象，并且将它start()起来即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = new Thread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p>start()方法就会新建一个线程并让这个线程执行run()方法</p>
<p>如果直接调用run()方法不会新建一个线程，而是只会在当前线程中，串行执行run()中的代码</p>
<ol>
<li>继承Thread创建线程</li>
<li>实现Runnanle接口创建线程</li>
<li>实现Callable接口通过FutureTask包装器来创建线程</li>
<li>使用ExecutorService、Callable、Future实现有返回结果的线程</li>
</ol>
<h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>stop()方法，可以立即将线程终止，已被标记为废弃</p>
<p>强行把执行到一半的线程终止，可能会引起一些数据不一致问题</p>
<h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><p>线程中断不会使线程立即退出，而是给线程发送一个通知告知目标线程希望其退出，至于目标线程接到通知后如何处理则完全由线程自行决定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void Thread.interrupt() //中断线程</span><br><span class="line">public boolean Thread.isInterrupted() //判断是否被中断</span><br><span class="line">public static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态</span><br></pre></td></tr></table></figure>

<p>Thread.interrupt()是一个实例方法，它通知目标线程中断，也就是设置设置中断标志位。中断标志位表示当前线程已经被中断了。Thread.isInterrupted()方法也是实例方法，它判断当前线程是否被中断（通过检查中断标志位）。Thread.interrupted()是静态方法，也是判断中断状态，但同时会清除当前线程的中断标志位状态。</p>
<p>interrupted()作用于当前线程，interrupt()和isInterrupted()作用于调用此方法的实例所代表的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void sleep(long millis) throws InterruptedException</span><br><span class="line">public static void sleep(long millis, int nanos) throws InterruptedException</span><br></pre></td></tr></table></figure>

<p>sleep()方法会让当前线程休眠若干时间，它会抛出一个InterruptedException中断异常。InterruptedException不是运行时异常，也就是程序必须捕获处理，当线程在sleep()休眠时，如果被中断，这个异常就会产生</p>
<h5 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h5><p>这两个方法输出Object类，任何对象都可以调用</p>
<p>当在一个对象实例上调用了wait方法后，当前线程就会在这个对象上等待，比如一个线程调用了object.wait()，那么它就会进入这个object对象的等待队列。这个等待队列中可能有多个线程在等待，当object.notify()被调用的时候，就会从这个等待队列中随机选择一个线程唤醒，这个选择是不公平的，完全随机的</p>
<p>notifyAll()方法会唤醒在这个等待队列中所有的等待的线程</p>
<p>wait()和notify()方法必须包含哎对应的synchronzied语句中，都需要首先获得目标对象的一个监视器，</p>
<p>wait和sleep方法都可以让线程等待若干时间，wait方法会释放目标对象的锁，而sleep方法不会释放任何资源</p>
<h5 id="挂起suspend和继续执行resume线程"><a href="#挂起suspend和继续执行resume线程" class="headerlink" title="挂起suspend和继续执行resume线程"></a>挂起suspend和继续执行resume线程</h5><p>不推荐使用，suspend方法在导致线程暂停的同时，并不会去释放任何锁资源，直到对应线程上进行了resume方法被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行，但是如果resume操作意外的在suspend前执行会导致所占用的锁不会被释放。</p>
<h5 id="等待线程结束join和谦让yield"><a href="#等待线程结束join和谦让yield" class="headerlink" title="等待线程结束join和谦让yield"></a>等待线程结束join和谦让yield</h5><p>当一个线程的输入可能非常依赖另外一个或者多个线程的输出时候。此时这个线程就需要等待依赖线程执行完毕才能继续执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptException</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException</span><br></pre></td></tr></table></figure>

<p>第一个join方法表示无限等待，它会一直阻塞当前线程，直到目标线程执行完毕，第二个方法给出了一个最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因为等不及了而继续往下执行</p>
<p>join方法本质是让调用线程wait()在当前线程对象实例上，它让调用线程在当前对象上进行等待，当线程执行完成后，被等待的线程会在退出前调用notifyAll通知所有的等待线程继续执行 。因此不要在应用程序中，在Thread对象实例上使用类似wait或者notify等方法</p>
<p>yield方法是一个静态方法，会使当前线程让出CPU，但是让出后该线程还会进行CPU资源的争夺</p>
<h4 id="volatile与Java内存模型（JMM）"><a href="#volatile与Java内存模型（JMM）" class="headerlink" title="volatile与Java内存模型（JMM）"></a>volatile与Java内存模型（JMM）</h4><p>在计算机中，所有的运算操作都是由CPU的寄存器完成，CPU指令的执行过程需要涉及数据的读取和写入操作，由于CPU的处理速度和内存的访问速度之间的差距越来越大，增加了缓存的设计</p>
<p> <img src="201907160002.png" alt="23131123"></p>
<p>由于缓存的出现，极大地提高了CPU的吞吐模型，但是同时也引入了缓存不一致的问题，比如i++操作，在程序的运行过程中，首先需要将主内存中的数据复制一份存放到CPU Cache中，那么CPU寄存器在进行数值计算的时候就直接到Cache中读取和写入，当整个过程运算结束之后再将Cache中的数据刷新到主存当中，</p>
<p>i++在单线程中不会出现问题，但是在多线程中就会出现问题，为了解决缓存不一致的问题，通常主流解决办法有：通过总线加锁的方式，通过缓存一致性协议</p>
<p> 在缓存一致性协议中最为出名的是Intel的MESI协议，MESI协议保证了每一个缓存中使用的共享变量副本都是一致的，它的大致思想是，当CPU在操作Cache数据的时，如果发现该变量是一个共享变量，也就是说在其他CPU Cache中也存在一个副本，那么：</p>
<ol>
<li>读取操作，不做任何处理，只是将Cache中的数据读取到寄存器</li>
<li>写入操作，发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU在进行该变量读取的时候不得不到主内存中再次获取</li>
</ol>
<h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p> Java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系，具体有：</p>
<ol>
<li>共享内存存储在主内存之中，每个线程都可以访问</li>
<li>每个线程都有私有的工作内存或者称为本地内存</li>
<li>工作内存只存储该线程对共享变量的副本</li>
<li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存</li>
<li>工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等</li>
</ol>
<p><img src="201907160003.png" alt="12311414"></p>
<h5 id="JMM与原子性"><a href="#JMM与原子性" class="headerlink" title="JMM与原子性"></a>JMM与原子性</h5><p>对基本数据类型的变量读取赋值操作是原子性，对引用类型的变量读取和赋值操作也是原子性的</p>
<ol>
<li><p>x=10 原子性</p>
</li>
<li><p>y=x 非原子</p>
</li>
<li><p>y++ 非原子</p>
</li>
<li><p>z=z+1 非原子</p>
<p>JMM只保证了基本读取和赋值的原子性操作，如果想要使得某些代码片段具备原子性，需要使用关键字synchronized，或者JUC中的lock。如果想要使得int等类型自增操作具备原子性，可以使用JUC包下的原子封装类型java.util.concurrent.atomic.*</p>
</li>
</ol>
<p>volatile关键字不具备原子性的语义</p>
<h5 id="JMM与可见性"><a href="#JMM与可见性" class="headerlink" title="JMM与可见性"></a>JMM与可见性</h5><p>使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作要先修改工作内存，但是修改结束后会立刻将其刷新到主内存中</p>
<p>同通过synchronized关键字，能够保证同一个时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中</p>
<p>通过JUC提供的显式锁Lock</p>
<h5 id="JMM与有序性"><a href="#JMM与有序性" class="headerlink" title="JMM与有序性"></a>JMM与有序性</h5><p>在Java内存模型中，允许编译器和处理器对指令进行重排列，</p>
<ol>
<li>使用volatile</li>
<li>使用synchronized</li>
<li>使用Lock</li>
</ol>
<h5 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h5><ol>
<li>程序次序规则：在一个线程内，代码按照编写时的次序执行，但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致</li>
<li>锁定原则：一个unlock操作要先发生于对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作要早与对这个变量之后的读操作</li>
<li>传递规则：如果A操作先于B，B先于C，则A肯定先于C</li>
<li>线程启动规则：Thread对象的start方法要先行发生于对该线程的任何动作</li>
<li>线程中断规则：对线程执行interrupt方法肯定要优先于捕获到中断信号</li>
<li>线程终结规则：线程中所有的操作都要先行发生于线程的终止检测</li>
<li>对象的终结规则：一个对象初始化的完成要先行发生在finalize()方法前</li>
</ol>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p> 被volatile修饰的实例变量或者类变量具备如下两层语义：</p>
<ol>
<li>保证了不同线程之间对共享变量操作的可见性</li>
<li>禁止对指令进行重排序操作</li>
</ol>
<h5 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h5><p> 被volatile修饰的变量存在于一个“lock；”的前缀中，</p>
<p><img src="201907160004.png" alt="13123"></p>
<p>“lock；”前缀实际上相当于一个内存屏障，该内存屏障会为指令的执行提供如下几个保证：</p>
<ol>
<li>确保指令重排序时不会将后面的代码排到内存屏障之前</li>
<li>确保指令重排序时不会将前面的代码排到内存屏障后</li>
<li>确保在执行到内存屏障修饰的指令时在前面的代码全部执行完成</li>
<li>强制将线程工作内存中的值修改刷新到主内存</li>
<li>如果是写操作，则会导致其他线程工作内存总的缓存数据失效</li>
</ol>
<h5 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h5><p>使用上的区别</p>
<ol>
<li>volatile关键字只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法参数和局部变量、常量等</li>
<li>synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块</li>
<li>volatile修饰的变量可以为null，synchronized同步语句块的monitor对象不能为null</li>
</ol>
<p>对原子性的保证</p>
<ol>
<li>volatile不能保证原子性</li>
<li>synchronized可以保证代码的原子性</li>
</ol>
<p>对可见性的保证</p>
<ol>
<li>都可以保证共享资源在多线程的可见性</li>
<li>synchronized借助JVM指令monitor enter和monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都将刷新到主内存</li>
<li>volatile使用机器指令（偏硬件）“lock；”的方式迫使其他线程工作内存中的数据失效，不得不在主内存进行再次加载</li>
</ol>
<p>对有序性保证</p>
<ol>
<li>volatile禁止JVM编译器以及处理器对其进行重排序，所以保证有序性</li>
<li>synchronized所修饰的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修饰的代码块代码指令中也会发生指令重排序情况</li>
</ol>
<p>其他</p>
<ol>
<li>volatile不会使线程陷入阻塞</li>
<li>synchronized会使线程进入阻塞</li>
</ol>
<h5 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h5><p> 在Thread的构造函数中，可以显示的指定线程的Group，也就是ThreadGroup，下面看<code>init</code>方法的中间部分: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">              what to do. */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = security.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">              use the parent thread group. */</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果在构造Thread的时候没有显示的指定一个ThreadGroup，那么子线程将会被加入父线程所在的线程组</p>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p> 守护线程是在后台默默完成一些系统性的服务，比如垃圾回收线程、JIT线程；与之对应的是用户线程，用户线程是系统的工作线程，完成这个程序要完成的业务操作。当用户线程全部结束，只有守护线程时候，Java虚拟机自然退出</p>
<p><code>setDaemon</code> 方法。<code>isDaemon()</code> 方法可以判断该线程是不是守护线程。</p>
<p>另外需要注意的就是，<code>setDaemon()</code> 方法只在线程启动之前才能生效，如果一个线程已经死亡，那么再设置 <code>setDaemon()</code> 则会抛出 <code>IllegalThreadStateException</code> 异常。</p>
<h5 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h5><p>指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁</p>
<p>直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁</p>
<p>直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁</p>
<p>对象的同步Synchronized的底层是通过monitor来完成<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ol>
<li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
</li>
<li><p>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
</li>
<li><p>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ol>
<p>释放锁则是通过monitorexit指令，执行monitorexit的线程必须是objectref所对应的monitor的所有者，指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<p>方法的synchronized同步：相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<h3 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h3><h4 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h4><p>重要方法：</p>
<ol>
<li>lock():获得锁，如果锁已经被占用，则等待</li>
<li>lockInterruptibly():获得锁，但是优先响应中断</li>
<li>tryLock()：尝试获得锁，如果成功返回true，失败返回flae。该方法不等待，立即返回</li>
<li>tryLock(long time , TimeUnit nuit)：在给定时间内尝试获得锁</li>
<li>unlock()：释放锁</li>
</ol>
<p>在重入锁实现中主要包含三个要素：</p>
<ol>
<li>原子状态。原子状态使用CAS操作来存储当前锁的状态，判断锁是否已经被别的线程持有；以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</li>
<li>等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作</li>
<li>阻塞原语park()和unpark(),用于挂起和恢复线程,没有得到锁的线程将会被挂起</li>
</ol>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>通过Lock接口的Condition newCondition()方法可以生成一个与当前重入锁绑定的Condition实例。利用Condition对象，可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行</p>
<p>Condition接口方法有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException;</span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">void signal();</span><br></pre></td></tr></table></figure>

<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量可以指定多个线程，同时访问某一个资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">       sync = new NonfairSync(permits);</span><br><span class="line">   &#125;</span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">       sync = fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> 在构造信号量对象时，必须要指定信号量的准入数，当每个线程每次只申请一个许可时，就相当于指定了同时可以有多少个线程可以访问某个资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public void acquire() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"> public void acquireUninterruptibly() &#123;</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"> public boolean tryAcquire() &#123;</span><br><span class="line">        return sync.nonfairTryAcquireShared(1) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">public boolean tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"> public void release() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单实例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemapDemo implements Runnable &#123;</span><br><span class="line">    final Semaphore semp = new Semaphore(5);</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            semp.acquire();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.print(Thread.currentThread().getId()+&quot;:done&quot;);</span><br><span class="line">            semp.release();</span><br><span class="line"></span><br><span class="line">        &#125;catch (InterruptedException e )&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(20);</span><br><span class="line">        final SemapDemo demo = new SemapDemo();</span><br><span class="line">        for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h5><p>​    <img src="201907160005.png" alt="32314"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class RWDictionary &#123;</span><br><span class="line"> *   private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;();</span><br><span class="line"> *   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"> *   private final Lock r = rwl.readLock();</span><br><span class="line"> *   private final Lock w = rwl.writeLock();</span><br><span class="line"> *</span><br><span class="line"> *   public Data get(String key) &#123;</span><br><span class="line"> *     r.lock();</span><br><span class="line"> *     try &#123; return m.get(key); &#125;</span><br><span class="line"> *     finally &#123; r.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public String[] allKeys() &#123;</span><br><span class="line"> *     r.lock();</span><br><span class="line"> *     try &#123; return m.keySet().toArray(); &#125;</span><br><span class="line"> *     finally &#123; r.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public Data put(String key, Data value) &#123;</span><br><span class="line"> *     w.lock();</span><br><span class="line"> *     try &#123; return m.put(key, value); &#125;</span><br><span class="line"> *     finally &#123; w.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public void clear() &#123;</span><br><span class="line"> *     w.lock();</span><br><span class="line"> *     try &#123; m.clear(); &#125;</span><br><span class="line"> *     finally &#123; w.unlock(); &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>通常用来控制线程等待，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class Driver2 &#123; // ...</span><br><span class="line"> *   void main() throws InterruptedException &#123;</span><br><span class="line"> *     CountDownLatch doneSignal = new CountDownLatch(N);</span><br><span class="line"> *     Executor e = ...</span><br><span class="line"> *</span><br><span class="line"> *     for (int i = 0; i &lt; N; ++i) // create and start threads</span><br><span class="line"> *       e.execute(new WorkerRunnable(doneSignal, i));</span><br><span class="line"> *</span><br><span class="line"> *     doneSignal.await();           // wait for all to finish</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * class WorkerRunnable implements Runnable &#123;</span><br><span class="line"> *   private final CountDownLatch doneSignal;</span><br><span class="line"> *   private final int i;</span><br><span class="line"> *   WorkerRunnable(CountDownLatch doneSignal, int i) &#123;</span><br><span class="line"> *     this.doneSignal = doneSignal;</span><br><span class="line"> *     this.i = i;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *   public void run() &#123;</span><br><span class="line"> *     try &#123;</span><br><span class="line"> *       doWork(i);</span><br><span class="line"> *       doneSignal.countDown();</span><br><span class="line"> *     &#125; catch (InterruptedException ex) &#123;&#125; // return;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   void doWork() &#123; ... &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br></pre></td></tr></table></figure>

<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>也可以实现线程间的计数等待，但是计数器可以循环使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line">* class Solver &#123;</span><br><span class="line">*   final int N;</span><br><span class="line">*   final float[][] data;</span><br><span class="line">*   final CyclicBarrier barrier;</span><br><span class="line">*</span><br><span class="line">*   class Worker implements Runnable &#123;</span><br><span class="line">*     int myRow;</span><br><span class="line">*     Worker(int row) &#123; myRow = row; &#125;</span><br><span class="line">*     public void run() &#123;</span><br><span class="line">*       while (!done()) &#123;</span><br><span class="line">*         processRow(myRow);</span><br><span class="line">*</span><br><span class="line">*         try &#123;</span><br><span class="line">*           barrier.await();</span><br><span class="line">*         &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">*           return;</span><br><span class="line">*         &#125; catch (BrokenBarrierException ex) &#123;</span><br><span class="line">*           return;</span><br><span class="line">*         &#125;</span><br><span class="line">*       &#125;</span><br><span class="line">*     &#125;</span><br><span class="line">*   &#125;</span><br><span class="line">*</span><br><span class="line">*   public Solver(float[][] matrix) &#123;</span><br><span class="line">*     data = matrix;</span><br><span class="line">*     N = matrix.length;</span><br><span class="line">*     Runnable barrierAction =</span><br><span class="line">*       new Runnable() &#123; public void run() &#123; mergeRows(...); &#125;&#125;;</span><br><span class="line">*     barrier = new CyclicBarrier(N, barrierAction);</span><br><span class="line">*</span><br><span class="line">*     List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(N);</span><br><span class="line">*     for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">*       Thread thread = new Thread(new Worker(i));</span><br><span class="line">*       threads.add(thread);</span><br><span class="line">*       thread.start();</span><br><span class="line">*     &#125;</span><br><span class="line">*</span><br><span class="line">*     // wait until done</span><br><span class="line">*     for (Thread thread : threads)</span><br><span class="line">*       thread.join();</span><br><span class="line">*   &#125;</span><br><span class="line">* &#125;&#125;&lt;/pre&gt;</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h5 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h5><p>可以在线程内任意位置让线程阻塞。和Thread。suspend相比，弥补了由于resume在前发生，导致线程无法继续执行的情况。和Object.wait相比，它不需要先获得某个对象的锁，也不会抛出InterruptedException异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class FIFOMutex &#123;</span><br><span class="line"> *   private final AtomicBoolean locked = new AtomicBoolean(false);</span><br><span class="line"> *   private final Queue&lt;Thread&gt; waiters</span><br><span class="line"> *     = new ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class="line"> *</span><br><span class="line"> *   public void lock() &#123;</span><br><span class="line"> *     boolean wasInterrupted = false;</span><br><span class="line"> *     Thread current = Thread.currentThread();</span><br><span class="line"> *     waiters.add(current);</span><br><span class="line"> *</span><br><span class="line"> *     // Block while not first in queue or cannot acquire lock</span><br><span class="line"> *     while (waiters.peek() != current ||</span><br><span class="line"> *            !locked.compareAndSet(false, true)) &#123;</span><br><span class="line"> *       LockSupport.park(this);</span><br><span class="line"> *       if (Thread.interrupted()) // ignore interrupts while waiting</span><br><span class="line"> *         wasInterrupted = true;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     waiters.remove();</span><br><span class="line"> *     if (wasInterrupted)          // reassert interrupt status on exit</span><br><span class="line"> *       current.interrupt();</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   public void unlock() &#123;</span><br><span class="line"> *     locked.set(false);</span><br><span class="line"> *     LockSupport.unpark(waiters.peek());</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>为了避免系统频繁地创建和销毁线程，可以让创建的线程进行复用</p>
<p>Executor 框架是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p>
<p>Executor 框架包括：线程池，<code>Executor，Executors，ExecutorService，CompletionService，Future，Callable</code> 等</p>
<p><img src="201907160006.png" alt="7989898"></p>
<h5 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个固定线程数量的线程池，当有一个新任务提交的时候，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个只有一个线程的线程池，若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个可根据实际情况调整线程数量的线程池。当有线程来的时候且现在线程池的线程都在工作的时候，才创建新的线程，否则使用空闲的线程，默认情况下，如果某个线程空闲超过60秒就会自动结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">        return new DelegatedScheduledExecutorService</span><br><span class="line">            (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个ScheduledExecutorService对象，线程池的大小为1，扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个ScheduledExecutorService对象，但该线程池可以指定线程数量</p>
<h5 id="ForkJoinPoll"><a href="#ForkJoinPoll" class="headerlink" title="ForkJoinPoll"></a>ForkJoinPoll</h5><p> 核心思想就是分治，Fork分解任务，Join收集数据</p>
<p>  <img src="201907160007.png" alt="12314"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CountTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">    private static final int THRESHOLD = 10000;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line"></span><br><span class="line">    public CountTask(long start , long end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long compute()&#123;</span><br><span class="line">        long sum = 0;</span><br><span class="line">        boolean canCompute = (end-start)&lt;THRESHOLD;</span><br><span class="line">        if(canCompute)&#123;</span><br><span class="line">            for(long i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //分成100个任务</span><br><span class="line">            long step = (start+end)/100;</span><br><span class="line">            ArrayList&lt;CountTask&gt; subTasks = new ArrayList&lt;&gt;();</span><br><span class="line">            long pos = start;</span><br><span class="line">            for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">                long lastOne = pos + step;</span><br><span class="line">                if(lastOne&gt;end) lastOne=end;</span><br><span class="line">                CountTask subTask = new CountTask(pos,lastOne);</span><br><span class="line">                pos+=step+1;</span><br><span class="line">                subTasks.add(subTask);</span><br><span class="line">                subTask.fork();</span><br><span class="line">            &#125;</span><br><span class="line">            for(CountTask t : subTasks)&#123;</span><br><span class="line">                sum+=t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        CountTask task = new CountTask(0,200000L);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        try&#123;</span><br><span class="line">            long res = result.get();</span><br><span class="line">            System.out.println(&quot;sum=&quot; +res);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h5><p>主要构造方法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line">     * parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line">     *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line">     * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line">     *        pool</span><br><span class="line">     * @param keepAliveTime when the number of threads is greater than</span><br><span class="line">     *        the core, this is the maximum time that excess idle threads</span><br><span class="line">     *        will wait for new tasks before terminating.</span><br><span class="line">     * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line">     * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line">     *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line">     *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line">     * @param threadFactory the factory to use when the executor</span><br><span class="line">     *        creates a new thread</span><br><span class="line">     * @param handler the handler to use when execution is blocked</span><br><span class="line">     *        because the thread bounds and queue capacities are reached</span><br><span class="line">     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line">     *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line">     * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line">     *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line">     */</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>参数workQueue指被提交但未执行的任务队列，是一个BlockingQueue接口的对象，仅用于存放Runnable对象。根据队列功能分类，可以使用的BlockingQueue有：</p>
<p> 直接提交的队列：SynchronousQueue，是一个特殊的BlockingQueue。没有容量，每一个插入都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程数量已经达到最大值则执行拒绝策略</p>
<p>有界的任务队列：ArrayBlockingQueue，当使用有界的任务队列时，若有新的任务需要执行，如何线程池的实际线程小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务，若大于maximumPoolSize则执行拒绝策略</p>
<p>无界的任务队列：LinkedBlockingQueue，与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况</p>
<p>优先任务队列：PriorityBlockingQueue， 可以根据任务自身的优先级顺序先后执行，在确保系统性能的同时，也能够很好的质量保证</p>
<h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>ThreadPoolExecutor的最后一个参数指定了拒绝策略，也就是当任务数量超过系统实际承载能力时，需要使用拒绝策略，JDK内置了四种拒绝策略</p>
<p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</p>
<p>CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中,运行当前被丢弃的任务，</p>
<p>DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务</p>
<p>DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。</p>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>减少锁持有时间，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量</p>
<p>减少锁粒度，就是缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力</p>
<p>读写分离锁来代替独占锁</p>
<p>锁分离，例如在LinkedBlockingQueue实现中，take和put函数分别实现了从队列中取得数据和往队列中增加数据功能，分别作用于队列的前端和尾端，所以可以通过takeLock和putLock两把锁</p>
<p>锁粗化，虚拟机在遇到一连串连续地对同一锁进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁粗化</p>
<h4 id="JDK内部”锁“优化策略"><a href="#JDK内部”锁“优化策略" class="headerlink" title="JDK内部”锁“优化策略"></a>JDK内部”锁“优化策略</h4><p>锁偏向:如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无须再做任何同步操作</p>
<p>轻量级锁：只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁</p>
<p>自旋锁：锁的等待者会原地忙等，不停的询问，直到获得锁。采用让当前线程不停地的在循环体内执行实现，当循环的条件被其他线程改变时才能进入临界区。</p>
<p>锁消除：Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁</p>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">    * thread-local variable.  If the variable has no value for the</span><br><span class="line">    * current thread, it is first initialized to the value returned</span><br><span class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">    *</span><br><span class="line">    * @return the current thread&apos;s value of this thread-local</span><br><span class="line">    */</span><br><span class="line">   public T get() &#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       if (map != null) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">           if (e != null) &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">     * to the specified value.  Most subclasses will have no need to</span><br><span class="line">     * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">     * method to set the values of thread-locals.</span><br><span class="line">     *</span><br><span class="line">     * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">     *        this thread-local.</span><br><span class="line">     */</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Removes the current thread&apos;s value for this thread-local</span><br><span class="line">     * variable.  If this thread-local variable is subsequently</span><br><span class="line">     * &#123;@linkplain #get read&#125; by the current thread, its value will be</span><br><span class="line">     * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span><br><span class="line">     * unless its value is &#123;@linkplain #set set&#125; by the current thread</span><br><span class="line">     * in the interim.  This may result in multiple invocations of the</span><br><span class="line">     * &#123;@code initialValue&#125; method in the current thread.</span><br><span class="line">     *</span><br><span class="line">     * @since 1.5</span><br><span class="line">     */</span><br><span class="line">     public void remove() &#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         if (m != null)</span><br><span class="line">             m.remove(this);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h5 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h5><p>AQS（AbstractQueuedSynchronizer），抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p>
<p><img src="201907160008.png" alt="312314"></p>
<p>AQS有以下几种方法：</p>
<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
</ol>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>上面是AQS定义的资源独占方式，其实还有资源共享方式，采用以下两种方法：</p>
<ol>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ol>
<h5 id="CAS（Compare-and-swap）"><a href="#CAS（Compare-and-swap）" class="headerlink" title="CAS（Compare and swap）"></a>CAS（Compare and swap）</h5><p> CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p>
<p>现在CPU内部已经执行原子的CAS操作，Java5+中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性，这会使代码运行更快。</p>
<p>Java5以来，你可以使用java.util.concurrent.atomic包中的一些原子类来使用CPU中的这些功能</p>
<p><img src="201907160009.png" alt="31231"></p>
<p>上面是一个使用AtomicBoolean类实现lock()方法的例子。</p>
<p>locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，若两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。</p>
<p>即compareAndSet()返回true，如果值被替换了，返回false。</p>
<p>CAS用于同步（乐观锁的机制就是CAS）</p>
<ol>
<li>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值  B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</li>
<li>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算</li>
</ol>
<p>CAS存在的问题：有三个，ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。<br>ABA问题：</p>
<ol>
<li>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li>
<li>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
</ol>
<p>循环时间长开销大：</p>
<ol>
<li>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
</ol>
<p>只能保证一个共享变量的原子操作：</p>
<ol>
<li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</li>
<li>这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作</li>
</ol>
<h4 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h4><p>死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间相互等待对方释放资源，产生了无限制的等待现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo extends Thread &#123;</span><br><span class="line">    protected Object tool;</span><br><span class="line">    static Object obj1 = new Object();</span><br><span class="line">    static Object obj2 = new Object();</span><br><span class="line"></span><br><span class="line">    public DeadLockDemo(Object obj)&#123;</span><br><span class="line">        this.tool=obj;</span><br><span class="line">        if(tool==obj1)&#123;</span><br><span class="line">            this.setName(&quot;哲学家A&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(tool==obj2)&#123;</span><br><span class="line">            this.setName(&quot;哲学家B&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        if(tool==obj1)&#123;</span><br><span class="line">            synchronized (obj1)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj2)&#123;</span><br><span class="line">                    System.out.println(&quot;A eat&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tool==obj2)&#123;</span><br><span class="line">            synchronized (obj2)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj1)&#123;</span><br><span class="line">                    System.out.println(&quot;B eat&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DeadLockDemo A = new DeadLockDemo(obj1);</span><br><span class="line">        DeadLockDemo B = new DeadLockDemo(obj2);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生死锁的四个必要条件： </p>
<ol>
<li><p>互斥条件：一个资源每次只能被一个进程使用。 </p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </p>
</li>
<li><p>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 </p>
</li>
<li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系</p>
</li>
</ol>
<p>如何避免死锁？ </p>
<ol>
<li><p>从死锁的四个必要条件来看，破坏其中的任意一个条件就可以避免死锁。但互斥条件是由资源本身决定的，不剥夺条件一般无法破坏，要实现的话得自己写更多的逻辑。 </p>
</li>
<li><p>避免无限期的等待：用Lock.tryLock(),wait/notify等方法写出请求一定时间后，放弃已经拥有的锁的程序。 </p>
</li>
<li><p>注意锁的顺序：以固定的顺序获取锁，可以避免死锁。 </p>
</li>
<li><p>开放调用：即只对有请求的进行封锁。你应当只想你要运行的资源获取封锁，比如在上述程序中我在封锁的完全的对象资源。但是如果我们只对它所属领域中的一个感兴趣，那我们应当封锁住那个特殊的领域而并非完全的对象。 </p>
</li>
<li><p>最后，如果能避免使用多个锁，甚至写出无锁的线程安全程序是再好不过了</p>
</li>
</ol>
<h5 id="BlockingQueue解决生产者消费者问题"><a href="#BlockingQueue解决生产者消费者问题" class="headerlink" title="BlockingQueue解决生产者消费者问题"></a>BlockingQueue解决生产者消费者问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class ProduceAndConsumerDemo &#123;</span><br><span class="line">    public static void main(String[] argd)&#123;</span><br><span class="line">        final BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(10);</span><br><span class="line">        Produce produce = new Produce(blockingQueue);</span><br><span class="line">        Consume consume = new Consume(blockingQueue);</span><br><span class="line">        produce.start();</span><br><span class="line">        consume.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Consume extends Thread&#123;</span><br><span class="line">        private final BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">        Consume(BlockingQueue&lt;Integer&gt; blockingQueue)&#123;</span><br><span class="line">            this.blockingQueue=blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Integer take = blockingQueue.take();</span><br><span class="line">                    System.out.println(&quot;consume:&quot; + take);</span><br><span class="line">                &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Produce extends Thread&#123;</span><br><span class="line">        private final BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">        Produce(BlockingQueue&lt;Integer&gt; blockingQueue)&#123;</span><br><span class="line">            this.blockingQueue=blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = new Random().nextInt(100);</span><br><span class="line">                    blockingQueue.add(i);</span><br><span class="line">                    System.out.println(&quot;produce:&quot;+ i);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用wait和notify实现生产者和消费者"><a href="#使用wait和notify实现生产者和消费者" class="headerlink" title="使用wait和notify实现生产者和消费者"></a>使用wait和notify实现生产者和消费者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class ProduceAndConsumerDemo2 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        int maxSize = 5;</span><br><span class="line">        Produce produce = new Produce(queue,maxSize);</span><br><span class="line">        Consume consume = new Consume(queue,maxSize);</span><br><span class="line">        produce.start();</span><br><span class="line">        consume.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Produce extends Thread&#123;</span><br><span class="line">        private Queue&lt;Integer&gt; queue;</span><br><span class="line">        private int maxSize;</span><br><span class="line"></span><br><span class="line">        Produce(Queue&lt;Integer&gt; queue , int maxSize)&#123;</span><br><span class="line">            this.queue = queue;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                synchronized (queue)&#123;</span><br><span class="line">                    while (queue.size()==maxSize)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;full&quot;);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int i = new Random().nextInt(100);</span><br><span class="line">                    System.out.println(&quot;produce:&quot;+ i);</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Consume extends Thread&#123;</span><br><span class="line">        private Queue&lt;Integer&gt; queue;</span><br><span class="line">        private int maxSize;</span><br><span class="line"></span><br><span class="line">        Consume(Queue&lt;Integer&gt; queue , int maxSize)&#123;</span><br><span class="line">            this.queue = queue;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                synchronized (queue)&#123;</span><br><span class="line">                    while (queue.isEmpty())&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;empty&quot;);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int i = queue.poll();</span><br><span class="line">                    System.out.println(&quot;consume:&quot;+ i);</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>《Java高并发编程详解》</p>
<p>《实战Java高并发程序设计》</p>
<p>《Java多线程编程核心技术》</p>
<p><a href="https://github.com/ZXZxin/ZXBlog/tree/master/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">https://github.com/ZXZxin/ZXBlog/tree/master/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B</a></p>
<p><a href="https://blog.csdn.net/ll666634/article/details/78615505" target="_blank" rel="noopener">https://blog.csdn.net/ll666634/article/details/78615505</a></p>
<p><a href="https://blog.csdn.net/cmyperson/article/details/79610870" target="_blank" rel="noopener">https://blog.csdn.net/cmyperson/article/details/79610870</a></p>
<script type="text/javascript" src="/js/jquery.js?v=2.0.3" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="����" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>Desire is the starting point of all achievement！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/img/weChatMoney.png" title="΢�Ŵ���" alt="΢�Ŵ���"><img src="/img/alipayMoney.png" title="֧��������" alt="֧��������"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="post-copyright"><blockquote><p>原文作者: Yang Peng</p><p>原文链接: <a href="http://ylovex.cn/2019/07/16/java多线程基础/">http://ylovex.cn/2019/07/16/java多线程基础/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/07/21/操作系统基础/" class="pre">操作系统基础</a><a href="/2019/07/13/Redis设计与实现笔记七/" class="next">Redis设计与实现笔记七</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDk3OC8yMTQ5OA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java多线程基础"><span class="toc-text">Java多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并行基础概念"><span class="toc-text">并行基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#同步和异步"><span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发与并行"><span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#临界区"><span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#死锁、饥饿、活锁"><span class="toc-text">死锁、饥饿、活锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发级别"><span class="toc-text">并发级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原子性"><span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#可见性"><span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#有序性"><span class="toc-text">有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java并行基础"><span class="toc-text">Java并行基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#进程与线程"><span class="toc-text">进程与线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程生命周期"><span class="toc-text">线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#New状态"><span class="toc-text">New状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Runnable状态"><span class="toc-text">Runnable状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Running状态"><span class="toc-text">Running状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Blocked状态"><span class="toc-text">Blocked状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dead状态"><span class="toc-text">Dead状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程基本操作"><span class="toc-text">线程基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#新建线程"><span class="toc-text">新建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#终止线程"><span class="toc-text">终止线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程中断"><span class="toc-text">线程中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait和notify"><span class="toc-text">wait和notify</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#挂起suspend和继续执行resume线程"><span class="toc-text">挂起suspend和继续执行resume线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#等待线程结束join和谦让yield"><span class="toc-text">等待线程结束join和谦让yield</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile与Java内存模型（JMM）"><span class="toc-text">volatile与Java内存模型（JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java内存模型"><span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JMM与原子性"><span class="toc-text">JMM与原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JMM与可见性"><span class="toc-text">JMM与可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JMM与有序性"><span class="toc-text">JMM与有序性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#happens-before原则"><span class="toc-text">happens-before原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#volatile原理"><span class="toc-text">volatile原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#volatile和synchronized"><span class="toc-text">volatile和synchronized</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程组"><span class="toc-text">线程组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#守护线程"><span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#synchronized使用"><span class="toc-text">synchronized使用</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK并发包"><span class="toc-text">JDK并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentranLock"><span class="toc-text">ReentranLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-text">Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#信号量"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReadWriteLock读写锁"><span class="toc-text">ReadWriteLock读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LockSupport"><span class="toc-text">LockSupport</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线程池类型"><span class="toc-text">线程池类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ForkJoinPoll"><span class="toc-text">ForkJoinPoll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ThreadPoolExecutor类"><span class="toc-text">ThreadPoolExecutor类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#拒绝策略"><span class="toc-text">拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁优化"><span class="toc-text">锁优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK内部”锁“优化策略"><span class="toc-text">JDK内部”锁“优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AQS（AbstractQueuedSynchronizer）"><span class="toc-text">AQS（AbstractQueuedSynchronizer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS（Compare-and-swap）"><span class="toc-text">CAS（Compare and swap）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁分析"><span class="toc-text">死锁分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BlockingQueue解决生产者消费者问题"><span class="toc-text">BlockingQueue解决生产者消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用wait和notify实现生产者和消费者"><span class="toc-text">使用wait和notify实现生产者和消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/23/2021年-新的起点/">2021年-新的起点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/13/LeetCode-钥匙和房间/">LeetCode-钥匙和房间</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/05/nowcoder-进制转换/">nowcoder-进制转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/Redis设计与实现笔记八/">Redis设计与实现笔记八</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/27/LeetCode-二叉树的序列化与反序列化/">LeetCode-二叉树的序列化与反序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/java基础面试题总结/">java基础面试题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/操作系统基础/">操作系统基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/16/java多线程基础/">java多线程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/Redis设计与实现笔记七/">Redis设计与实现笔记七</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/Redis设计与实现笔记六/">Redis设计与实现笔记六</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nowcoder/">nowcoder</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信号处理/">信号处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/dp/" style="font-size: 15px;">dp</a> <a href="/tags/lms/" style="font-size: 15px;">lms</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/List/" style="font-size: 15px;">List</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/遍历/" style="font-size: 15px;">遍历</a> <a href="/tags/bfs/" style="font-size: 15px;">bfs</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/单例模式/" style="font-size: 15px;">单例模式</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/yxxyyx1314" title="github" target="_blank">github</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Yang Peng.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1ec291f029f752ac2c73c4f283e80301";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>