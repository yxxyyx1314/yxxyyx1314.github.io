<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Yang Peng's blogs"><meta name="keywords" content="cs,java,go"><title>Redis设计与实现笔记八 | 人生如逆旅，我亦是行人</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis设计与实现笔记八</h1><a id="logo" href="/.">人生如逆旅，我亦是行人</a><p class="description">Desire is the starting point of all achievement</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Redis设计与实现笔记八</h1><div class="post-meta"><a href="/2019/07/30/Redis设计与实现笔记八/#comments" class="comment-count"></a><p><span class="date">Jul 30, 2019</span><span><a href="/categories/Redis/" class="category">Redis</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Redis服务器将所有的数据库都保存在服务器状态redisServer结构的db数组中，db数组的每项都是一个redisDb结构，每个redisDb结构都代表一个数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line"></span><br><span class="line">    // 数据库键空间，保存着数据库中的所有键值对</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line"></span><br><span class="line">    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line"></span><br><span class="line">    // 正处于阻塞状态的键</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</span><br><span class="line"></span><br><span class="line">    // 可以解除阻塞的键</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line"></span><br><span class="line">    // 正在被 WATCH 命令监视的键</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line"></span><br><span class="line">    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */</span><br><span class="line"></span><br><span class="line">    // 数据库号码</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line"></span><br><span class="line">    // 数据库的键的平均 TTL ，统计信息</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>初始化服务器时候，根据redisServer中的dbnum属性决定创建数据库个数，默认为16，默认情况使用0号数据库，通过SELECT命令可以切换目标数据库</p>
<p>客户端状态redisClient结构的db属性记录了客户端当前目标数据库。</p>
<h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>redisDb结构的dict属性保存了数据库中的所有键值对，</p>
<p>键空间的键也就是数据库的键，每个键都是一个字符串对象</p>
<p>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种</p>
<p><img src="201907300001.png" alt="313142"></p>
<h5 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h5><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，比如</p>
<ol>
<li>在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits keyspace_misses属性查看</li>
<li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime<key> 命令可以查看键的闲置时间</key></li>
<li>如果服务器在读取一个键时发现键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作</li>
<li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视键进行修改后，会将这个键标记为脏（dirty）从而让事务程序注意到这个键已经被修改过</li>
<li>服务器每次修改一个键后，都会对脏键计数器值增一，这个计数器会触发服务器的持久化以及复制操作</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送相应的数据库通知</li>
</ol>
<h5 id="设置键生存时间或过期时间"><a href="#设置键生存时间或过期时间" class="headerlink" title="设置键生存时间或过期时间"></a>设置键生存时间或过期时间</h5><p>有四个不同的命令可以用于设置键的生存时间或过期时间</p>
<p>EXPIRE<key><ttl> 用于将键key的生存时间设置为ttl秒</ttl></key></p>
<p>PEXPIRE<key><ttl> 用于将生存时间设置为ttl毫秒</ttl></key></p>
<p>EXPIREAT<key><timestamp> 用于将过期时间设置为timestamp所指定的秒数时间戳</timestamp></key></p>
<p>PEXPIREAT<key><timestamp> 用于将过期时间设置为timestamp所指定的毫秒数时间戳</timestamp></key></p>
<p>实际上，EXPIRE、PEXPIRE、EXPIREAT都是通过PEXPIREAT实现</p>
<p>redisDb结构的expires字典保存了数据库中所有键的过期时间</p>
<h5 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h5><p>PERSIST命令可以移除一个键的过期时间</p>
<h5 id="计算并返回过期时间"><a href="#计算并返回过期时间" class="headerlink" title="计算并返回过期时间"></a>计算并返回过期时间</h5><p>TTL命令和PTTL命令</p>
<h5 id="过期键判断"><a href="#过期键判断" class="headerlink" title="过期键判断"></a>过期键判断</h5><p>检查给定键是否存在于过期字典，如果存在那么取得键的过期时间</p>
<p>检查当前UNIX时间戳是否大于键的过期时候：如果是的话，那么键已经过期</p>
<h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键过期时机来临时，立即执行对键的删除操作</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回改建</p>
<h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。</p>
<p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡</p>
<p>惰性删除策略由db.c中的expireIfNeeded函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 检查 key 是否已经过期，如果是的话，将它从数据库中删除。</span><br><span class="line"> *</span><br><span class="line"> * 返回 0 表示键没有过期时间，或者键未过期。</span><br><span class="line"> *</span><br><span class="line"> * 返回 1 表示键已经因为过期而被删除了。</span><br><span class="line"> */</span><br><span class="line">int expireIfNeeded(redisDb *db, robj *key) &#123;</span><br><span class="line"></span><br><span class="line">    // 取出键的过期时间</span><br><span class="line">    mstime_t when = getExpire(db,key);</span><br><span class="line">    mstime_t now;</span><br><span class="line"></span><br><span class="line">    // 没有过期时间</span><br><span class="line">    if (when &lt; 0) return 0; /* No expire for this key */</span><br><span class="line"></span><br><span class="line">    /* Don&apos;t expire anything while loading. It will be done later. */</span><br><span class="line">    // 如果服务器正在进行载入，那么不进行任何过期检查</span><br><span class="line">    if (server.loading) return 0;</span><br><span class="line"></span><br><span class="line">    /* If we are in the context of a Lua script, we claim that time is</span><br><span class="line">     * blocked to when the Lua script started. This way a key can expire</span><br><span class="line">     * only the first time it is accessed and not in the middle of the</span><br><span class="line">     * script execution, making propagation to slaves / AOF consistent.</span><br><span class="line">     * See issue #1525 on Github for more information. */</span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    /* If we are running in the context of a slave, return ASAP:</span><br><span class="line">     * the slave key expiration is controlled by the master that will</span><br><span class="line">     * send us synthesized DEL operations for expired keys.</span><br><span class="line">     *</span><br><span class="line">     * Still we try to return the right information to the caller, </span><br><span class="line">     * that is, 0 if we think the key should be still valid, 1 if</span><br><span class="line">     * we think the key is expired at this time. */</span><br><span class="line">    // 当服务器运行在 replication 模式时</span><br><span class="line">    // 附属节点并不主动删除 key</span><br><span class="line">    // 它只返回一个逻辑上正确的返回值</span><br><span class="line">    // 真正的删除操作要等待主节点发来删除命令时才执行</span><br><span class="line">    // 从而保证数据的同步</span><br><span class="line">    if (server.masterhost != NULL) return now &gt; when;</span><br><span class="line"></span><br><span class="line">    // 运行到这里，表示键带有过期时间，并且服务器为主节点</span><br><span class="line"></span><br><span class="line">    /* Return when this key has not expired */</span><br><span class="line">    // 如果未过期，返回 0</span><br><span class="line">    if (now &lt;= when) return 0;</span><br><span class="line"></span><br><span class="line">    /* Delete the key */</span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line"></span><br><span class="line">    // 向 AOF 文件和附属节点传播过期信息</span><br><span class="line">    propagateExpire(db,key);</span><br><span class="line"></span><br><span class="line">    // 发送事件通知</span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</span><br><span class="line">        &quot;expired&quot;,key,db-&gt;id);</span><br><span class="line"></span><br><span class="line">    // 将过期键从数据库中删除</span><br><span class="line">    return dbDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="201907300002.png" alt="31214"></p>
<p>定期删除策略由redis.c中的activeExpireCycle实现，每当Redis服务器周期性操作redis.c/serverCron函数时，activeExpireCycle函数就会被调用，它在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expire字典中随机检查一部分键的过期时间并删除其中过期键</p>
<h4 id="AOF、RDB和复制功能对过期键处理"><a href="#AOF、RDB和复制功能对过期键处理" class="headerlink" title="AOF、RDB和复制功能对过期键处理"></a>AOF、RDB和复制功能对过期键处理</h4><h5 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h5><p>在执行SAVE命令或者BGSAVE命令创建一个新RDB文件，程序会对数据库中的键进行检查，已经过期键不会被保存到新创建的RDB文件中</p>
<h5 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h5><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入</p>
<p>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，过期键被忽略</p>
<p>如果服务器以从服务器运行，所有键都会载入。</p>
<h5 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h5><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键产生任何影响</p>
<p>当过期键被惰性删除后，程序会向AOF文件追加一条DEL命令，来显示地记录该键已被删除</p>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中</p>
<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键</p>
<p>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期的键删除，而是继续像处理未过期的键一样来处理过期键</p>
<p>从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键</p>
<h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变换，以及数据库中命令的执行情况\</p>
<p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* The API provided to the rest of the Redis core is a simple function:</span><br><span class="line"> *</span><br><span class="line"> * notifyKeyspaceEvent(char *event, robj *key, int dbid);</span><br><span class="line"> *</span><br><span class="line"> * &apos;event&apos; is a C string representing the event name.</span><br><span class="line"> *</span><br><span class="line"> * event 参数是一个字符串表示的事件名</span><br><span class="line"> *</span><br><span class="line"> * &apos;key&apos; is a Redis object representing the key name.</span><br><span class="line"> *</span><br><span class="line"> * key 参数是一个 Redis 对象表示的键名</span><br><span class="line"> *</span><br><span class="line"> * &apos;dbid&apos; is the database ID where the key lives.  </span><br><span class="line"> *</span><br><span class="line"> * dbid 参数为键所在的数据库</span><br><span class="line"> */</span><br><span class="line">void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) &#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    int len = -1;</span><br><span class="line">    char buf[24];</span><br><span class="line"></span><br><span class="line">    /* If notifications for this class of events are off, return ASAP. */</span><br><span class="line">    // 如果服务器配置为不发送 type 类型的通知，那么直接返回</span><br><span class="line">    if (!(server.notify_keyspace_events &amp; type)) return;</span><br><span class="line"></span><br><span class="line">    // 事件的名字</span><br><span class="line">    eventobj = createStringObject(event,strlen(event));</span><br><span class="line"></span><br><span class="line">    /* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span><br><span class="line">    // 发送键空间通知</span><br><span class="line">    if (server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE) &#123;</span><br><span class="line"></span><br><span class="line">        // 构建频道对象</span><br><span class="line">        chan = sdsnewlen(&quot;__keyspace@&quot;,11);</span><br><span class="line">        len = ll2string(buf,sizeof(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, &quot;__:&quot;, 3);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">        chanobj = createObject(REDIS_STRING, chan);</span><br><span class="line"></span><br><span class="line">        // 通过 publish 命令发送通知</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line"></span><br><span class="line">        // 释放频道对象</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* __keyevente@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span><br><span class="line">    // 发送键事件通知</span><br><span class="line">    if (server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT) &#123;</span><br><span class="line"></span><br><span class="line">        // 构建频道对象</span><br><span class="line">        chan = sdsnewlen(&quot;__keyevent@&quot;,11);</span><br><span class="line">        // 如果在前面发送键空间通知的时候计算了 len ，那么它就不会是 -1</span><br><span class="line">        // 这可以避免计算两次 buf 的长度</span><br><span class="line">        if (len == -1) len = ll2string(buf,sizeof(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, &quot;__:&quot;, 3);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line"></span><br><span class="line">        chanobj = createObject(REDIS_STRING, chan);</span><br><span class="line"></span><br><span class="line">        // 通过 publish 命令发送通知</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line"></span><br><span class="line">        // 释放频道对象</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 释放事件对象</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="redisServer结构"><a href="#redisServer结构" class="headerlink" title="redisServer结构"></a>redisServer结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line"></span><br><span class="line">    /* General */</span><br><span class="line"></span><br><span class="line">    // 配置文件的绝对路径</span><br><span class="line">    char *configfile;           /* Absolute config file path, or NULL */</span><br><span class="line"></span><br><span class="line">    // serverCron() 每秒调用的次数</span><br><span class="line">    int hz;                     /* serverCron() calls frequency in hertz */</span><br><span class="line"></span><br><span class="line">    // 数据库</span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    // 命令表（受到 rename 配置选项的作用）</span><br><span class="line">    dict *commands;             /* Command table */</span><br><span class="line">    // 命令表（无 rename 配置选项的作用）</span><br><span class="line">    dict *orig_commands;        /* Command table before command renaming. */</span><br><span class="line"></span><br><span class="line">    // 事件状态</span><br><span class="line">    aeEventLoop *el;</span><br><span class="line"></span><br><span class="line">    // 最近一次使用时钟</span><br><span class="line">    unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */</span><br><span class="line"></span><br><span class="line">    // 关闭服务器的标识</span><br><span class="line">    int shutdown_asap;          /* SHUTDOWN needed ASAP */</span><br><span class="line"></span><br><span class="line">    // 在执行 serverCron() 时进行渐进式 rehash</span><br><span class="line">    int activerehashing;        /* Incremental rehash in serverCron() */</span><br><span class="line"></span><br><span class="line">    // 是否设置了密码</span><br><span class="line">    char *requirepass;          /* Pass for AUTH command, or NULL */</span><br><span class="line"></span><br><span class="line">    // PID 文件</span><br><span class="line">    char *pidfile;              /* PID file path */</span><br><span class="line"></span><br><span class="line">    // 架构类型</span><br><span class="line">    int arch_bits;              /* 32 or 64 depending on sizeof(long) */</span><br><span class="line"></span><br><span class="line">    // serverCron() 函数的运行次数计数器</span><br><span class="line">    int cronloops;              /* Number of times the cron function run */</span><br><span class="line"></span><br><span class="line">    // 本服务器的 RUN ID</span><br><span class="line">    char runid[REDIS_RUN_ID_SIZE+1];  /* ID always different at every exec. */</span><br><span class="line"></span><br><span class="line">    // 服务器是否运行在 SENTINEL 模式</span><br><span class="line">    int sentinel_mode;          /* True if this instance is a Sentinel. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Networking */</span><br><span class="line"></span><br><span class="line">    // TCP 监听端口</span><br><span class="line">    int port;                   /* TCP listening port */</span><br><span class="line"></span><br><span class="line">    int tcp_backlog;            /* TCP listen() backlog */</span><br><span class="line"></span><br><span class="line">    // 地址</span><br><span class="line">    char *bindaddr[REDIS_BINDADDR_MAX]; /* Addresses we should bind to */</span><br><span class="line">    // 地址数量</span><br><span class="line">    int bindaddr_count;         /* Number of addresses in server.bindaddr[] */</span><br><span class="line"></span><br><span class="line">    // UNIX 套接字</span><br><span class="line">    char *unixsocket;           /* UNIX socket path */</span><br><span class="line">    mode_t unixsocketperm;      /* UNIX socket permission */</span><br><span class="line"></span><br><span class="line">    // 描述符</span><br><span class="line">    int ipfd[REDIS_BINDADDR_MAX]; /* TCP socket file descriptors */</span><br><span class="line">    // 描述符数量</span><br><span class="line">    int ipfd_count;             /* Used slots in ipfd[] */</span><br><span class="line"></span><br><span class="line">    // UNIX 套接字文件描述符</span><br><span class="line">    int sofd;                   /* Unix socket file descriptor */</span><br><span class="line"></span><br><span class="line">    int cfd[REDIS_BINDADDR_MAX];/* Cluster bus listening socket */</span><br><span class="line">    int cfd_count;              /* Used slots in cfd[] */</span><br><span class="line"></span><br><span class="line">    // 一个链表，保存了所有客户端状态结构</span><br><span class="line">    list *clients;              /* List of active clients */</span><br><span class="line">    // 链表，保存了所有待关闭的客户端</span><br><span class="line">    list *clients_to_close;     /* Clients to close asynchronously */</span><br><span class="line"></span><br><span class="line">    // 链表，保存了所有从服务器，以及所有监视器</span><br><span class="line">    list *slaves, *monitors;    /* List of slaves and MONITORs */</span><br><span class="line"></span><br><span class="line">    // 服务器的当前客户端，仅用于崩溃报告</span><br><span class="line">    redisClient *current_client; /* Current client, only used on crash report */</span><br><span class="line"></span><br><span class="line">    int clients_paused;         /* True if clients are currently paused */</span><br><span class="line">    mstime_t clients_pause_end_time; /* Time when we undo clients_paused */</span><br><span class="line"></span><br><span class="line">    // 网络错误</span><br><span class="line">    char neterr[ANET_ERR_LEN];   /* Error buffer for anet.c */</span><br><span class="line"></span><br><span class="line">    // MIGRATE 缓存</span><br><span class="line">    dict *migrate_cached_sockets;/* MIGRATE cached sockets */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* RDB / AOF loading information */</span><br><span class="line"></span><br><span class="line">    // 这个值为真时，表示服务器正在进行载入</span><br><span class="line">    int loading;                /* We are loading data from disk if true */</span><br><span class="line"></span><br><span class="line">    // 正在载入的数据的大小</span><br><span class="line">    off_t loading_total_bytes;</span><br><span class="line"></span><br><span class="line">    // 已载入数据的大小</span><br><span class="line">    off_t loading_loaded_bytes;</span><br><span class="line"></span><br><span class="line">    // 开始进行载入的时间</span><br><span class="line">    time_t loading_start_time;</span><br><span class="line">    off_t loading_process_events_interval_bytes;</span><br><span class="line"></span><br><span class="line">    /* Fast pointers to often looked up command */</span><br><span class="line">    // 常用命令的快捷连接</span><br><span class="line">    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,</span><br><span class="line">                        *rpopCommand;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Fields used only for stats */</span><br><span class="line"></span><br><span class="line">    // 服务器启动时间</span><br><span class="line">    time_t stat_starttime;          /* Server start time */</span><br><span class="line"></span><br><span class="line">    // 已处理命令的数量</span><br><span class="line">    long long stat_numcommands;     /* Number of processed commands */</span><br><span class="line"></span><br><span class="line">    // 服务器接到的连接请求数量</span><br><span class="line">    long long stat_numconnections;  /* Number of connections received */</span><br><span class="line"></span><br><span class="line">    // 已过期的键数量</span><br><span class="line">    long long stat_expiredkeys;     /* Number of expired keys */</span><br><span class="line"></span><br><span class="line">    // 因为回收内存而被释放的过期键的数量</span><br><span class="line">    long long stat_evictedkeys;     /* Number of evicted keys (maxmemory) */</span><br><span class="line"></span><br><span class="line">    // 成功查找键的次数</span><br><span class="line">    long long stat_keyspace_hits;   /* Number of successful lookups of keys */</span><br><span class="line"></span><br><span class="line">    // 查找键失败的次数</span><br><span class="line">    long long stat_keyspace_misses; /* Number of failed lookups of keys */</span><br><span class="line"></span><br><span class="line">    // 已使用内存峰值</span><br><span class="line">    size_t stat_peak_memory;        /* Max used memory record */</span><br><span class="line"></span><br><span class="line">    // 最后一次执行 fork() 时消耗的时间</span><br><span class="line">    long long stat_fork_time;       /* Time needed to perform latest fork() */</span><br><span class="line"></span><br><span class="line">    // 服务器因为客户端数量过多而拒绝客户端连接的次数</span><br><span class="line">    long long stat_rejected_conn;   /* Clients rejected because of maxclients */</span><br><span class="line"></span><br><span class="line">    // 执行 full sync 的次数</span><br><span class="line">    long long stat_sync_full;       /* Number of full resyncs with slaves. */</span><br><span class="line"></span><br><span class="line">    // PSYNC 成功执行的次数</span><br><span class="line">    long long stat_sync_partial_ok; /* Number of accepted PSYNC requests. */</span><br><span class="line"></span><br><span class="line">    // PSYNC 执行失败的次数</span><br><span class="line">    long long stat_sync_partial_err;/* Number of unaccepted PSYNC requests. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* slowlog */</span><br><span class="line"></span><br><span class="line">    // 保存了所有慢查询日志的链表</span><br><span class="line">    list *slowlog;                  /* SLOWLOG list of commands */</span><br><span class="line"></span><br><span class="line">    // 下一条慢查询日志的 ID</span><br><span class="line">    long long slowlog_entry_id;     /* SLOWLOG current entry ID */</span><br><span class="line"></span><br><span class="line">    // 服务器配置 slowlog-log-slower-than 选项的值</span><br><span class="line">    long long slowlog_log_slower_than; /* SLOWLOG time limit (to get logged) */</span><br><span class="line"></span><br><span class="line">    // 服务器配置 slowlog-max-len 选项的值</span><br><span class="line">    unsigned long slowlog_max_len;     /* SLOWLOG max number of items logged */</span><br><span class="line">    size_t resident_set_size;       /* RSS sampled in serverCron(). */</span><br><span class="line">    /* The following two are used to track instantaneous &quot;load&quot; in terms</span><br><span class="line">     * of operations per second. */</span><br><span class="line">    // 最后一次进行抽样的时间</span><br><span class="line">    long long ops_sec_last_sample_time; /* Timestamp of last sample (in ms) */</span><br><span class="line">    // 最后一次抽样时，服务器已执行命令的数量</span><br><span class="line">    long long ops_sec_last_sample_ops;  /* numcommands in last sample */</span><br><span class="line">    // 抽样结果</span><br><span class="line">    long long ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    // 数组索引，用于保存抽样结果，并在需要时回绕到 0</span><br><span class="line">    int ops_sec_idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Configuration */</span><br><span class="line"></span><br><span class="line">    // 日志可见性</span><br><span class="line">    int verbosity;                  /* Loglevel in redis.conf */</span><br><span class="line"></span><br><span class="line">    // 客户端最大空转时间</span><br><span class="line">    int maxidletime;                /* Client timeout in seconds */</span><br><span class="line"></span><br><span class="line">    // 是否开启 SO_KEEPALIVE 选项</span><br><span class="line">    int tcpkeepalive;               /* Set SO_KEEPALIVE if non-zero. */</span><br><span class="line">    int active_expire_enabled;      /* Can be disabled for testing purposes. */</span><br><span class="line">    size_t client_max_querybuf_len; /* Limit for client query buffer length */</span><br><span class="line">    int dbnum;                      /* Total number of configured DBs */</span><br><span class="line">    int daemonize;                  /* True if running as a daemon */</span><br><span class="line">    // 客户端输出缓冲区大小限制</span><br><span class="line">    // 数组的元素有 REDIS_CLIENT_LIMIT_NUM_CLASSES 个</span><br><span class="line">    // 每个代表一类客户端：普通、从服务器、pubsub，诸如此类</span><br><span class="line">    clientBufferLimitsConfig client_obuf_limits[REDIS_CLIENT_LIMIT_NUM_CLASSES];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* AOF persistence */</span><br><span class="line"></span><br><span class="line">    // AOF 状态（开启/关闭/可写）</span><br><span class="line">    int aof_state;                  /* REDIS_AOF_(ON|OFF|WAIT_REWRITE) */</span><br><span class="line"></span><br><span class="line">    // 所使用的 fsync 策略（每个写入/每秒/从不）</span><br><span class="line">    int aof_fsync;                  /* Kind of fsync() policy */</span><br><span class="line">    char *aof_filename;             /* Name of the AOF file */</span><br><span class="line">    int aof_no_fsync_on_rewrite;    /* Don&apos;t fsync if a rewrite is in prog. */</span><br><span class="line">    int aof_rewrite_perc;           /* Rewrite AOF if % growth is &gt; M and... */</span><br><span class="line">    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */</span><br><span class="line"></span><br><span class="line">    // 最后一次执行 BGREWRITEAOF 时， AOF 文件的大小</span><br><span class="line">    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */</span><br><span class="line"></span><br><span class="line">    // AOF 文件的当前字节大小</span><br><span class="line">    off_t aof_current_size;         /* AOF current size. */</span><br><span class="line">    int aof_rewrite_scheduled;      /* Rewrite once BGSAVE terminates. */</span><br><span class="line"></span><br><span class="line">    // 负责进行 AOF 重写的子进程 ID</span><br><span class="line">    pid_t aof_child_pid;            /* PID if rewriting process */</span><br><span class="line"></span><br><span class="line">    // AOF 重写缓存链表，链接着多个缓存块</span><br><span class="line">    list *aof_rewrite_buf_blocks;   /* Hold changes during an AOF rewrite. */</span><br><span class="line"></span><br><span class="line">    // AOF 缓冲区</span><br><span class="line">    sds aof_buf;      /* AOF buffer, written before entering the event loop */</span><br><span class="line"></span><br><span class="line">    // AOF 文件的描述符</span><br><span class="line">    int aof_fd;       /* File descriptor of currently selected AOF file */</span><br><span class="line"></span><br><span class="line">    // AOF 的当前目标数据库</span><br><span class="line">    int aof_selected_db; /* Currently selected DB in AOF */</span><br><span class="line"></span><br><span class="line">    // 推迟 write 操作的时间</span><br><span class="line">    time_t aof_flush_postponed_start; /* UNIX time of postponed AOF flush */</span><br><span class="line"></span><br><span class="line">    // 最后一直执行 fsync 的时间</span><br><span class="line">    time_t aof_last_fsync;            /* UNIX time of last fsync() */</span><br><span class="line">    time_t aof_rewrite_time_last;   /* Time used by last AOF rewrite run. */</span><br><span class="line"></span><br><span class="line">    // AOF 重写的开始时间</span><br><span class="line">    time_t aof_rewrite_time_start;  /* Current AOF rewrite start time. */</span><br><span class="line"></span><br><span class="line">    // 最后一次执行 BGREWRITEAOF 的结果</span><br><span class="line">    int aof_lastbgrewrite_status;   /* REDIS_OK or REDIS_ERR */</span><br><span class="line"></span><br><span class="line">    // 记录 AOF 的 write 操作被推迟了多少次</span><br><span class="line">    unsigned long aof_delayed_fsync;  /* delayed AOF fsync() counter */</span><br><span class="line"></span><br><span class="line">    // 指示是否需要每写入一定量的数据，就主动执行一次 fsync()</span><br><span class="line">    int aof_rewrite_incremental_fsync;/* fsync incrementally while rewriting? */</span><br><span class="line">    int aof_last_write_status;      /* REDIS_OK or REDIS_ERR */</span><br><span class="line">    int aof_last_write_errno;       /* Valid if aof_last_write_status is ERR */</span><br><span class="line">    /* RDB persistence */</span><br><span class="line"></span><br><span class="line">    // 自从上次 SAVE 执行以来，数据库被修改的次数</span><br><span class="line">    long long dirty;                /* Changes to DB from the last save */</span><br><span class="line"></span><br><span class="line">    // BGSAVE 执行前的数据库被修改次数</span><br><span class="line">    long long dirty_before_bgsave;  /* Used to restore dirty on failed BGSAVE */</span><br><span class="line"></span><br><span class="line">    // 负责执行 BGSAVE 的子进程的 ID</span><br><span class="line">    // 没在执行 BGSAVE 时，设为 -1</span><br><span class="line">    pid_t rdb_child_pid;            /* PID of RDB saving child */</span><br><span class="line">    struct saveparam *saveparams;   /* Save points array for RDB */</span><br><span class="line">    int saveparamslen;              /* Number of saving points */</span><br><span class="line">    char *rdb_filename;             /* Name of RDB file */</span><br><span class="line">    int rdb_compression;            /* Use compression in RDB? */</span><br><span class="line">    int rdb_checksum;               /* Use RDB checksum? */</span><br><span class="line"></span><br><span class="line">    // 最后一次完成 SAVE 的时间</span><br><span class="line">    time_t lastsave;                /* Unix time of last successful save */</span><br><span class="line"></span><br><span class="line">    // 最后一次尝试执行 BGSAVE 的时间</span><br><span class="line">    time_t lastbgsave_try;          /* Unix time of last attempted bgsave */</span><br><span class="line"></span><br><span class="line">    // 最近一次 BGSAVE 执行耗费的时间</span><br><span class="line">    time_t rdb_save_time_last;      /* Time used by last RDB save run. */</span><br><span class="line"></span><br><span class="line">    // 数据库最近一次开始执行 BGSAVE 的时间</span><br><span class="line">    time_t rdb_save_time_start;     /* Current RDB save start time. */</span><br><span class="line"></span><br><span class="line">    // 最后一次执行 SAVE 的状态</span><br><span class="line">    int lastbgsave_status;          /* REDIS_OK or REDIS_ERR */</span><br><span class="line">    int stop_writes_on_bgsave_err;  /* Don&apos;t allow writes if can&apos;t BGSAVE */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Propagation of commands in AOF / replication */</span><br><span class="line">    redisOpArray also_propagate;    /* Additional command to propagate. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Logging */</span><br><span class="line">    char *logfile;                  /* Path of log file */</span><br><span class="line">    int syslog_enabled;             /* Is syslog enabled? */</span><br><span class="line">    char *syslog_ident;             /* Syslog ident */</span><br><span class="line">    int syslog_facility;            /* Syslog facility */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Replication (master) */</span><br><span class="line">    int slaveseldb;                 /* Last SELECTed DB in replication output */</span><br><span class="line">    // 全局复制偏移量（一个累计值）</span><br><span class="line">    long long master_repl_offset;   /* Global replication offset */</span><br><span class="line">    // 主服务器发送 PING 的频率</span><br><span class="line">    int repl_ping_slave_period;     /* Master pings the slave every N seconds */</span><br><span class="line"></span><br><span class="line">    // backlog 本身</span><br><span class="line">    char *repl_backlog;             /* Replication backlog for partial syncs */</span><br><span class="line">    // backlog 的长度</span><br><span class="line">    long long repl_backlog_size;    /* Backlog circular buffer size */</span><br><span class="line">    // backlog 中数据的长度</span><br><span class="line">    long long repl_backlog_histlen; /* Backlog actual data length */</span><br><span class="line">    // backlog 的当前索引</span><br><span class="line">    long long repl_backlog_idx;     /* Backlog circular buffer current offset */</span><br><span class="line">    // backlog 中可以被还原的第一个字节的偏移量</span><br><span class="line">    long long repl_backlog_off;     /* Replication offset of first byte in the</span><br><span class="line">                                       backlog buffer. */</span><br><span class="line">    // backlog 的过期时间</span><br><span class="line">    time_t repl_backlog_time_limit; /* Time without slaves after the backlog</span><br><span class="line">                                       gets released. */</span><br><span class="line"></span><br><span class="line">    // 距离上一次有从服务器的时间</span><br><span class="line">    time_t repl_no_slaves_since;    /* We have no slaves since that time.</span><br><span class="line">                                       Only valid if server.slaves len is 0. */</span><br><span class="line"></span><br><span class="line">    // 是否开启最小数量从服务器写入功能</span><br><span class="line">    int repl_min_slaves_to_write;   /* Min number of slaves to write. */</span><br><span class="line">    // 定义最小数量从服务器的最大延迟值</span><br><span class="line">    int repl_min_slaves_max_lag;    /* Max lag of &lt;count&gt; slaves to write. */</span><br><span class="line">    // 延迟良好的从服务器的数量</span><br><span class="line">    int repl_good_slaves_count;     /* Number of slaves with lag &lt;= max_lag. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Replication (slave) */</span><br><span class="line">    // 主服务器的验证密码</span><br><span class="line">    char *masterauth;               /* AUTH with this password with master */</span><br><span class="line">    // 主服务器的地址</span><br><span class="line">    char *masterhost;               /* Hostname of master */</span><br><span class="line">    // 主服务器的端口</span><br><span class="line">    int masterport;                 /* Port of master */</span><br><span class="line">    // 超时时间</span><br><span class="line">    int repl_timeout;               /* Timeout after N seconds of master idle */</span><br><span class="line">    // 主服务器所对应的客户端</span><br><span class="line">    redisClient *master;     /* Client that is master for this slave */</span><br><span class="line">    // 被缓存的主服务器，PSYNC 时使用</span><br><span class="line">    redisClient *cached_master; /* Cached master to be reused for PSYNC. */</span><br><span class="line">    int repl_syncio_timeout; /* Timeout for synchronous I/O calls */</span><br><span class="line">    // 复制的状态（服务器是从服务器时使用）</span><br><span class="line">    int repl_state;          /* Replication status if the instance is a slave */</span><br><span class="line">    // RDB 文件的大小</span><br><span class="line">    off_t repl_transfer_size; /* Size of RDB to read from master during sync. */</span><br><span class="line">    // 已读 RDB 文件内容的字节数</span><br><span class="line">    off_t repl_transfer_read; /* Amount of RDB read from master during sync. */</span><br><span class="line">    // 最近一次执行 fsync 时的偏移量</span><br><span class="line">    // 用于 sync_file_range 函数</span><br><span class="line">    off_t repl_transfer_last_fsync_off; /* Offset when we fsync-ed last time. */</span><br><span class="line">    // 主服务器的套接字</span><br><span class="line">    int repl_transfer_s;     /* Slave -&gt; Master SYNC socket */</span><br><span class="line">    // 保存 RDB 文件的临时文件的描述符</span><br><span class="line">    int repl_transfer_fd;    /* Slave -&gt; Master SYNC temp file descriptor */</span><br><span class="line">    // 保存 RDB 文件的临时文件名字</span><br><span class="line">    char *repl_transfer_tmpfile; /* Slave-&gt; master SYNC temp file name */</span><br><span class="line">    // 最近一次读入 RDB 内容的时间</span><br><span class="line">    time_t repl_transfer_lastio; /* Unix time of the latest read, for timeout */</span><br><span class="line">    int repl_serve_stale_data; /* Serve stale data when link is down? */</span><br><span class="line">    // 是否只读从服务器？</span><br><span class="line">    int repl_slave_ro;          /* Slave is read only? */</span><br><span class="line">    // 连接断开的时长</span><br><span class="line">    time_t repl_down_since; /* Unix time at which link with master went down */</span><br><span class="line">    // 是否要在 SYNC 之后关闭 NODELAY ？</span><br><span class="line">    int repl_disable_tcp_nodelay;   /* Disable TCP_NODELAY after SYNC? */</span><br><span class="line">    // 从服务器优先级</span><br><span class="line">    int slave_priority;             /* Reported in INFO and used by Sentinel. */</span><br><span class="line">    // 本服务器（从服务器）当前主服务器的 RUN ID</span><br><span class="line">    char repl_master_runid[REDIS_RUN_ID_SIZE+1];  /* Master run id for PSYNC. */</span><br><span class="line">    // 初始化偏移量</span><br><span class="line">    long long repl_master_initial_offset;         /* Master PSYNC offset. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Replication script cache. */</span><br><span class="line">    // 复制脚本缓存</span><br><span class="line">    // 字典</span><br><span class="line">    dict *repl_scriptcache_dict;        /* SHA1 all slaves are aware of. */</span><br><span class="line">    // FIFO 队列</span><br><span class="line">    list *repl_scriptcache_fifo;        /* First in, first out LRU eviction. */</span><br><span class="line">    // 缓存的大小</span><br><span class="line">    int repl_scriptcache_size;          /* Max number of elements. */</span><br><span class="line"></span><br><span class="line">    /* Synchronous replication. */</span><br><span class="line">    list *clients_waiting_acks;         /* Clients waiting in WAIT command. */</span><br><span class="line">    int get_ack_from_slaves;            /* If true we send REPLCONF GETACK. */</span><br><span class="line">    /* Limits */</span><br><span class="line">    int maxclients;                 /* Max number of simultaneous clients */</span><br><span class="line">    unsigned long long maxmemory;   /* Max number of memory bytes to use */</span><br><span class="line">    int maxmemory_policy;           /* Policy for key eviction */</span><br><span class="line">    int maxmemory_samples;          /* Pricision of random sampling */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Blocked clients */</span><br><span class="line">    unsigned int bpop_blocked_clients; /* Number of clients blocked by lists */</span><br><span class="line">    list *unblocked_clients; /* list of clients to unblock before next loop */</span><br><span class="line">    list *ready_keys;        /* List of readyList structures for BLPOP &amp; co */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Sort parameters - qsort_r() is only available under BSD so we</span><br><span class="line">     * have to take this state global, in order to pass it to sortCompare() */</span><br><span class="line">    int sort_desc;</span><br><span class="line">    int sort_alpha;</span><br><span class="line">    int sort_bypattern;</span><br><span class="line">    int sort_store;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Zip structure config, see redis.conf for more information  */</span><br><span class="line">    size_t hash_max_ziplist_entries;</span><br><span class="line">    size_t hash_max_ziplist_value;</span><br><span class="line">    size_t list_max_ziplist_entries;</span><br><span class="line">    size_t list_max_ziplist_value;</span><br><span class="line">    size_t set_max_intset_entries;</span><br><span class="line">    size_t zset_max_ziplist_entries;</span><br><span class="line">    size_t zset_max_ziplist_value;</span><br><span class="line">    size_t hll_sparse_max_bytes;</span><br><span class="line">    time_t unixtime;        /* Unix time sampled every cron cycle. */</span><br><span class="line">    long long mstime;       /* Like &apos;unixtime&apos; but with milliseconds resolution. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Pubsub */</span><br><span class="line">    // 字典，键为频道，值为链表</span><br><span class="line">    // 链表中保存了所有订阅某个频道的客户端</span><br><span class="line">    // 新客户端总是被添加到链表的表尾</span><br><span class="line">    dict *pubsub_channels;  /* Map channels to list of subscribed clients */</span><br><span class="line"></span><br><span class="line">    // 这个链表记录了客户端订阅的所有模式的名字</span><br><span class="line">    list *pubsub_patterns;  /* A list of pubsub_patterns */</span><br><span class="line"></span><br><span class="line">    int notify_keyspace_events; /* Events to propagate via Pub/Sub. This is an</span><br><span class="line">                                   xor of REDIS_NOTIFY... flags. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Cluster */</span><br><span class="line"></span><br><span class="line">    int cluster_enabled;      /* Is cluster enabled? */</span><br><span class="line">    mstime_t cluster_node_timeout; /* Cluster node timeout. */</span><br><span class="line">    char *cluster_configfile; /* Cluster auto-generated config file name. */</span><br><span class="line">    struct clusterState *cluster;  /* State of the cluster */</span><br><span class="line"></span><br><span class="line">    int cluster_migration_barrier; /* Cluster replicas migration barrier. */</span><br><span class="line">    /* Scripting */</span><br><span class="line"></span><br><span class="line">    // Lua 环境</span><br><span class="line">    lua_State *lua; /* The Lua interpreter. We use just one for all clients */</span><br><span class="line">    </span><br><span class="line">    // 复制执行 Lua 脚本中的 Redis 命令的伪客户端</span><br><span class="line">    redisClient *lua_client;   /* The &quot;fake client&quot; to query Redis from Lua */</span><br><span class="line"></span><br><span class="line">    // 当前正在执行 EVAL 命令的客户端，如果没有就是 NULL</span><br><span class="line">    redisClient *lua_caller;   /* The client running EVAL right now, or NULL */</span><br><span class="line"></span><br><span class="line">    // 一个字典，值为 Lua 脚本，键为脚本的 SHA1 校验和</span><br><span class="line">    dict *lua_scripts;         /* A dictionary of SHA1 -&gt; Lua scripts */</span><br><span class="line">    // Lua 脚本的执行时限</span><br><span class="line">    mstime_t lua_time_limit;  /* Script timeout in milliseconds */</span><br><span class="line">    // 脚本开始执行的时间</span><br><span class="line">    mstime_t lua_time_start;  /* Start time of script, milliseconds time */</span><br><span class="line"></span><br><span class="line">    // 脚本是否执行过写命令</span><br><span class="line">    int lua_write_dirty;  /* True if a write command was called during the</span><br><span class="line">                             execution of the current script. */</span><br><span class="line"></span><br><span class="line">    // 脚本是否执行过带有随机性质的命令</span><br><span class="line">    int lua_random_dirty; /* True if a random command was called during the</span><br><span class="line">                             execution of the current script. */</span><br><span class="line"></span><br><span class="line">    // 脚本是否超时</span><br><span class="line">    int lua_timedout;     /* True if we reached the time limit for script</span><br><span class="line">                             execution. */</span><br><span class="line"></span><br><span class="line">    // 是否要杀死脚本</span><br><span class="line">    int lua_kill;         /* Kill the script if true. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Assert &amp; bug reporting */</span><br><span class="line"></span><br><span class="line">    char *assert_failed;</span><br><span class="line">    char *assert_file;</span><br><span class="line">    int assert_line;</span><br><span class="line">    int bug_report_start; /* True if bug report header was already logged. */</span><br><span class="line">    int watchdog_period;  /* Software watchdog period in ms. 0 = off */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="/js/jquery.js?v=2.0.3" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="����" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>Desire is the starting point of all achievement！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/img/weChatMoney.png" title="΢�Ŵ���" alt="΢�Ŵ���"><img src="/img/alipayMoney.png" title="֧��������" alt="֧��������"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="post-copyright"><blockquote><p>原文作者: Yang Peng</p><p>原文链接: <a href="http://ylovex.cn/2019/07/30/Redis设计与实现笔记八/">http://ylovex.cn/2019/07/30/Redis设计与实现笔记八/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/05/nowcoder-进制转换/" class="pre">nowcoder-进制转换</a><a href="/2019/07/27/LeetCode-二叉树的序列化与反序列化/" class="next">LeetCode-二叉树的序列化与反序列化</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDk3OC8yMTQ5OA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库键空间"><span class="toc-text">数据库键空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#读写键空间时的维护操作"><span class="toc-text">读写键空间时的维护操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置键生存时间或过期时间"><span class="toc-text">设置键生存时间或过期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#移除过期时间"><span class="toc-text">移除过期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#计算并返回过期时间"><span class="toc-text">计算并返回过期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#过期键判断"><span class="toc-text">过期键判断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#过期键删除策略"><span class="toc-text">过期键删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定时删除"><span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#惰性删除"><span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定期删除"><span class="toc-text">定期删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF、RDB和复制功能对过期键处理"><span class="toc-text">AOF、RDB和复制功能对过期键处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#生成RDB文件"><span class="toc-text">生成RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#载入RDB文件"><span class="toc-text">载入RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF文件写入"><span class="toc-text">AOF文件写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF重写"><span class="toc-text">AOF重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#复制"><span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库通知"><span class="toc-text">数据库通知</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redisServer结构"><span class="toc-text">redisServer结构</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/23/2021年-新的起点/">2021年-新的起点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/13/LeetCode-钥匙和房间/">LeetCode-钥匙和房间</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/05/nowcoder-进制转换/">nowcoder-进制转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/Redis设计与实现笔记八/">Redis设计与实现笔记八</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/27/LeetCode-二叉树的序列化与反序列化/">LeetCode-二叉树的序列化与反序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/java基础面试题总结/">java基础面试题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/操作系统基础/">操作系统基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/16/java多线程基础/">java多线程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/Redis设计与实现笔记七/">Redis设计与实现笔记七</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/Redis设计与实现笔记六/">Redis设计与实现笔记六</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nowcoder/">nowcoder</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/信号处理/">信号处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/dp/" style="font-size: 15px;">dp</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/List/" style="font-size: 15px;">List</a> <a href="/tags/Set/" style="font-size: 15px;">Set</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/遍历/" style="font-size: 15px;">遍历</a> <a href="/tags/bfs/" style="font-size: 15px;">bfs</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/lms/" style="font-size: 15px;">lms</a> <a href="/tags/单例模式/" style="font-size: 15px;">单例模式</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/yxxyyx1314" title="github" target="_blank">github</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Yang Peng.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1ec291f029f752ac2c73c4f283e80301";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>