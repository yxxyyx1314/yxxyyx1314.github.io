[{"title":"nowcoder-括号匹配问题","date":"2019-06-30T23:44:08.000Z","path":"2019/07/01/nowcoder-括号匹配问题/","text":"题目来源：https://www.nowcoder.com/practice/380380e6c6b444888ae145593ccbbbca?tpId=90&amp;tqId=30840&amp;tPage=4&amp;rp=4&amp;ru=/ta/2018test&amp;qru=/ta/2018test/question-ranking 题目描述：合法的括号匹配序列被定义为: 空串””是合法的括号序列 如果”X”和”Y”是合法的序列,那么”XY”也是一个合法的括号序列 如果”X”是一个合法的序列,那么”(X)”也是一个合法的括号序列 每个合法的括号序列都可以由上面的规则生成例如””, “()”, “()()()”, “(()())”, “(((())))”都是合法的。 东东现在有一个合法的括号序列s,一次移除 操作分为两步: 移除序列s中第一个左括号 移除序列s中任意一个右括号.保证操作之后s还是一个合法的括号序列东东现在想知道使用上述的移除操作有多少种方案可以把序列s变为空如果两个方案中有一次移除操作移除的是不同的右括号就认为是不同的方案。例如: s = “()()()()()”,输出1, 因为每次都只能选择被移除的左括号所相邻的右括号.s = “(((())))”,输出24, 第一次有4种情况, 第二次有3种情况, … ,依次类推, 4 * 3 * 2 * 1 = 24 思路：反向遍历，用count记录”)“数量，用res记录结果，每次遍历到”)“则count加一，遍历到”(“则结果乘以count，表示该”(“可以匹配的”)”选择为count数，之后count减一继续遍历，遍历完序列后的res即为方案数量。 参考代码：12345678910111213141516171819public class now_64 &#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String input = bf.readLine(); int len=input.length(); int res=1; int count=0; for(int i=len-1;i&gt;=0;i--)&#123; if(input.charAt(i)==')')&#123; count++; &#125; else &#123; res*=count; count--; &#125; &#125; System.out.println(res); &#125;&#125;","tags":[{"name":"code","slug":"code","permalink":"http://ylovex.cn/tags/code/"},{"name":"Stack","slug":"Stack","permalink":"http://ylovex.cn/tags/Stack/"}]},{"title":"nowcoder-神奇数","date":"2019-06-30T23:40:06.000Z","path":"2019/07/01/nowcoder-神奇数/","text":"题目来源：https://www.nowcoder.com/practice/56d818ae68134c12b26e81f41ecafb9e?tpId=90&amp;tqId=30841&amp;tPage=4&amp;rp=4&amp;ru=%2Fta%2F2018test&amp;qru=%2Fta%2F2018test%2Fquestion-ranking 题目描述：/** 东东在一本古籍上看到有一种神奇数,如果能够将一个数的数字分成两组, 其中一组数字的和等于另一组数字的和,我们就将这个数称为神奇数。 例如242就是一个神奇数,我们能够将这个数的数字分成两组, 分别是{2,2}以及{4},而且这两组数的和都是4.东东现在需要统计给定区间中有多少个神奇数, 即给定区间[l, r],统计这个区间中有多少个神奇数,请你来帮助他。*/ 思路：设数字X，先求出X的每位数字存在List中，再求出X每位数字和，若为奇数则舍弃，若为偶数则判断是否是神奇数，通过动态规划，dp[i] [j]表示链表前i个数字能否求和得到j，则有dp[i] [j]=dp[i-1] [j] || dp[i-1] [j-list.get(i)];通过逆序循环将dp数组简化为一维数组。 参考代码：123456789101112131415161718192021222324252627282930313233343536public class now_65 &#123; public static void main(String[] args)throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String[] strings = bf.readLine().split(&quot; &quot;); int left = Integer.parseInt(strings[0]); int right = Integer.parseInt(strings[1]); int res = 0; for(int num = left ; num&lt;=right ; num++)&#123; if(isMagic(num))&#123; res++; &#125; &#125; System.out.println(res); &#125; private static boolean isMagic(int num) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int sum = 0; while (num&gt;0)&#123; list.add(num%10); sum+=num%10; num/=10; &#125; if(sum%2 != 0) return false; int mid = sum/2; int len = list.size(); boolean[] dp = new boolean[mid+1]; dp[0]=true; for(int i=0;i&lt;len;i++)&#123; for(int j=mid;j&gt;=list.get(i);j--)&#123; dp[j]=dp[j-list.get(i)] || dp[j]; &#125; &#125; return dp[mid]; &#125;&#125;","tags":[{"name":"code","slug":"code","permalink":"http://ylovex.cn/tags/code/"},{"name":"动态规划","slug":"动态规划","permalink":"http://ylovex.cn/tags/动态规划/"}]},{"title":"LMS算法","date":"2019-06-29T12:07:05.000Z","path":"2019/06/29/LMS算法/","text":"自适应滤波就是利用前一时刻获得的滤波器参数来自动调节现时刻的滤波器参数，以适应信号和噪声随时间变化的统计特性，从而实现最优滤波。 主输入端接收带噪信号，参考端为噪声信号，其中参考信号vi是与主输入端中信号s无关但与vo相关的噪声信号，利用量输入信号的相关性和有用信号与噪声的独立性，使参考信号尽可能逼近主输入端中的vo并相减从而抵消掉主输入端中的噪声干扰，最终得到有用信号。 算法代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function [yn,w,en,itr]=LMSALG(xn,dn,M,mu,itr)% LMS(Least Mean Squre)算法% 输入参数:% xn 输入的信号序列 (列向量) % dn 所期望的响应序列 (列向量) % M 滤波器的阶数 (标量) % mu 收敛因子(步长) (标量) 要求大于0,小于xn的相关矩阵最大特征值的倒数 % itr 迭代次数 (标量) 默认为xn的长度,M &lt; itr &lt;= length(xn) % 输出参数: % w 滤波器的权值矩阵 (矩阵) % 大小为M*itr, % en 误差序列(itr*1) (列向量) % yn 实际输出序列 (列向量)% 确定迭代次数，若输入迭代次数itr，则设置为itr；若没有该参数，则设置为输入信号长度% 参数个数必须为4个或5个if nargin == 4 % 4个时递归迭代的次数为xn的长度 itr = length(xn);elseif nargin == 5 % 5个时需满足 M &lt; itr &lt; length(xn) if itr &gt; length(xn) || itr &lt; M error(&apos;迭代次数过大或过小!&apos;); endelse error(&apos;请检查输入参数的个数!&apos;); end % 初始化参数en = zeros(itr,1); % 误差序列,en(k)表示第k次迭代时预期输出与实际输入的误差w = zeros(itr,M); % 每一行代表一个加权参量,每一列代表-次迭代,初始为0% w权系数取为矩阵主要是为了判断该算法的收敛性xn_r=xn&apos;; %%%%参考行向量dn_r=dn&apos;; %%%%nmr行向量% 迭代计算for kitr = M:itr % 第k次迭代 x = xn(kitr:-1:kitr-M+1); % 滤波器M个抽头的输入 y = w(kitr-1,:)*x; % 滤波器的输出 en(kitr) = dn(kitr) - y; % 第k次迭代的误差 % 滤波器权值计算的迭代式 w(kitr,:) = w(kitr-1,:) + 2*mu*en(kitr)*x&apos;;%%xn(kitr-M+1:kitr)&apos;;end%%%方法一、直接使用filter函数来进行滤波处理CancellationData = filter(w(end,:),1,xn_r); % 直接使用filter函数来进行滤波处理yn = dn_r-CancellationData;yn = yn(M+1:end);% 去掉与滤波系数长度对应的前N个点yn=yn&apos;; %%输出行向量% % 求最优时滤波器的输出序列% yn = zeros(size(xn)); % for kitr = M:length(xn)% x = xn(kitr:-1:kitr-M+1);% yn(kitr) = dn(kitr) - w(end,:)*x; % w(:,end)为最后一次迭代生成的滤波器系数% end% yn = yn(M:end); % 前面M个数据没有经过滤波处理，所以设置成inf，绘图时不显示","tags":[{"name":"lms","slug":"lms","permalink":"http://ylovex.cn/tags/lms/"}]},{"title":"Java List面经","date":"2019-06-28T13:54:41.000Z","path":"2019/06/28/java-list面经/","text":"ListList是一个接口，继承于Collenction接口，它代表着有序的队列。 ​ ps：java.util.Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法；javautil.Collections是一个包装类，它包含各种有关集合操作的静态多态方法，该类不能实例化，服务于Collection框架。 ArrayList：底层是用数组实现。 LinkedList：底层是通过双向链表实现。 Vector：通过数组实现，线程安全。 ArrayList扩容默认初始容量为10. 12345678/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; transient Object[] elementData; // non-private to simplify nested class access private int size; 扩容，默认为1.5倍方式 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; ArrayList和LinkedListArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。 对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对 ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。 在ArrayList集合中添加或者删除一个元素时，当前的列表所所有的元素都会被移动。而LinkedList集合中添加或者删除一个元素的开销是固定的。 LinkedList集合不支持高效的随机随机访问（RandomAccess），因为可能产生二次项的行为。 ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。 Arrays.asList()方法123456int[] a = &#123;1,2,3,4&#125;; List a_list = Arrays.asList(a); System.out.println(a_list.size());//size=1 Integer[] b = &#123;1,2,3,4&#125;; List b_list = Arrays.asList(b); System.out.println(b_list.size());//size=4 Arrays.asList方法返回的是List，通过Arrays类的一个内部类实现，内部用的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反应到List中，对List调用add/remove方法会抛出异常。 使用ArrayList方法实现为： 1List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(a)); ArrayList线程不安全12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 因为ArrayList本身不是线程安全的，通过Collections.synchronizedList可以将其包装成一个线程安全的List。 Vector和ArrayListvector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。 如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"},{"name":"List","slug":"List","permalink":"http://ylovex.cn/tags/List/"}]},{"title":"Java Set面经","date":"2019-06-28T13:54:41.000Z","path":"2019/06/28/java-set面经/","text":"Set种类Set接口的特性，Set接口继承了Collection接口，Set集合中不能包含重复的元素，每个元素必须是唯一的，你只要将元素加入set中，重复的元素会自动移除。 Java中提供了HashSet、TreeSet、LinkedHashSet三种常用的Set实现。 HashSet实现HashSet底层通过HashMap实现。 123456789101112private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; HashSet存储元素是无序的，元素的哈希码进行存储的，HashSet根据每个存储对象的哈希码值（调用hashCode方法获得），用固定的算法算出它的存储索引，把存储对象存放在一个叫做散列表的相应位置中，如果对应的位置没有其它元素，就只需要直接存入；如果该位置已经有元素了，就会将新对象跟该位置的所有对象进行比较（调用equals（）方法），以查看容器中是否已经存在该对象，若不存在，就存放该对象，若已经存在，就直接使用该对象。 HashSet的存储结构是个链表数组，每一个数组元素就是一个链表，类似这种数据结构称为散列表。数组用于存储元素，该存储元素对应的数组下标是调用hashCode方法返回的存储元素的哈希码。当后加入元素的哈希码与已经加入的元素哈希码相同时，HashSet就会创建一个链表，将相同哈希码的元素存入一个链表，并将该链表的头指针存储到哈希码对应的数组元素中。 HashSet和TreeSetHashSet底层数据结构是哈希表，TreeSet底层数据结构是红黑树。 TreeSet保证元素的排序方式： 自然排序(这种排序方式可以理解成元素本身具备比较性)让元素所属的类实现Comparable接口。 比较器排序(这种排序可以理解成集合类具备比较性)让集合构造方法接收Comparator的实现类对象，实现方式可以用匿名类来实现。 LinkedHashSet是HashSet子类，LinkedHashSet集合也是根据元素hashCode值来决定元素存储位置，但它同时使用链表维护元素的次序，这样使的元素看起来是以插入的顺序保存的。也就是说当遍历LinkedHashSet集合里的元素时，HashSet将会按元素的添加顺序来访问集合里的元素。 LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但是在迭代访问Set里的全部元素时，将有很好的性能，因为它以列表来维护内部顺序。","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"},{"name":"Set","slug":"Set","permalink":"http://ylovex.cn/tags/Set/"}]},{"title":"Java Map面经","date":"2019-06-28T13:54:41.000Z","path":"2019/06/28/java-map面经/","text":"HashMap实现原理 参考https://www.cnblogs.com/chengxiao/p/6059914.html Entry内部结构为： HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，即链地址法。HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对和一个hash值和一个指向下一个Entry的next指针。 如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即 如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，操作是创建新节点，把该新节点插入到链表中的头部，该新节点的next指针指向原来的头结点 ，即需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。 所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作 如果key为null，就会插入到table[0]的位置也就是数组头。如果key=null，则hash值直接赋0 存key时，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回：这就是为什么HashMap不能有两个相同的key的原因。 计算hash值之后，如何通过hash值均匀的存到数组里？当然是取模，但取模消耗大，因此HashMap用的&amp;运算符（按位与操作）来实现的：hashCode &amp; (length-1)。 这里就隐含了为什么数组长度length一定要是2的n次方。当length不是2的n次方的时候，length-1的二进制最后一位肯定是0，在&amp;操作时，一个为0，无论另一个为1还是0，最终&amp;操作结果都是0，这就造成了结果的二进制的最后一位都是0，这就导致了所有数据都存储在2的倍数位上，所以说，所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。 存储过程： 传入key和value，判断key是否为null，如果为null，则调用putForNullKey，以null作为key存储到哈希表中； 2. 然后计算key的hash值，根据hash值搜索在哈希表table中的索引位置，若当前索引位置不为null，则对该位置的Entry链表进行遍历，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回，结束； 3. 否则调用addEntry，用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部 读取过程： 调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null。 JDK1.8前后HashMap区别 在JDK1.8以前版本中，HashMap的实现是数组+链表，它的缺点是即使哈希函数选择的再好，也很难达到元素百分百均匀分布，而且当HashMap中有大量元素都存到同一个桶中时，这个桶会有一个很长的链表，此时遍历的时间复杂度就是O(n)，当然这是最糟糕的情况。 在JDK1.8及以后的版本中引入了红黑树结构，HashMap的实现就变成了数组+链表或数组+红黑树。添加元素时，若桶中链表个数超过8，链表会转换成红黑树；删除元素、扩容时，若桶中结构为红黑树并且树中元素个数较少时会进行修剪或直接还原成链表结构，以提高后续操作性能；遍历、查找时，由于使用红黑树结构，红黑树遍历的时间复杂度为 O(logn)，所以性能得到提升。 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; HashMap扩容HashMap扩容可以分为三种情况： 使用默认构造方法初始化HashMap。HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。 指定初始容量的构造方法初始化HashMap。初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。 HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。 HashMap是先插入数据再进行扩容的，但是如果是刚刚初始化容器的时候是先扩容再插入数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 参考https://blog.csdn.net/pange1991/article/details/82347284 HashMap多线程问题HashMap在多线程情况下出现死循环主要是在1.7情况下面，存在多线程时候应该使用ConcurrentHashMap。 12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); &#125; 12345678910111213141516171819202122void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; //循环取出原数组中每一个链表，e本身也是一个链表的节点，同时包含下一个节点的连接, //此处e表示第一个节点，next表示链表的下一个节点 if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); //计算在新数组中的存储位置 e.next = newTable[i]; //将原数组链表的第一个元素的next指向新数组，若新数组中已经存在元素， //则这个元素为第一个元素，next属性为原节点地址 newTable[i] = e; //将新数组的头节点指向e，此时e(原数组中的第一个元素)已经成功的转移到了新数据中 e = next; //继续处理原数组中剩下的节点 &#125; &#125; &#125; 参考https://www.jianshu.com/p/1ff9f3dee207 HashMap和HashTable Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。 Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 HashTable和synchronizedMap和ConcurrentHashMapHashTable、synchronizedMap效率低下 现在基本不用HashTable。HashTable容器使用synchronized来保证线程安全，但是锁的是整个hash表，当一个线程使用 put 方法时，另一个线程不但不可以使用 put 方法，连 get 方法都不可以。 synchronizedMap比HashTable强一分钱，synchronizedMap提供一个不同步的基类和一个同步的包装。允许需要同步的用户可以拥有同步，而不需要同步的用户则不必为同步付出代价，get方法与HashTable一样锁住整个hash表，区别是get()和put()之类的简单操作可以在不需要额外同步的情况下安全地完成。但多个操作组成的操作序列却可能导致数据争用，总之就是不好用。 ConcurrentHashMap效率高，因为用了分段锁（JDK8之前），16个 HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁 那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率 这就是 ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，默认分成16个段，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 上面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个hash表。 ConcurrentHashMap JDK1.8基本结构：Node&lt;K,V&gt;数组+链表（红黑树）的结构。 而对于锁的粒度，调整为对每个数组元素加锁（Node），即没有分段锁了，而是Node锁，粒度更小。 使用CAS操作来确保Node的一些操作的原子性，这种方式代替了锁。 ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，但同时降低了读一致性。ConcurrentHashMap的get操作上面并没有加锁。所以在多线程操作的过程中，并不能完全的保证一致性。这里和1.7当中类似，是弱一致性的体现。 代码中使用synchronized而不是ReentrantLock，说明JDK8中synchronized有了足够的优化。 然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。 因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O(n)变为O(logN)。 ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响。 HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性。 HashMap读取与写入1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"},{"name":"Map","slug":"Map","permalink":"http://ylovex.cn/tags/Map/"}]},{"title":"Java 基础知识","date":"2019-06-28T13:43:41.000Z","path":"2019/06/28/java-基础/","text":"面向对象和面向过程 面向过程：是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。 面向对象：是以“对象”为中心的编程思想。 面向对象三大特性：封装、继承、多态。因为一切皆对象，所以一切都需要“封装”成类。“继承”让我们设计相似的东西的时候更方便，而“多态”让我们使用类似的东西的时候可以不用去思考它们微弱的不同。我们关心的不是过程，而是接口，而接口来自对象，故名为面向对象。 封装、继承、多态 封装：通过隐藏类的内部实现机制，对外界提供已经定义好的接口进行访问。对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 继承：是从已有的类得到继承信息创建新的类的过程，继承可以表示为is-a关系，让我们设计相似的东西的时候更加的方便。 多态：可以分为方法重载和方法重写两种方式，方法重载是在编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致；方法重写是运行时多态（也称为后绑定），实现方法重写：1.方法重写，子类继承父类并重写父类方法；2.用父类型引用来引用子类型对象，实现调用同样的方法会根据子类对象的不同表示出不一样的行为。 反射 Java的反射机制允许我们动态的调用某个对象的方法、构造函数、获取某个对象的属性等； 无需在编码的时候确定调用的对象 实现方式： 先获取这个类的class实例，比如:Class&lt;?&gt; myClass =Class.forName(“myClassName”); 然后通过这个类实例获得一个类对象，比如：Object myClassObject = myClass.newInstance(); 然后调用Class类的对象的getMethod获取method对象; 获取method对象后调用method.invoke方法获取这个类的field、method、construct等，在这一步中，JVM默认如果调用次数小于15次，会调用native方法实现反射，累积调用大于15次之后，会由java代码创建出字节码来实现反射。 集合实现了Collection接口的集合类： Collection&lt;–List&lt;–Vector Collection&lt;–List&lt;–ArrayList Collection&lt;–List&lt;–LinkedList Collection&lt;–Set&lt;–HashSet Collection&lt;–Set&lt;–HashSet&lt;–LinkedHashSet Collection&lt;–Set&lt;–SortedSet&lt;–TreeSet 实现了Map接口，和Collection接口没关系，但都属于集合类的一部分： HashMap HashTable LinkedHashMap TreeMap SynchronizedMap ConcurrentHashMap final和static被final声明的对象即表示“我不想这个对象再被改变”，因此： 被final声明的方法：这个方法不可以被子类重写 被final声明的类：这个类不能被继承 被final声明的变量：引用不能改变，常和static关键字一起使用作为常量final关键字的好处： final关键字提高了性能。JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法、变量及类进行优化。 static关键字 final关键字提高了性能。JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法、变量及类进行优化。 数据类型 boolean byte char ：都是一个字节 short int long float double ：int是4个字节，负2的31次方到正2的31次方减1 String Enum Array Object ps：负数使用补码表示 Primitive type: int,long,float… Object: Integer,Long,Float,String… Primitive type: 值类型 用a==b判断相等 Object： 引用类型 用a==b判断是否为同一个Object 用a.equals(b),或者Obeject.equals(a,b)判断是否相等 两个Object如果不是同一个Object，即使值相等用==判断也是false 数组和链表基于空间的考虑： 数组的存储空间是静态，连续分布的，初始化的过大造成空间浪费，过小又将使空间溢出机会增多。而链表的存储空间是动态分布的，只要内存空间尚有空闲，就不会产生溢出；链表中每个节点出了数据域外，还有链域（指向下一个节点），这样空间利用率就会变高。 数组从栈中分配空间，对于程序员方便快速，但是自由度小。链表从堆中分配空间，自由度大但是申请管理比较麻烦。 数组中的数据在内存中按顺序存储的，而链表是随机存储的。 基于时间的考虑： 数组查询快，插入与删除慢，单链表查询慢，插入与删除快。细说的话：数组中任意节点都可以在O（1）内直接存储访问，而链表中的节点，需从头指针顺着链表扫描才能获取到；而链表任意位置进行插入和删除，都只需要修改指针，而数组中插入删除节点，平均要移动一半的节点。 访问控制符 public protected defailt private 同一个类 True True True True 同一个包 True True True False 子父类 True True False False 不同包 True False False False 接口与抽象类抽象类就是比普通类多了一些抽象方法而已，其他部分和普通类完全一样；而接口是特殊的抽象类。作用上看： 接口与抽象类结构有点像，但功能完全不同 接口是强调合约、约束关系，即你要与我合作，必须实现我的功能；抽象类没这个功能 语法上看： 都不能被实例化 接口是特殊的抽象类 接口不能有实现，Java8中可以有添加default关键字的默认实现和静态方法实现。 接口中的成员变量必须是public static final修饰（编译器默认会添加上），因此是常量 一个类可以实现多个接口但只能继承一个抽象类 什么是接口？ 从表现来说：定义了很多函数，但是这些函数都没有实现，这就是接口。从作用来说：起到一个合约规范的作用。我要告诉你和我打交道的东西有什么约束 接口中的方法只能用public和abstract修饰或者不修饰 接口中的属性默认都是public static final，因此是常量 equal与==对于字符串变量： ==：比较两个对象在内存中的首地址 equals：比较字符串中所包含的内容是否相同 对于非字符串变量： ==和equals都是比较对象在堆内存中的首地址。 装箱及拆箱Integer i = 10; //装箱 int n = i ;//拆箱 装箱就是自动将基本数据类型转换为包装器类型。 拆箱就是自动将包装器类型转换为基本数据类型。 hashCode方法及作用Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的 字段等）映射成一个数值，这个数值称作为散列值。 1、在Java集合中有两类，一类是List，一类是Set。他们之间的区别就在于List集合中的元素是有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知2、当集合要添加新的对象时，先调用这个对象的 hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode 值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址3、所以hashCode在上面扮演的角色为快速寻域（寻找某个对象在集合中区域位置） 在重写equals方法的同时，必须重写hashCode方法。为什么这么说呢？1、让equals方法和hashCode方法始终在逻辑上保持一致性2、即让equals认为相等的两个对象，这两个对象同时调用hashCode方法，返回的值也是一样的 Java8新特性Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 Java NIO框架对比Mina Mina(Multipurpose Infrastructure for Network Applications) 是 Apache 组织一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 Mina 版本2.04支持基于 Java NIO 技术的 TCP/UDP 应用程序开发、串口通讯程序，Mina 所支持的功能也在进一步的扩展中。 Netty Netty是一款异步的事件驱动的网络应用框架和工具，用于快速开发可维护的高性能、高扩展性协议服务器和客户端。也就是说，Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器。 Grizzly Grizzly是一种应用程序框架，专门解决编写成千上万用户访问服务器时候产生的各种问题。使用JAVA NIO作为基础，并隐藏其编程的复杂性。容易使用的高性能的API。带来非阻塞socketd到协议处理层。利用高性能的缓冲和缓冲管理使用高性能的线程池。 xSocket xSocket是一个轻量级的基于nio的服务器框架用于开发高性能、可扩展、多线程的服务器。该框架封装了线程处理、异步读/写等方面。（只是对Java的NIO做了最简单的封装，以便于开发使用。","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"}]},{"title":"my first blog","date":"2019-06-28T13:41:41.000Z","path":"2019/06/28/my-first-blog/","text":"Desire is the starting point of all achievement 渴望是所有成就的原点。 love xy","tags":[{"name":"Life","slug":"Life","permalink":"http://ylovex.cn/tags/Life/"}]},{"title":"Hello World","date":"2019-06-28T05:32:33.400Z","path":"2019/06/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]