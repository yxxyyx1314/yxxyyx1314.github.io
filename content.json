[{"title":"LMS算法","date":"2019-06-29T12:07:05.000Z","path":"2019/06/29/LMS算法/","text":"自适应滤波就是利用前一时刻获得的滤波器参数来自动调节现时刻的滤波器参数，以适应信号和噪声随时间变化的统计特性，从而实现最优滤波。 主输入端接收带噪信号，参考端为噪声信号，其中参考信号vi是与主输入端中信号s无关但与vo相关的噪声信号，利用量输入信号的相关性和有用信号与噪声的独立性，使参考信号尽可能逼近主输入端中的vo并相减从而抵消掉主输入端中的噪声干扰，最终得到有用信号。 算法代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function [yn,w,en,itr]=LMSALG(xn,dn,M,mu,itr)% LMS(Least Mean Squre)算法% 输入参数:% xn 输入的信号序列 (列向量) % dn 所期望的响应序列 (列向量) % M 滤波器的阶数 (标量) % mu 收敛因子(步长) (标量) 要求大于0,小于xn的相关矩阵最大特征值的倒数 % itr 迭代次数 (标量) 默认为xn的长度,M &lt; itr &lt;= length(xn) % 输出参数: % w 滤波器的权值矩阵 (矩阵) % 大小为M*itr, % en 误差序列(itr*1) (列向量) % yn 实际输出序列 (列向量)% 确定迭代次数，若输入迭代次数itr，则设置为itr；若没有该参数，则设置为输入信号长度% 参数个数必须为4个或5个if nargin == 4 % 4个时递归迭代的次数为xn的长度 itr = length(xn);elseif nargin == 5 % 5个时需满足 M &lt; itr &lt; length(xn) if itr &gt; length(xn) || itr &lt; M error(&apos;迭代次数过大或过小!&apos;); endelse error(&apos;请检查输入参数的个数!&apos;); end % 初始化参数en = zeros(itr,1); % 误差序列,en(k)表示第k次迭代时预期输出与实际输入的误差w = zeros(itr,M); % 每一行代表一个加权参量,每一列代表-次迭代,初始为0% w权系数取为矩阵主要是为了判断该算法的收敛性xn_r=xn&apos;; %%%%参考行向量dn_r=dn&apos;; %%%%nmr行向量% 迭代计算for kitr = M:itr % 第k次迭代 x = xn(kitr:-1:kitr-M+1); % 滤波器M个抽头的输入 y = w(kitr-1,:)*x; % 滤波器的输出 en(kitr) = dn(kitr) - y; % 第k次迭代的误差 % 滤波器权值计算的迭代式 w(kitr,:) = w(kitr-1,:) + 2*mu*en(kitr)*x&apos;;%%xn(kitr-M+1:kitr)&apos;;end%%%方法一、直接使用filter函数来进行滤波处理CancellationData = filter(w(end,:),1,xn_r); % 直接使用filter函数来进行滤波处理yn = dn_r-CancellationData;yn = yn(M+1:end);% 去掉与滤波系数长度对应的前N个点yn=yn&apos;; %%输出行向量% % 求最优时滤波器的输出序列% yn = zeros(size(xn)); % for kitr = M:length(xn)% x = xn(kitr:-1:kitr-M+1);% yn(kitr) = dn(kitr) - w(end,:)*x; % w(:,end)为最后一次迭代生成的滤波器系数% end% yn = yn(M:end); % 前面M个数据没有经过滤波处理，所以设置成inf，绘图时不显示","tags":[{"name":"lms","slug":"lms","permalink":"http://ylovex.cn/tags/lms/"}]},{"title":"Java List面经","date":"2019-06-28T13:54:41.000Z","path":"2019/06/28/java-list面经/","text":"Desire is the starting point of all achievement 渴望是所有成就的原点。","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"},{"name":"List","slug":"List","permalink":"http://ylovex.cn/tags/List/"}]},{"title":"Java Map面经","date":"2019-06-28T13:54:41.000Z","path":"2019/06/28/java-map面经/","text":"HashMap实现原理JDK1.8前后HashMap区别HashMap扩容HashMap多线程问题HashMap和HashTableHashTable和synchronizedMap和ConcurrentHashMapConcurrentHashMap JDK1.8HashMap读取与写入","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"},{"name":"Map","slug":"Map","permalink":"http://ylovex.cn/tags/Map/"}]},{"title":"Java Set面经","date":"2019-06-28T13:54:41.000Z","path":"2019/06/28/java-set面经/","text":"Desire is the starting point of all achievement 渴望是所有成就的原点。","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"},{"name":"Set","slug":"Set","permalink":"http://ylovex.cn/tags/Set/"}]},{"title":"Java 基础知识","date":"2019-06-28T13:43:41.000Z","path":"2019/06/28/java-基础/","text":"面向对象和面向过程 面向过程：是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。 面向对象：是以“对象”为中心的编程思想。 面向对象三大特性：封装、继承、多态。因为一切皆对象，所以一切都需要“封装”成类。“继承”让我们设计相似的东西的时候更方便，而“多态”让我们使用类似的东西的时候可以不用去思考它们微弱的不同。我们关心的不是过程，而是接口，而接口来自对象，故名为面向对象。 封装、继承、多态 封装：通过隐藏类的内部实现机制，对外界提供已经定义好的接口进行访问。对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 继承：是从已有的类得到继承信息创建新的类的过程，继承可以表示为is-a关系，让我们设计相似的东西的时候更加的方便。 多态：可以分为方法重载和方法重写两种方式，方法重载是在编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致；方法重写是运行时多态（也称为后绑定），实现方法重写：1.方法重写，子类继承父类并重写父类方法；2.用父类型引用来引用子类型对象，实现调用同样的方法会根据子类对象的不同表示出不一样的行为。 反射 Java的反射机制允许我们动态的调用某个对象的方法、构造函数、获取某个对象的属性等； 无需在编码的时候确定调用的对象 实现方式： 先获取这个类的class实例，比如:Class&lt;?&gt; myClass =Class.forName(“myClassName”); 然后通过这个类实例获得一个类对象，比如：Object myClassObject = myClass.newInstance(); 然后调用Class类的对象的getMethod获取method对象; 获取method对象后调用method.invoke方法获取这个类的field、method、construct等，在这一步中，JVM默认如果调用次数小于15次，会调用native方法实现反射，累积调用大于15次之后，会由java代码创建出字节码来实现反射。 集合实现了Collection接口的集合类： Collection&lt;–List&lt;–Vector Collection&lt;–List&lt;–ArrayList Collection&lt;–List&lt;–LinkedList Collection&lt;–Set&lt;–HashSet Collection&lt;–Set&lt;–HashSet&lt;–LinkedHashSet Collection&lt;–Set&lt;–SortedSet&lt;–TreeSet 实现了Map接口，和Collection接口没关系，但都属于集合类的一部分： HashMap HashTable LinkedHashMap TreeMap SynchronizedMap ConcurrentHashMap final和static被final声明的对象即表示“我不想这个对象再被改变”，因此： 被final声明的方法：这个方法不可以被子类重写 被final声明的类：这个类不能被继承 被final声明的变量：引用不能改变，常和static关键字一起使用作为常量final关键字的好处： final关键字提高了性能。JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法、变量及类进行优化。 static关键字 final关键字提高了性能。JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法、变量及类进行优化。 数据类型 boolean byte char ：都是一个字节 short int long float double ：int是4个字节，负2的31次方到正2的31次方减1 String Enum Array Object ps：负数使用补码表示 Primitive type: int,long,float… Object: Integer,Long,Float,String… Primitive type: 值类型 用a==b判断相等 Object： 引用类型 用a==b判断是否为同一个Object 用a.equals(b),或者Obeject.equals(a,b)判断是否相等 两个Object如果不是同一个Object，即使值相等用==判断也是false 数组和链表基于空间的考虑： 数组的存储空间是静态，连续分布的，初始化的过大造成空间浪费，过小又将使空间溢出机会增多。而链表的存储空间是动态分布的，只要内存空间尚有空闲，就不会产生溢出；链表中每个节点出了数据域外，还有链域（指向下一个节点），这样空间利用率就会变高。 数组从栈中分配空间，对于程序员方便快速，但是自由度小。链表从堆中分配空间，自由度大但是申请管理比较麻烦。 数组中的数据在内存中按顺序存储的，而链表是随机存储的。 基于时间的考虑： 数组查询快，插入与删除慢，单链表查询慢，插入与删除快。细说的话：数组中任意节点都可以在O（1）内直接存储访问，而链表中的节点，需从头指针顺着链表扫描才能获取到；而链表任意位置进行插入和删除，都只需要修改指针，而数组中插入删除节点，平均要移动一半的节点。 访问控制符 public protected defailt private 同一个类 True True True True 同一个包 True True True False 子父类 True True False False 不同包 True False False False 接口与抽象类抽象类就是比普通类多了一些抽象方法而已，其他部分和普通类完全一样；而接口是特殊的抽象类。作用上看： 接口与抽象类结构有点像，但功能完全不同 接口是强调合约、约束关系，即你要与我合作，必须实现我的功能；抽象类没这个功能 语法上看： 都不能被实例化 接口是特殊的抽象类 接口不能有实现，Java8中可以有添加default关键字的默认实现和静态方法实现。 接口中的成员变量必须是public static final修饰（编译器默认会添加上），因此是常量 一个类可以实现多个接口但只能继承一个抽象类 什么是接口？ 从表现来说：定义了很多函数，但是这些函数都没有实现，这就是接口。从作用来说：起到一个合约规范的作用。我要告诉你和我打交道的东西有什么约束 接口中的方法只能用public和abstract修饰或者不修饰 接口中的属性默认都是public static final，因此是常量 equal与==装箱及拆箱hashCode方法及作用Java8新特性Java NIO框架对比","tags":[{"name":"Java","slug":"Java","permalink":"http://ylovex.cn/tags/Java/"}]},{"title":"my first blog","date":"2019-06-28T13:41:41.000Z","path":"2019/06/28/my-first-blog/","text":"Desire is the starting point of all achievement 渴望是所有成就的原点。","tags":[{"name":"Life","slug":"Life","permalink":"http://ylovex.cn/tags/Life/"}]},{"title":"Hello World","date":"2019-06-28T05:32:33.400Z","path":"2019/06/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]